{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cosmic-Ray Neutron Python (CRNPy) Library","text":"<p>Welcome to the homepage of the CRNPy (Cosmic-Ray Neutron Python) library, an open-source Python library designed for the processing and conversion of raw neutron counts from cosmic-ray neutron probes (CRNP) into soil moisture data.</p> <p>This library has been developed with the intent of providing a comprehensive yet easy-to-use workflow for processing raw data from a variety of CRNP, encompassing multiple manufacturers and models.</p>"},{"location":"#statement-of-need","title":"Statement of Need","text":"<p>CRNPs are a valuable tool for non-invasive soil moisture estimation at the hectometer scale (e.g., typical agricultural fields), filling the gap between point-level sensors and large-scale (i.e., several kilometers) remote sensors onboard orbiting satellites. However, cleaning, processing, and analyzing CRNP data involves multiple corrections and filtering steps spread across multiple peer-reviewed manuscripts. CRNPy simplifies these steps by providing a complete, user-friendly, and well-documented library with minimal dependencies that includes examples to convert raw CRNP data into soil moisture. The library is designed to be accessible to both researchers and instrument manufacturers. Unlike other similar libraries, CRNPy does not require any specific naming convention for the input data or large external data sources, or reanalysis data.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Versatile and instrument agnostic: CRNPy can handle data from various CRNP manufacturers and models. It has been successfully tested on both roving and stationary CRNP.</p> </li> <li> <p>Modular: The library is designed to be modular, allowing users to easily customize the processing workflow to their needs.</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install the CRNPy library, you can use Python's package manager. Open a terminal and type:</p> <p><code>pip install crnpy</code></p> <p>from the Jupyter notebook, type:</p> <p><code>!pip install crnpy</code></p> <p>Ideally dependencies should be installed automatically. If not, you can install them manually by typing:</p> <p><code>pip install -r requirements.txt</code></p> <p>The CRNPy library is compatible with Python 3.7 and above. See requirements.txt for a list of dependencies.</p>"},{"location":"#authors","title":"Authors","text":"<p>The CRNPy library was developed at the Kansas State University Soil Water Processes Lab by:</p> <ul> <li> <p>Joaquin Peraza</p> </li> <li> <p>Andres Patrignani</p> </li> </ul> <p>The Soil Water Processes Lab at Kansas State University combines a range of experimental and computational approaches to tackle pressing issues in soil and water research. The development of the CRNPy library is a step forward to creating reproducible data processing workflows across the scientific community using cosmic-ray neutrons probes for soil moisture sensing. </p>"},{"location":"#community-guidelines","title":"Community Guidelines","text":""},{"location":"#contributing","title":"Contributing","text":"<p>To contribute to the software, please first fork the repository and create your own branch from <code>main</code>. Ensure your code adheres to our established standards and includes appropriate test coverage. Then, submit a pull request with a clear and detailed description of your changes.</p>"},{"location":"#reporting-issues","title":"Reporting Issues","text":"<p>If you encounter any issues or problems with the software, please report them on our issues page. Include a detailed description of the issue, steps to reproduce the problem, any error messages you received, and details about your operating system and software version.</p>"},{"location":"#seeking-support","title":"Seeking Support","text":"<p>If you need support, please first refer to the documentation. If you still require assistance, post a question on the issues page with the <code>question</code> tag. For private inquiries, you can reach us via email at jperaza@ksu.edu or andrespatrignani@ksu.edu.</p>"},{"location":"correction_routines/","title":"Correction routines","text":""},{"location":"correction_routines/#overview","title":"Overview","text":"<p>The CRNPy library provides the tools to correct and process neutron counts recorded with both stationary and roving cosmic-ray neutron probes. Below are two flowcharts describing the typical steps from the correction of raw neutron counts to the conversion into volumetric soil water content.</p>"},{"location":"correction_routines/#stationary-crnp-processing","title":"Stationary CRNP processing","text":"<p> Dashed lines indicate optional steps. See the complete example notebook.</p>"},{"location":"correction_routines/#roving-crnp-processing","title":"Roving CRNP processing","text":"<p> Dashed lines indicate optional steps. See the complete example notebook.</p>"},{"location":"correction_routines/#incoming-neutron-flux","title":"Incoming neutron flux","text":"<p>The CRNPy library includes a complete set of methods for correcting the raw observed neutron counts for natural variation in the incoming neutron flux, including a set of tools for searching and downloading data from reference neutron monitors from the NMDB database (www.nmdb.eu) with similar the cut-off rigidity as the study location (Klein et al., 2009; Shea &amp; Smart., 2019).</p> Incoming neutron flux correction factor $fi = \\frac{I_{m}}{I_{0}}$ $ fi $: Incoming neutron flux correction factor $ I_{m} $: Measured incoming neutron flux $ I_{0} $: Reference incoming neutron flux at a given time. <p>Implementation</p> <p>See  crnpy.crnpy.cutoff_rigidity, crnpy.crnpy.find_neutron_monitor, crnpy.crnpy.get_incoming_neutron_flux, crnpy.crnpy.interpolate_incoming_flux and crnpy.crnpy.incoming_flux_correction documentation for the implementation details.</p>"},{"location":"correction_routines/#atmospheric-corrections","title":"Atmospheric corrections","text":"<p>The CRNPy library also provides functions for correcting raw neutron counts for atmospheric pressure, air humidity, and air temperature (Andreasen et al., 2017; Rosolem et al., 2013).</p> Pressure correction Atmospheric water correction $fp = exp(\\frac{P_{0} - P}{L})$ $fw = 1 + 0.0054*(A - Aref)$ $fp$: Atmospheric pressure correction factor $fw$: Atmospheric water correction factor $P_{0}$: Reference atmospheric pressure (for e.g. long-term average) $A$: Atmospheric absolute humidity (g/m3) $P$: Measured atmospheric pressure $Aref$: Reference atmospheric absolute humidity (g/m3) $L$: Mass attenuation factor for high-energy neutrons in air <p>Implementation</p> <p>See crnpy.crnpy.humidity_correction and crnpy.crnpy.pressure_correction documentation for the implementation details.</p>"},{"location":"correction_routines/#biomass-correction","title":"Biomass correction","text":"<p>The library provides a function for correcting neutron counts for the effects of above-ground biomass by combining an approach for estimating biomass water equivalent (BWE) from in-situ biomass samples and the BWE correction factor (Baatz et al., 2015).</p> Biomass correction $fb = 1 - bwe*r2_N0$ $fb$: Biomass correction factor $bwe$: Biomass water equivalent $r2_N0$: Ratio of the neutron counts reduction ($counts kg^-1$) to the neutron calibration constant (N0) <p>Implementation</p> <p>See crnpy.crnpy.bwe_correction and crnpy.crnpy.biomass_to_bwe documentation for the implementation details.</p>"},{"location":"correction_routines/#road-correction","title":"Road correction","text":"<p>The lCRNPY library includes functions to correct for the effect of roads during rover surveys which account for the field soil water content and the road water content following the approach proposed by Schr\u00f6n et al., (2018).</p> Road correction $fr = 1 + F1 \\cdot F2 \\cdot F3$ $fr$: Road correction factor $F1$: Road geometry term $F2$: Road moisture term $F3$: Road distance term <p>Implementation</p> <p>See crnpy.crnpy.road_correction documentation for the implementation details.</p>"},{"location":"correction_routines/#additional-corrections","title":"Additional corrections","text":"<p>Other correction routines includes corrections for soil lattice water and total soil carbon that are known to affect the attentuation of epithermal cosmic-ray neutrons. A function to estimate the soil lattice water content based on clay content and soil organic carbon content was developed using soil samples collected across the state of Kansas.</p> <p>Implementation</p> <p>See crnpy.crnpy.estimate_lattice_water and crnpy.crnpy.counts_to_vwc documentation for the implementation details.</p> <p>References</p> <p>Klein, K.-L., Steigies, C., &amp; Nmdb Team. (2009). WWW.NMDB.EU: The real-time Neutron Monitor database. EGU General Assembly Conference Abstracts, 5633.</p> <p>Shea, M., &amp; Smart, D. (2019). Re-examination of the first five ground-level events. International Cosmic Ray Conference (ICRC2019), 36, 1149.</p> <p>Smart, D., &amp; Shea, M. (2001). Geomagnetic cutoff rigidity computer program: Theory, software description and example.</p> <p>Andreasen, M., Jensen, K. H., Desilets, D., Franz, T. E., Zreda, M., Bogena, H. R., &amp; Looms, M. C. (2017). Status and perspectives on the cosmic-ray neutron method for soil moisture estimation and other environmental science applications. Vadose Zone Journal, 16(8), 1\u201311.</p> <p>Rosolem, R., Shuttleworth, W. J., Zreda, M., Franz, T. E., Zeng, X., &amp; Kurc, S. A. (2013). The effect of atmospheric water vapor on neutron count in the cosmic-ray soil moisture observing system. Journal of Hydrometeorology, 14(5), 1659\u20131671.</p> <p>Zreda, M., Desilets, D., Ferr\u00e9, T., &amp; Scott, R. L. (2008). Measuring soil moisture content non-invasively at intermediate spatial scale using cosmic-ray neutrons. Geophysical Research Letters, 35(21).</p> <p>Dong, J., &amp; Ochsner, T. E. (2018). Soil texture often exerts a stronger influence than precipitation on mesoscale soil moisture patterns. Water Resources Research, 54(3), 2199\u20132211.</p> <p>Wahbi, A., Heng, L., Dercon, G., Wahbi, A., &amp; Avery, W. (2018). In situ destructive sampling. Cosmic Ray Neutron Sensing: Estimation of Agricultural Crop Biomass Water Equivalent, 5\u20139.</p> <p>Baatz, R., Bogena, H., Hendricks Franssen, H.-J., Huisman, J., Montzka, C., &amp; Vereecken, H. (2015). An empirical vegetation correction for soil water content quantification using cosmic ray probes. Water Resources Research, 51(4), 2030\u20132046.</p> <p>Schr\u00f6n, M., Rosolem, R., K\u00f6hli, M., Piussi, L., Schr\u00f6ter, I., Iwema, J., K\u00f6gler, S., Oswald, S. E., Wollschl\u00e4ger, U., Samaniego, L., &amp; others. (2018). Cosmic-ray neutron rover surveys of field soil moisture and the influence of roads. Water Resources Research, 54(9), 6441\u20136459.</p> <p>Zreda, M., Shuttleworth, W. J., Zeng, X., Zweck, C., Desilets, D., Franz, T., and Rosolem, R.: COSMOS: the COsmic-ray Soil Moisture Observing System, Hydrol. Earth Syst. Sci., 16, 4079\u20134099, https://doi.org/10.5194/hess-16-4079-2012, 2012.</p>"},{"location":"reference/","title":"Reference","text":"<p><code>crnpy</code> is a Python package for processing cosmic ray neutron data.</p> <p>Created by Joaquin Peraza and Andres Patrignani.</p>"},{"location":"reference/#crnpy.crnpy.abs_humidity","title":"<code>abs_humidity(relative_humidity, temp)</code>","text":"<p>Compute the actual vapor pressure (e) in g m^-3 using RH (%) and current temperature (c) observations.</p> <p>Parameters:</p> Name Type Description Default <code>relative_humidity</code> <code>float</code> <p>relative humidity (%)</p> required <code>temp</code> <code>float</code> <p>temperature (Celsius)</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>actual vapor pressure (g m^-3)</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def abs_humidity(relative_humidity, temp):\n\"\"\"\n    Compute the actual vapor pressure (e) in g m^-3 using RH (%) and current temperature (c) observations.\n\n    Args:\n        relative_humidity (float): relative humidity (%)\n        temp (float): temperature (Celsius)\n\n    Returns:\n        float: actual vapor pressure (g m^-3)\n    \"\"\"\n\n    ### Atmospheric water vapor factor\n    # Saturation vapor pressure\n    e_sat = 0.611 * np.exp(17.502 * temp / (\n                temp + 240.97)) * 1000  # in Pascals Eq. 3.8 p.41 Environmental Biophysics (Campbell and Norman)\n\n    # Vapor pressure Pascals\n    Pw = e_sat * relative_humidity / 100\n\n    # Absolute humidity (g/m^3)\n    C = 2.16679  # g K/J;\n    abs_h = C * Pw / (temp + 273.15)\n    return abs_h\n</code></pre>"},{"location":"reference/#crnpy.crnpy.biomass_to_bwe","title":"<code>biomass_to_bwe(biomass_dry, biomass_fresh, fWE=0.494)</code>","text":"<p>Function to convert biomass to biomass water equivalent.</p> <p>Parameters:</p> Name Type Description Default <code>biomass_dry</code> <code>array or pd.Series or pd.DataFrame</code> <p>Above ground dry biomass in kg m-2.</p> required <code>biomass_fresh</code> <code>array or pd.Series or pd.DataFrame</code> <p>Above ground fresh biomass in kg m-2.</p> required <code>fWE</code> <code>float</code> <p>Stoichiometric ratio of H2O to organic carbon molecules in the plant (assuming this is mostly cellulose) Default is 0.494 (Wahbi &amp; Avery, 2018).</p> <code>0.494</code> <p>Returns:</p> Type Description <code>array or pd.Series or pd.DataFrame</code> <p>Biomass water equivalent in kg m-2.</p> References <p>Wahbi, A., Avery, W. (2018). In Situ Destructive Sampling. In: Cosmic Ray Neutron Sensing: Estimation of Agricultural Crop Biomass Water Equivalent. Springer, Cham. https://doi.org/10.1007/978-3-319-69539-6_2</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def biomass_to_bwe(biomass_dry, biomass_fresh, fWE=0.494):\n\"\"\"Function to convert biomass to biomass water equivalent.\n\n    Args:\n        biomass_dry (array or pd.Series or pd.DataFrame): Above ground dry biomass in kg m-2.\n        biomass_fresh (array or pd.Series or pd.DataFrame): Above ground fresh biomass in kg m-2.\n        fWE (float): Stoichiometric ratio of H2O to organic carbon molecules in the plant (assuming this is mostly cellulose)\n            Default is 0.494 (Wahbi &amp; Avery, 2018).\n\n    Returns:\n        (array or pd.Series or pd.DataFrame): Biomass water equivalent in kg m-2.\n\n    References:\n        Wahbi, A., Avery, W. (2018). In Situ Destructive Sampling. In:\n        Cosmic Ray Neutron Sensing: Estimation of Agricultural Crop Biomass Water Equivalent.\n        Springer, Cham. https://doi.org/10.1007/978-3-319-69539-6_2\n    \"\"\"\n    return (biomass_fresh - biomass_dry) + fWE * biomass_dry\n</code></pre>"},{"location":"reference/#crnpy.crnpy.correction_bwe","title":"<code>correction_bwe(counts, bwe, r2_N0=0.05)</code>","text":"<p>Function to correct for biomass effects in neutron counts. following the approach described in Baatz et al., 2015.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>array or pd.Series or pd.DataFrame</code> <p>Array of ephithermal neutron counts.</p> required <code>bwe</code> <code>float</code> <p>Biomass water equivalent kg m-2.</p> required <code>r2_N0</code> <code>float</code> <p>Ratio of neutron counts with biomass to neutron counts without biomass. Default is 0.05.</p> <code>0.05</code> <p>Returns:</p> Type Description <code>array or pd.Series or pd.DataFrame</code> <p>Array of corrected neutron counts for biomass effects.</p> References <p>Baatz, R., H. R. Bogena, H.-J. Hendricks Franssen, J. A. Huisman, C. Montzka, and H. Vereecken (2015), An empiricalvegetation correction for soil water content quantification using cosmic ray probes, Water Resour. Res., 51, 2030\u20132046, doi:10.1002/ 2014WR016443.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def correction_bwe(counts, bwe, r2_N0=0.05):\n\"\"\"Function to correct for biomass effects in neutron counts.\n    following the approach described in Baatz et al., 2015.\n\n    Args:\n        counts (array or pd.Series or pd.DataFrame): Array of ephithermal neutron counts.\n        bwe (float): Biomass water equivalent kg m-2.\n        r2_N0 (float): Ratio of neutron counts with biomass to neutron counts without biomass. Default is 0.05.\n\n    Returns:\n        (array or pd.Series or pd.DataFrame): Array of corrected neutron counts for biomass effects.\n\n    References:\n        Baatz, R., H. R. Bogena, H.-J. Hendricks Franssen, J. A. Huisman, C. Montzka, and H. Vereecken (2015),\n        An empiricalvegetation correction for soil water content quantification using cosmic ray probes,\n        Water Resour. Res., 51, 2030\u20132046, doi:10.1002/ 2014WR016443.\n    \"\"\"\n\n    return counts/(1 - bwe*r2_N0)\n</code></pre>"},{"location":"reference/#crnpy.crnpy.correction_humidity","title":"<code>correction_humidity(abs_humidity, Aref)</code>","text":"<p>Correction factor for absolute humidity.</p> <p>This function corrects neutron counts for absolute humidity using the method described in Rosolem et al. (2013) and Anderson et al. (2017). The correction is performed using the following equation:</p> <p>$$ C_{corrected} = C_{raw} \\cdot f_w $$</p> <p>where:</p> <ul> <li>Ccorrected: corrected neutron counts</li> <li>Craw: raw neutron counts</li> <li>fw: absolute humidity correction factor</li> </ul> <p>$$ f_w = 1 + 0.0054(A - A_{ref}) $$</p> <p>where:</p> <ul> <li>A: absolute humidity</li> <li>Aref: reference absolute humidity</li> </ul> <p>Parameters:</p> Name Type Description Default <code>abs_humidity</code> <code>list or array</code> <p>Relative humidity readings.</p> required <code>temp</code> <code>list or array</code> <p>Temperature readings (Celsius).</p> required <code>Aref</code> <code>float</code> <p>Reference absolute humidity (g/m^3). The day of the instrument calibration is recommended.</p> required <p>Returns:</p> Type Description <code>list</code> <p>fw correction factor.</p> References <p>M. Andreasen, K.H. Jensen, D. Desilets, T.E. Franz, M. Zreda, H.R. Bogena, and M.C. Looms. 2017. Status and perspectives on the cosmic-ray neutron method for soil moisture estimation and other environmental science applications. Vadose Zone J. 16(8). doi:10.2136/vzj2017.04.0086</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def correction_humidity(abs_humidity, Aref):\nr\"\"\"Correction factor for absolute humidity.\n\n    This function corrects neutron counts for absolute humidity using the method described in Rosolem et al. (2013) and Anderson et al. (2017). The correction is performed using the following equation:\n\n    $$\n    C_{corrected} = C_{raw} \\cdot f_w\n    $$\n\n    where:\n\n    - Ccorrected: corrected neutron counts\n    - Craw: raw neutron counts\n    - fw: absolute humidity correction factor\n\n    $$\n    f_w = 1 + 0.0054(A - A_{ref})\n    $$\n\n    where:\n\n    - A: absolute humidity\n    - Aref: reference absolute humidity\n\n    Args:\n        abs_humidity (list or array): Relative humidity readings.\n        temp (list or array): Temperature readings (Celsius).\n        Aref (float): Reference absolute humidity (g/m^3). The day of the instrument calibration is recommended.\n\n    Returns:\n        (list): fw correction factor.\n\n    References:\n        M. Andreasen, K.H. Jensen, D. Desilets, T.E. Franz, M. Zreda, H.R. Bogena, and M.C. Looms. 2017. Status and perspectives on the cosmic-ray neutron method for soil moisture estimation and other environmental science applications. Vadose Zone J. 16(8). doi:10.2136/vzj2017.04.0086\n    \"\"\"\n    A = abs_humidity\n    fw = 1 + 0.0054*(A - Aref) # Zreda et al. 2017 Eq 6.\n    return fw\n</code></pre>"},{"location":"reference/#crnpy.crnpy.correction_incoming_flux","title":"<code>correction_incoming_flux(incoming_neutrons, incoming_Ref=None)</code>","text":"<p>Correction factor for incoming neutron flux.</p> <p>This function corrects neutron counts for incoming neutron flux using the method described in Anderson et al. (2017). The correction is performed using the following equation:</p> <p>$$ C_{corrected} = \\frac{C_{raw}}{f_i} $$</p> <p>where:</p> <ul> <li>Ccorrected: corrected neutron counts</li> <li>Craw: raw neutron counts</li> <li>fi: incoming neutron flux correction factor</li> </ul> <p>$$ f_i = \\frac{I_{ref}}{I} $$</p> <p>where:</p> <ul> <li>I: incoming neutron flux</li> <li>Iref: reference incoming neutron flux</li> </ul> <p>Parameters:</p> Name Type Description Default <code>incoming_neutrons</code> <code>list or array</code> <p>Incoming neutron flux readings.</p> required <code>incoming_Ref</code> <code>float</code> <p>Reference incoming neutron flux. Baseline incoming neutron flux.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>fi correction factor.</p> References <p>M. Andreasen, K.H. Jensen, D. Desilets, T.E. Franz, M. Zreda, H.R. Bogena, and M.C. Looms. 2017. Status and perspectives on the cosmic-ray neutron method for soil moisture estimation and other environmental science applications. Vadose Zone J. 16(8). doi:10.2136/vzj2017.04.0086</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def correction_incoming_flux(incoming_neutrons, incoming_Ref=None):\nr\"\"\"Correction factor for incoming neutron flux.\n\n    This function corrects neutron counts for incoming neutron flux using the method described in Anderson et al. (2017). The correction is performed using the following equation:\n\n    $$\n    C_{corrected} = \\frac{C_{raw}}{f_i}\n    $$\n\n    where:\n\n    - Ccorrected: corrected neutron counts\n    - Craw: raw neutron counts\n    - fi: incoming neutron flux correction factor\n\n    $$\n    f_i = \\frac{I_{ref}}{I}\n    $$\n\n    where:\n\n    - I: incoming neutron flux\n    - Iref: reference incoming neutron flux\n\n    Args:\n        incoming_neutrons (list or array): Incoming neutron flux readings.\n        incoming_Ref (float): Reference incoming neutron flux. Baseline incoming neutron flux.\n\n    Returns:\n        (list): fi correction factor.\n\n    References:\n        M. Andreasen, K.H. Jensen, D. Desilets, T.E. Franz, M. Zreda, H.R. Bogena, and M.C. Looms. 2017. Status and perspectives on the cosmic-ray neutron method for soil moisture estimation and other environmental science applications. Vadose Zone J. 16(8). doi:10.2136/vzj2017.04.0086\n\n\n    \"\"\"\n    if incoming_Ref is None and not isinstance(incoming_neutrons, type(None)):\n        incoming_Ref = incoming_neutrons[0]\n        warnings.warn('Reference incoming neutron flux not provided. Using first value of incoming neutron flux.')\n    fi = incoming_neutrons / incoming_Ref\n    fi.fillna(1.0, inplace=True)  # Use a value of 1 for days without data\n\n    return fi\n</code></pre>"},{"location":"reference/#crnpy.crnpy.correction_pressure","title":"<code>correction_pressure(pressure, Pref, L)</code>","text":"<p>Correction factor for atmospheric pressure.</p> <p>This function corrects neutron counts for atmospheric pressure using the method described in Andreasen et al. (2017). The correction is performed using the following equation:</p> <p>$$ C_{corrected} = \\frac{C_{raw}}{fp} $$</p> <p>where:</p> <ul> <li>Ccorrected: corrected neutron counts</li> <li>Craw: raw neutron counts</li> <li>fp: pressure correction factor</li> </ul> <p>$$ fp = e^{\\frac{P_{ref} - P}{L}} $$</p> <p>where:</p> <ul> <li>P: atmospheric pressure</li> <li>Pref: reference atmospheric pressure</li> <li>L: Atmospheric attenuation coefficient.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>atm_pressure</code> <code>list or array</code> <p>Atmospheric pressure readings. Long-term average pressure is recommended.</p> required <code>Pref</code> <code>float</code> <p>Reference atmospheric pressure.</p> required <code>L</code> <code>float</code> <p>Atmospheric attenuation coefficient.</p> required <p>Returns:</p> Type Description <code>list</code> <p>fp pressure correction factor.</p> References <p>M. Andreasen, K.H. Jensen, D. Desilets, T.E. Franz, M. Zreda, H.R. Bogena, and M.C. Looms. 2017. Status and perspectives on the cosmic-ray neutron method for soil moisture estimation and other environmental science applications. Vadose Zone J. 16(8). doi:10.2136/vzj2017.04.0086</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def correction_pressure(pressure, Pref, L):\nr\"\"\"Correction factor for atmospheric pressure.\n\n    This function corrects neutron counts for atmospheric pressure using the method described in Andreasen et al. (2017).\n    The correction is performed using the following equation:\n\n    $$\n    C_{corrected} = \\frac{C_{raw}}{fp}\n    $$\n\n    where:\n\n    - Ccorrected: corrected neutron counts\n    - Craw: raw neutron counts\n    - fp: pressure correction factor\n\n    $$\n    fp = e^{\\frac{P_{ref} - P}{L}}\n    $$\n\n    where:\n\n    - P: atmospheric pressure\n    - Pref: reference atmospheric pressure\n    - L: Atmospheric attenuation coefficient.\n\n\n    Args:\n        atm_pressure (list or array): Atmospheric pressure readings. Long-term average pressure is recommended.\n        Pref (float): Reference atmospheric pressure.\n        L (float): Atmospheric attenuation coefficient.\n\n    Returns:\n        (list): fp pressure correction factor.\n\n    References:\n        M. Andreasen, K.H. Jensen, D. Desilets, T.E. Franz, M. Zreda, H.R. Bogena, and M.C. Looms. 2017. Status and perspectives on the cosmic-ray neutron method for soil moisture estimation and other environmental science applications. Vadose Zone J. 16(8). doi:10.2136/vzj2017.04.0086\n    \"\"\"\n\n    # Compute pressure correction factor\n    fp = np.exp((Pref - pressure) / L) # Zreda et al. 2017 Eq 5.\n\n    return fp\n</code></pre>"},{"location":"reference/#crnpy.crnpy.correction_road","title":"<code>correction_road(counts, theta_N, road_width, road_distance=0.0, theta_road=0.12, p0=0.42, p1=0.5, p2=1.06, p3=4, p4=0.16, p6=0.94, p7=1.1, p8=2.7, p9=0.01)</code>","text":"<p>Function to correct for road effects in neutron counts. following the approach described in Schr\u00f6n et al., 2018.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>array or pd.Series or pd.DataFrame</code> <p>Array of ephithermal neutron counts.</p> required <code>theta_N</code> <code>float</code> <p>Volumetric water content of the soil estimated from the uncorrected neutron counts.</p> required <code>road_width</code> <code>float</code> <p>Width of the road in m.</p> required <code>road_distance</code> <code>float</code> <p>Distance of the road from the sensor in m. Default is 0.0.</p> <code>0.0</code> <code>theta_road</code> <code>float</code> <p>Volumetric water content of the road. Default is 0.12.</p> <code>0.12</code> <code>p0-p9</code> <code>float</code> <p>Parameters of the correction function. Default values are from Schr\u00f6n et al., 2018.</p> required <p>Returns:</p> Type Description <code>array or pd.Series or pd.DataFrame</code> <p>Array of corrected neutron counts for road effects.</p> References <p>Schr\u00f6n,M.,Rosolem,R.,K\u00f6hli,M., Piussi,L.,Schr\u00f6ter,I.,Iwema,J.,etal. (2018).Cosmic-ray neutron rover surveys of field soil moisture and the influence of roads.WaterResources Research,54,6441\u20136459. https://doi. org/10.1029/2017WR021719</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def correction_road(counts, theta_N, road_width, road_distance=0.0, theta_road=0.12, p0=0.42, p1=0.5, p2=1.06, p3=4, p4=0.16, p6=0.94, p7=1.10, p8=2.70, p9=0.01):\n\"\"\"Function to correct for road effects in neutron counts.\n    following the approach described in Schr\u00f6n et al., 2018.\n\n    Args:\n        counts (array or pd.Series or pd.DataFrame): Array of ephithermal neutron counts.\n        theta_N (float): Volumetric water content of the soil estimated from the uncorrected neutron counts.\n        road_width (float): Width of the road in m.\n        road_distance (float): Distance of the road from the sensor in m. Default is 0.0.\n        theta_road (float): Volumetric water content of the road. Default is 0.12.\n        p0-p9 (float): Parameters of the correction function. Default values are from Schr\u00f6n et al., 2018.\n\n    Returns:\n        (array or pd.Series or pd.DataFrame): Array of corrected neutron counts for road effects.\n\n    References:\n        Schr\u00f6n,M.,Rosolem,R.,K\u00f6hli,M., Piussi,L.,Schr\u00f6ter,I.,Iwema,J.,etal. (2018).Cosmic-ray neutron rover surveys\n        of field soil moisture and the influence of roads.WaterResources Research,54,6441\u20136459.\n        https://doi. org/10.1029/2017WR021719\n    \"\"\"\n    F1 = p0 * (1-np.exp(-p1*road_width))\n    F2 = -p2 - p3 * theta_road - ((p4 + theta_road) / (theta_N))\n    F3 = p6 * np.exp(-p7 * (road_width ** -p8) * road_distance ** 4) + (1 - p6) * np.exp(-p9 * road_distance)\n\n    C_roads = 1 + F1 * F2 * F3\n\n    corrected_counts = counts / C_roads\n\n    return corrected_counts\n</code></pre>"},{"location":"reference/#crnpy.crnpy.counts_to_vwc","title":"<code>counts_to_vwc(counts, N0, Wlat, Wsoc, bulk_density, a0=0.0808, a1=0.372, a2=0.115)</code>","text":"<p>Function to convert corrected and filtered neutron counts into volumetric water content.</p> <p>This method implements soil moisture estimation using the non-linear relationship between neutron count and soil volumetric water content following the approach described in Desilets et al., 2010.</p> <p>$\\theta(N) =\\frac{a_0}{(\\frac{N}{N_0}) - a_1} - a_2 $</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>array or pd.Series or pd.DataFrame</code> <p>Array of corrected and filtered neutron counts.</p> required <code>N0</code> <code>float</code> <p>Device-specific neutron calibration constant.</p> required <code>Wlat</code> <code>float</code> <p>Lattice water content.</p> required <code>Wsoc</code> <code>float</code> <p>Soil organic carbon content.</p> required <code>bulk_density</code> <code>float</code> <p>Soil bulk density.</p> required <code>a0</code> <code>float</code> <p>Parameter given in Zreda et al., 2012. Default is 0.0808.</p> <code>0.0808</code> <code>a1</code> <code>float</code> <p>Parameter given in Zreda et al., 2012. Default is 0.372.</p> <code>0.372</code> <code>a2</code> <code>float</code> <p>Parameter given in Zreda et al., 2012. Default is 0.115.</p> <code>0.115</code> <p>Returns:</p> Type Description <code>array or pd.Series or pd.DataFrame</code> <p>Volumetric water content in m3 m-3.</p> References <p>Desilets, D., M. Zreda, and T.P.A. Ferr\u00e9. 2010. Nature\u2019s neutron probe: Land surface hydrology at an elusive scale with cosmic rays. Water Resour. Res. 46:W11505. doi.org/10.1029/2009WR008726</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def counts_to_vwc(counts, N0, Wlat, Wsoc ,bulk_density, a0=0.0808,a1=0.372,a2=0.115):\nr\"\"\"Function to convert corrected and filtered neutron counts into volumetric water content.\n\n    This method implements soil moisture estimation using the non-linear relationship between neutron count and soil volumetric water content following the approach described in Desilets et al., 2010.\n\n    $\\theta(N) =\\frac{a_0}{(\\frac{N}{N_0}) - a_1} - a_2 $\n\n    Args:\n        counts (array or pd.Series or pd.DataFrame): Array of corrected and filtered neutron counts.\n        N0 (float): Device-specific neutron calibration constant.\n        Wlat (float): Lattice water content.\n        Wsoc (float): Soil organic carbon content.\n        bulk_density (float): Soil bulk density.\n        a0 (float): Parameter given in Zreda et al., 2012. Default is 0.0808.\n        a1 (float): Parameter given in Zreda et al., 2012. Default is 0.372.\n        a2 (float): Parameter given in Zreda et al., 2012. Default is 0.115.\n\n    Returns:\n        (array or pd.Series or pd.DataFrame): Volumetric water content in m3 m-3.\n\n    References:\n        Desilets, D., M. Zreda, and T.P.A. Ferr\u00e9. 2010. Nature\u2019s neutron probe:\n        Land surface hydrology at an elusive scale with cosmic rays. Water Resour. Res. 46:W11505.\n        doi.org/10.1029/2009WR008726\n    \"\"\"\n\n    # Convert neutron counts into vwc\n    vwc = (a0 / (counts/N0-a1) - a2 - Wlat - Wsoc) * bulk_density\n    return vwc\n</code></pre>"},{"location":"reference/#crnpy.crnpy.cutoff_rigidity","title":"<code>cutoff_rigidity(lat, lon)</code>","text":"<p>Function to estimate the approximate cutoff rigidity for any point on Earth according to the tabulated data of Smart and Shea, 2019. The returned value can be used to select the appropriate neutron monitor station to estimate the cosmic-ray neutron intensity at the location of interest.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Geographic latitude in decimal degrees. Value in range -90 to 90</p> required <code>lon</code> <code>float</code> <p>Geographic longitude in decimal degrees. Values in range from 0 to 360. Typical negative longitudes in the west hemisphere will fall in the range 180 to 360.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Cutoff rigidity in GV. Error is about +/- 0.3 GV</p> <p>Examples:</p> <p>Estimate the cutoff rigidity for Newark, NJ, US</p> <pre><code>&gt;&gt;&gt; zq = cutoff_rigidity(39.68, -75.75)\n&gt;&gt;&gt; print(zq)\n2.52 GV (Value from NMD is 2.40 GV)\n</code></pre> References <p>Smart, D. &amp; Shea, Matthew. (2001). Geomagnetic Cutoff Rigidity Computer Program: Theory, Software Description and Example. NASA STI/Recon Technical Report N.</p> <p>Shea, M. A., &amp; Smart, D. F. (2019, July). Re-examination of the First Five Ground-Level Events. In International Cosmic Ray Conference (ICRC2019) (Vol. 36, p. 1149).</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def cutoff_rigidity(lat,lon):\n\"\"\"Function to estimate the approximate cutoff rigidity for any point on Earth according to the\n    tabulated data of Smart and Shea, 2019. The returned value can be used to select the appropriate\n    neutron monitor station to estimate the cosmic-ray neutron intensity at the location of interest.\n\n    Args:\n        lat (float): Geographic latitude in decimal degrees. Value in range -90 to 90\n        lon (float): Geographic longitude in decimal degrees. Values in range from 0 to 360.\n            Typical negative longitudes in the west hemisphere will fall in the range 180 to 360.\n\n    Returns:\n        (float): Cutoff rigidity in GV. Error is about +/- 0.3 GV\n\n    Examples:\n        Estimate the cutoff rigidity for Newark, NJ, US\n\n        &gt;&gt;&gt; zq = cutoff_rigidity(39.68, -75.75)\n        &gt;&gt;&gt; print(zq)\n        2.52 GV (Value from NMD is 2.40 GV)\n\n    References:\n        Smart, D. &amp; Shea, Matthew. (2001). Geomagnetic Cutoff Rigidity Computer Program:\n        Theory, Software Description and Example. NASA STI/Recon Technical Report N.\n\n        Shea, M. A., &amp; Smart, D. F. (2019, July). Re-examination of the First Five Ground-Level Events.\n        In International Cosmic Ray Conference (ICRC2019) (Vol. 36, p. 1149).\n    \"\"\"\n    xq = lon\n    yq = lat\n\n    if xq &lt; 0:\n        xq = xq*-1 + 180\n    Z = np.array(data.cutoff_rigidity)\n    x = np.linspace(0, 360, Z.shape[1])\n    y = np.linspace(90, -90, Z.shape[0])\n    X, Y = np.meshgrid(x, y)\n    points = np.array( (X.flatten(), Y.flatten()) ).T\n    values = Z.flatten()\n    zq = griddata(points, values, (xq,yq))\n\n    return np.round(zq,2)\n</code></pre>"},{"location":"reference/#crnpy.crnpy.euclidean_distance","title":"<code>euclidean_distance(px, py, x, y)</code>","text":"<p>Function that computes the Euclidean distance between one point in space and one or more points.</p> <p>Parameters:</p> Name Type Description Default <code>px</code> <code>float</code> <p>x projected coordinate of the point.</p> required <code>py</code> <code>float</code> <p>y projected coordinate of the point.</p> required <code>x</code> <code>list, ndarray, pandas.series</code> <p>vector of x projected coordinates.</p> required <code>y</code> <code>list, ndarray, pandas.series</code> <p>vector of y projected coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Numpy array of distances from the point (px,py) to all the points in x and y vectors.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def euclidean_distance(px, py, x, y):\n\"\"\"Function that computes the Euclidean distance between one point\n    in space and one or more points.\n\n    Args:\n        px (float): x projected coordinate of the point.\n        py (float): y projected coordinate of the point.\n        x (list, ndarray, pandas.series): vector of x projected coordinates.\n        y (list, ndarray, pandas.series): vector of y projected coordinates.\n\n    Returns:\n        (ndarray): Numpy array of distances from the point (px,py) to all the points in x and y vectors.\n    \"\"\"\n    d = np.sqrt((px - x) ** 2 + (py - y) ** 2)\n    return d\n</code></pre>"},{"location":"reference/#crnpy.crnpy.exp_filter","title":"<code>exp_filter(sm, T=1)</code>","text":"<p>Exponential filter to estimate soil moisture in the rootzone from surface observtions.</p> <p>Parameters:</p> Name Type Description Default <code>sm</code> <code>list or array</code> <p>Soil moisture in mm of water for the top layer of the soil profile.</p> required <code>T</code> <code>float</code> <p>Characteristic time length in the same units as the measurement interval.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>sm_subsurface</code> <code>list or array</code> <p>Subsurface soil moisture in the same units as the input.</p> References <p>Albergel, C., R\u00fcdiger, C., Pellarin, T., Calvet, J.C., Fritz, N., Froissard, F., Suquia, D., Petitpa, A., Piguet, B. and Martin, E., 2008. From near-surface to root-zone soil moisture using an exponential filter: an assessment of the method based on in-situ observations and model simulations. Hydrology and Earth System Sciences, 12(6), pp.1323-1337.</p> <p>Franz, T.E., Wahbi, A., Zhang, J., Vreugdenhil, M., Heng, L., Dercon, G., Strauss, P., Brocca, L. and Wagner, W., 2020. Practical data products from cosmic-ray neutron sensing for hydrological applications. Frontiers in Water, 2, p.9.</p> <p>Rossini, P. and Patrignani, A., 2021. Predicting rootzone soil moisture from surface observations in cropland using an exponential filter. Soil Science Society of America Journal.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def exp_filter(sm,T=1):\n\"\"\"Exponential filter to estimate soil moisture in the rootzone from surface observtions.\n\n    Args:\n        sm (list or array): Soil moisture in mm of water for the top layer of the soil profile.\n        T (float): Characteristic time length in the same units as the measurement interval.\n\n    Returns:\n        sm_subsurface (list or array): Subsurface soil moisture in the same units as the input.\n\n    References:\n        Albergel, C., R\u00fcdiger, C., Pellarin, T., Calvet, J.C., Fritz, N., Froissard, F., Suquia, D., Petitpa, A., Piguet, B. and Martin, E., 2008.\n        From near-surface to root-zone soil moisture using an exponential filter: an assessment of the method based on in-situ observations and model\n        simulations. Hydrology and Earth System Sciences, 12(6), pp.1323-1337.\n\n        Franz, T.E., Wahbi, A., Zhang, J., Vreugdenhil, M., Heng, L., Dercon, G., Strauss, P., Brocca, L. and Wagner, W., 2020.\n        Practical data products from cosmic-ray neutron sensing for hydrological applications. Frontiers in Water, 2, p.9.\n\n        Rossini, P. and Patrignani, A., 2021. Predicting rootzone soil moisture from surface observations in cropland using an exponential filter.\n        Soil Science Society of America Journal.\n    \"\"\"\n\n\n    # Parameters\n    t_delta = 1\n    sm_min = np.min(sm)\n    sm_max = np.max(sm)\n    ms = (sm - sm_min) / (sm_max - sm_min)\n\n    # Pre-allocate soil water index array and recursive constant K\n    SWI = np.ones_like(ms)*np.nan\n    K = np.ones_like(ms)*np.nan\n\n    # Initial conditions\n    SWI[0] = ms[0]\n    K[0] = 1\n\n    # Values from 2 to N\n    for n in range(1,len(SWI)):\n        if ~np.isnan(ms[n]) &amp; ~np.isnan(ms[n-1]):\n            K[n] = K[n-1] / (K[n-1] + np.exp(-t_delta/T))\n            SWI[n] = SWI[n-1] + K[n]*(ms[n] - SWI[n-1])\n        else:\n            continue\n\n    # Rootzone storage\n    sm_subsurface = SWI * (sm_max - sm_min) + sm_min\n\n    return sm_subsurface\n</code></pre>"},{"location":"reference/#crnpy.crnpy.fill_missing_timestamps","title":"<code>fill_missing_timestamps(df, timestamp_col='timestamp', freq='H', round_timestamp=True, verbose=False)</code>","text":"<p>Helper function to fill rows with missing timestamps in datetime record. Rows are filled with NaN values.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>Pandas DataFrame.</p> required <code>timestamp_col</code> <code>str</code> <p>Column with the timestamp. Must be in datetime format. Default column name is 'timestamp'.</p> <code>'timestamp'</code> <code>freq</code> <code>str</code> <p>Timestamp frequency. 'H' for hourly, 'M' for minute, or None. Can also use '3H' for a 3 hour frequency. Default is 'H'.</p> <code>'H'</code> <code>round_timestamp</code> <code>bool</code> <p>Whether to round timestamps to the nearest frequency. Default is True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Prints the missing timestamps added to the DatFrame.</p> <code>False</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>DataFrame with filled missing timestamps.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def fill_missing_timestamps(df, timestamp_col='timestamp', freq='H', round_timestamp=True, verbose=False):\n\"\"\"Helper function to fill rows with missing timestamps in datetime record. Rows are filled with NaN values.\n\n     Args:\n         df (pandas.DataFrame): Pandas DataFrame.\n         timestamp_col (str, optional): Column with the timestamp. Must be in datetime format. Default column name is 'timestamp'.\n         freq (str, optional): Timestamp frequency. 'H' for hourly, 'M' for minute, or None. Can also use '3H' for a 3 hour frequency. Default is 'H'.\n         round_timestamp (bool, optional): Whether to round timestamps to the nearest frequency. Default is True.\n         verbose (bool, optional): Prints the missing timestamps added to the DatFrame.\n\n     Returns:\n         (pandas.DataFrame): DataFrame with filled missing timestamps.\n\n     \"\"\"\n\n    # Check format of timestamp column\n    if df[timestamp_col].dtype != 'datetime64[ns]':\n        raise TypeError('timestamp_col must be datetime64. Use `pd.to_datetime()` to fix this issue.')\n\n    # Round timestamps to nearest frequency. This steps must preced the filling of rows.\n    if round_timestamp:\n        df[timestamp_col] = df[timestamp_col].dt.round(freq)\n\n    # Fill in rows with missing timestamps\n    start_date = df[timestamp_col].iloc[0]\n    end_date = df[timestamp_col].iloc[-1]\n    date_range = pd.date_range(start_date, end_date, freq=freq)\n    counter = 0\n    for date in date_range:\n        if date not in df[timestamp_col].values:\n            if verbose:\n                print('Adding missing date:',date)\n            new_line = pd.DataFrame({timestamp_col:date}, index=[-1]) # By default fills columns with np.nan\n            df = pd.concat([df,new_line])\n            counter += 1\n\n    df.sort_values(by=timestamp_col, inplace=True)\n    df.reset_index(drop=True, inplace=True)\n\n    # Notify user about the number of rows that have been removed\n    print(f\"Added a total of {counter} missing timestamps.\")\n\n    return df\n</code></pre>"},{"location":"reference/#crnpy.crnpy.find_neutron_monitor","title":"<code>find_neutron_monitor(Rc, start_date=None, end_date=None, verbose=False)</code>","text":"<p>Search for potential reference neutron monitoring stations based on cutoff rigidity.</p> <p>Parameters:</p> Name Type Description Default <code>Rc</code> <code>float</code> <p>Cutoff rigidity in GV. Values in range 1.0 to 3.0 GV.</p> required <code>start_date</code> <code>datetime</code> <p>Start date for the period of interest.</p> <code>None</code> <code>end_date</code> <code>datetime</code> <p>End date for the period of interest.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>List of top five stations with closes cutoff rigidity. User needs to select station according to site altitude.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from crnpy import crnpy\n&gt;&gt;&gt; Rc = 2.40 # 2.40 Newark, NJ, US\n&gt;&gt;&gt; crnpy.find_neutron_monitor(Rc)\nSelect a station with an altitude similar to that of your location. For more information go to: 'https://www.nmdb.eu/nest/help.php#helpstations\n</code></pre> <p>Your cutoff rigidity is 2.4 GV         STID                          NAME     R  Altitude_m 40   NEWK                        Newark  2.40          50 33   MOSC                        Moscow  2.43         200 27   KIEL                          Kiel  2.36          54 28  KIEL2                        KielRT  2.36          54 31   MCRL  Mobile Cosmic Ray Laboratory  2.46         200 32   MGDN                       Magadan  2.10         220 42   NVBK                   Novosibirsk  2.91         163 26   KGSN                      Kingston  1.88          65 9    CLMX                        Climax  3.00        3400 57   YKTK                       Yakutsk  1.65         105</p> References <p>https://www.nmdb.eu/nest/help.php#helpstations</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def find_neutron_monitor(Rc, start_date=None, end_date=None, verbose=False):\n\"\"\"Search for potential reference neutron monitoring stations based on cutoff rigidity.\n\n    Args:\n        Rc (float): Cutoff rigidity in GV. Values in range 1.0 to 3.0 GV.\n        start_date (datetime): Start date for the period of interest.\n        end_date (datetime): End date for the period of interest.\n\n    Returns:\n        (list): List of top five stations with closes cutoff rigidity.\n            User needs to select station according to site altitude.\n\n    Examples:\n        &gt;&gt;&gt; from crnpy import crnpy\n        &gt;&gt;&gt; Rc = 2.40 # 2.40 Newark, NJ, US\n        &gt;&gt;&gt; crnpy.find_neutron_monitor(Rc)\n        Select a station with an altitude similar to that of your location. For more information go to: 'https://www.nmdb.eu/nest/help.php#helpstations\n\n        Your cutoff rigidity is 2.4 GV\n                STID                          NAME     R  Altitude_m\n        40   NEWK                        Newark  2.40          50\n        33   MOSC                        Moscow  2.43         200\n        27   KIEL                          Kiel  2.36          54\n        28  KIEL2                        KielRT  2.36          54\n        31   MCRL  Mobile Cosmic Ray Laboratory  2.46         200\n        32   MGDN                       Magadan  2.10         220\n        42   NVBK                   Novosibirsk  2.91         163\n        26   KGSN                      Kingston  1.88          65\n        9    CLMX                        Climax  3.00        3400\n        57   YKTK                       Yakutsk  1.65         105\n\n    References:\n        https://www.nmdb.eu/nest/help.php#helpstations\n    \"\"\"\n\n    # Load file with list of neutron monitoring stations\n    stations = pd.DataFrame(data.neutron_detectors, columns=[\"STID\",\"NAME\",\"R\",\"Altitude_m\"])\n\n    # Sort stations by closest cutoff rigidity\n    idx_R = (stations['R'] - Rc).abs().argsort()\n\n    if start_date is not None and end_date is not None:\n        stations[\"Period available\"] = False\n        for i in range(10):\n            station = stations.iloc[idx_R[i]][\"STID\"]\n            try:\n                if get_incoming_neutron_flux(start_date, end_date, station, verbose=verbose) is not None:\n                    stations.iloc[idx_R[i],-1] = True\n            except:\n                pass\n        if sum(stations[\"Period available\"] == True) == 0:\n            print(\"No stations available for the selected period!\")\n        else:\n            stations = stations[stations[\"Period available\"] == True]\n            idx_R = (stations['R'] - Rc).abs().argsort()\n            result = stations.iloc[idx_R.iloc[:10]]\n    else:\n        result = stations.reindex(idx_R).head(10).rename_axis(None)\n\n    # Print results\n    print('')\n    print(\"\"\"Select a station with an altitude similar to that of your location. For more information go to: 'https://www.nmdb.eu/nest/help.php#helpstations\"\"\")\n    print('')\n    print(f\"Your cutoff rigidity is {Rc} GV\")\n    print(result)\n    return result\n</code></pre>"},{"location":"reference/#crnpy.crnpy.get_incoming_neutron_flux","title":"<code>get_incoming_neutron_flux(start_date, end_date, station, utc_offset=0, expand_window=0, verbose=False)</code>","text":"<p>Function to retrieve neutron flux from the Neutron Monitor Database.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>datetime</code> <p>Start date of the time series.</p> required <code>end_date</code> <code>datetime</code> <p>End date of the time series.</p> required <code>station</code> <code>str</code> <p>Neutron Monitor station to retrieve data from.</p> required <code>utc_offset</code> <code>int</code> <p>UTC offset in hours. Default is 0.</p> <code>0</code> <code>expand_window</code> <code>int</code> <p>Number of hours to expand the time window to retrieve extra data. Default is 0.</p> <code>0</code> <code>verbose</code> <code>bool</code> <p>Print information about the request. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>Neutron flux in counts per hour and timestamps.</p> References <p>Documentation available:https://www.nmdb.eu/nest/help.php#howto</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def get_incoming_neutron_flux(start_date, end_date, station, utc_offset=0, expand_window=0, verbose=False):\n\"\"\"Function to retrieve neutron flux from the Neutron Monitor Database.\n\n    Args:\n        start_date (datetime): Start date of the time series.\n        end_date (datetime): End date of the time series.\n        station (str): Neutron Monitor station to retrieve data from.\n        utc_offset (int): UTC offset in hours. Default is 0.\n        expand_window (int): Number of hours to expand the time window to retrieve extra data. Default is 0.\n        verbose (bool): Print information about the request. Default is False.\n\n    Returns:\n        (pandas.DataFrame): Neutron flux in counts per hour and timestamps.\n\n    References:\n        Documentation available:https://www.nmdb.eu/nest/help.php#howto\n    \"\"\"\n\n    # Example: get_incoming_flux(station='IRKT',start_date='2020-04-10 11:00:00',end_date='2020-06-18 17:00:00')\n    # Template url = 'http://nest.nmdb.eu/draw_graph.php?formchk=1&amp;stations[]=KERG&amp;output=ascii&amp;tabchoice=revori&amp;dtype=corr_for_efficiency&amp;date_choice=bydate&amp;start_year=2009&amp;start_month=09&amp;start_day=01&amp;start_hour=00&amp;start_min=00&amp;end_year=2009&amp;end_month=09&amp;end_day=05&amp;end_hour=23&amp;end_min=59&amp;yunits=0'\n\n\n    # Expand the time window by 1 hour to ensure an extra observation is included in the request.\n    start_date -= pd.Timedelta(hours=expand_window)\n    end_date += pd.Timedelta(hours=expand_window)\n\n    # Convert local time to UTC\n    start_date = start_date - pd.Timedelta(hours=utc_offset)\n    end_date = end_date - pd.Timedelta(hours=utc_offset)\n    date_format = '%Y-%m-%d %H:%M:%S'\n    root = 'http://www.nmdb.eu/nest/draw_graph.php?'\n    url_par = [ 'formchk=1',\n                'stations[]=' + station,\n                'output=ascii',\n                'tabchoice=revori',\n                'dtype=corr_for_efficiency',\n                'tresolution=' + str(60),\n                'date_choice=bydate',\n                'start_year=' + str(start_date.year),\n                'start_month=' + str(start_date.month),\n                'start_day=' + str(start_date.day),\n                'start_hour=' + str(start_date.hour),\n                'start_min=' + str(start_date.minute),\n                'end_year=' + str(end_date.year),\n                'end_month=' + str(end_date.month),\n                'end_day=' + str(end_date.day),\n                'end_hour=' + str(end_date.hour),\n                'end_min=' + str(end_date.minute),\n                'yunits=0']\n\n    url = root + '&amp;'.join(url_par)\n\n    if verbose:\n        print(f\"Retrieving data from {url}\")\n\n    r = requests.get(url).content.decode('utf-8')\n\n    # Subtract 1 hour to restore the last date included in the request.\n    end_date -= pd.Timedelta('1H')\n    start = r.find(\"RCORR_E\\n\") + 8\n    end = r.find('\\n&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;Total') - 1\n    s = r[start:end]\n    s2 = ''.join([row.replace(';',',') for row in s])\n    try:\n        df_flux = pd.read_csv(io.StringIO(s2), names=['timestamp','counts'])\n    except:\n        if verbose:\n            print(f\"Error retrieving data from {url}\")\n        return None\n\n    # Check if all values from selected detector are NaN. If yes, warn the user\n    if df_flux['counts'].isna().all():\n        warnings.warn('Data for selected neutron detectors appears to be unavailable for the selected period')\n\n    # Convert timestamp to datetime and apply UTC offset\n    df_flux['timestamp'] = pd.to_datetime(df_flux['timestamp'])\n    df_flux['timestamp'] = df_flux['timestamp'] + pd.Timedelta(hours=utc_offset)\n\n    # Print acknowledgement to inform users about restrictions and to acknowledge the NMDB database\n    acknowledgement = \"\"\"Data retrieved via NMDB are the property of the individual data providers. These data are free for non commercial\nuse to within the restriction imposed by the providers. If you use such data for your research or applications, please acknowledge\nthe origin by a sentence like 'We acknowledge the NMDB database (www.nmdb.eu) founded under the European Union's FP7 programme \n(contract no. 213007), and the PIs of individual neutron monitors at: IGY Jungfraujoch \n(Physikalisches Institut, University of Bern, Switzerland)\"\"\"\n\n    return df_flux\n</code></pre>"},{"location":"reference/#crnpy.crnpy.idw","title":"<code>idw(x, y, z, X_pred, Y_pred, neighborhood=1000, p=1)</code>","text":"<p>Function to interpolate data using inverse distance weight.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list or array</code> <p>UTM x coordinates in meters.</p> required <code>y</code> <code>list or array</code> <p>UTM y coordinates in meters.</p> required <code>z</code> <code>list or array</code> <p>Values to be interpolated.</p> required <code>X_pred</code> <code>list or array</code> <p>UTM x coordinates where z values need to be predicted.</p> required <code>Y_pred</code> <code>list or array</code> <p>UTM y coordinates where z values need to be predicted.</p> required <code>neighborhood</code> <code>float</code> <p>Only points within this radius in meters are considered for the interpolation.</p> <code>1000</code> <code>p</code> <code>int</code> <p>Exponent of the inverse distance weight formula. Typically, p=1 or p=2.</p> <code>1</code> <p>Returns:</p> Type Description <code>array</code> <p>Interpolated values.</p> References <p>https://en.wikipedia.org/wiki/Inverse_distance_weighting</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def idw(x, y, z, X_pred, Y_pred, neighborhood=1000, p=1):\n\"\"\"Function to interpolate data using inverse distance weight.\n\n    Args:\n        x (list or array): UTM x coordinates in meters.\n        y (list or array): UTM y coordinates in meters.\n        z (list or array): Values to be interpolated.\n        X_pred (list or array): UTM x coordinates where z values need to be predicted.\n        Y_pred (list or array): UTM y coordinates where z values need to be predicted.\n        neighborhood (float): Only points within this radius in meters are considered for the interpolation.\n        p (int): Exponent of the inverse distance weight formula. Typically, p=1 or p=2.\n\n    Returns:\n        (array): Interpolated values.\n\n    References:\n        [https://en.wikipedia.org/wiki/Inverse_distance_weighting](https://en.wikipedia.org/wiki/Inverse_distance_weighting)\n\n\n    \"\"\"\n\n    # Flatten arrays to handle 1D and 2D arrays with the same code\n    s = X_pred.shape  # Save shape\n    X_pred = X_pred.flatten()\n    Y_pred = Y_pred.flatten()\n\n    # Pre-allocate output array\n    Z_pred = np.full_like(X_pred, np.nan)\n\n    for n in range(X_pred.size):\n        # Distance between current and observed points\n        d = euclidean_distance(X_pred[n], Y_pred[n], x, y)\n\n        # Select points within neighborhood only for interpolation\n        idx_neighbors = d &lt; neighborhood\n\n        # Compute interpolated value at point of interest\n        Z_pred[n] = np.sum(z[idx_neighbors] / d[idx_neighbors] ** p) / np.sum(1 / d[idx_neighbors] ** p)\n\n    return np.reshape(Z_pred, s)\n</code></pre>"},{"location":"reference/#crnpy.crnpy.interpolate_2d","title":"<code>interpolate_2d(x, y, z, dx=100, dy=100, method='cubic', neighborhood=1000)</code>","text":"<p>Function for interpolating irregular spatial data into a regular grid.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list or array</code> <p>UTM x coordinates in meters.</p> required <code>y</code> <code>list or array</code> <p>UTM y coordinates in meters.</p> required <code>z</code> <code>list or array</code> <p>Values to be interpolated.</p> required <code>dx</code> <code>float</code> <p>Pixel width in meters.</p> <code>100</code> <code>dy</code> <code>float</code> <p>Pixel height in meters.</p> <code>100</code> <code>method</code> <code>str</code> <p>Interpolation method. One of 'cubic', 'linear', 'nearest', or 'idw'.</p> <code>'cubic'</code> <code>neighborhood</code> <code>float</code> <p>Only points within this radius in meters are considered for the interpolation.</p> <code>1000</code> <p>Returns:</p> Name Type Description <code>x_pred</code> <code>array</code> <p>2D array with x coordinates.</p> <code>y_pred</code> <code>array</code> <p>2D array with y coordinates.</p> <code>z_pred</code> <code>array</code> <p>2D array with interpolated values.</p> References <p>https://soilwater.github.io/pynotes-agriscience/notebooks/interpolation.html</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def interpolate_2d(x, y, z, dx=100, dy=100, method='cubic', neighborhood=1000):\n\"\"\"Function for interpolating irregular spatial data into a regular grid.\n\n    Args:\n        x (list or array): UTM x coordinates in meters.\n        y (list or array): UTM y coordinates in meters.\n        z (list or array): Values to be interpolated.\n        dx (float): Pixel width in meters.\n        dy (float): Pixel height in meters.\n        method (str): Interpolation method. One of 'cubic', 'linear', 'nearest', or 'idw'.\n        neighborhood (float): Only points within this radius in meters are considered for the interpolation.\n\n    Returns:\n        x_pred (array): 2D array with x coordinates.\n        y_pred (array): 2D array with y coordinates.\n        z_pred (array): 2D array with interpolated values.\n\n    References:\n        [https://soilwater.github.io/pynotes-agriscience/notebooks/interpolation.html](https://soilwater.github.io/pynotes-agriscience/notebooks/interpolation.html)\n    \"\"\"\n\n    # Drop NaN values in x y and z\n    idx_nan = np.isnan(x) | np.isnan(y) | np.isnan(z)\n    x = x[~idx_nan]\n    y = y[~idx_nan]\n    z = z[~idx_nan]\n\n    if idx_nan.any():\n        print(f\"WARNING: {np.isnan(x).sum()}, {np.isnan(y).sum()}, and {np.isnan(z).sum()} NaN values were dropped from x, y, and z.\")\n\n    # Create 2D grid for interpolation\n    Nx = round((np.max(x) - np.min(x)) / dx) + 1\n    Ny = round((np.max(y) - np.min(y)) / dy) + 1\n    X_vec = np.linspace(np.min(x), np.max(x), Nx)\n    Y_vec = np.linspace(np.min(y), np.max(y), Ny)\n    X_pred, Y_pred = np.meshgrid(X_vec, Y_vec)\n\n    if method in ['linear', 'nearest', 'cubic']:\n        points = list(zip(x, y))\n        Z_pred = griddata(points, z, (X_pred, Y_pred), method=method)\n\n    elif method == 'idw':\n        Z_pred = idw(x, y, z, X_pred, Y_pred, neighborhood)\n\n    else:\n        raise f\"Method {method} does not exist. Provide either 'cubic', 'linear', 'nearest', or 'idw'.\"\n\n    return X_pred, Y_pred, Z_pred\n</code></pre>"},{"location":"reference/#crnpy.crnpy.interpolate_incoming_flux","title":"<code>interpolate_incoming_flux(nmdb_timestamps, nmdb_counts, crnp_timestamps)</code>","text":"<p>Function to interpolate incoming neutron flux to match the timestamps of the observations.</p> <p>Parameters:</p> Name Type Description Default <code>nmdb_timestamps</code> <code>pd.Series</code> <p>Series of timestamps in datetime format from the NMDB.</p> required <code>nmdb_counts</code> <code>pd.Series</code> <p>Series of neutron counts from the NMDB</p> required <code>crnp_timestamps</code> <code>pd.Series</code> <p>Series of timestamps in datetime format from the station or device.</p> required <p>Returns:</p> Type Description <code>pd.Series</code> <p>Series containing interpolated incoming neutron flux. Length of Series is the same as crnp_timestamps</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def interpolate_incoming_flux(nmdb_timestamps, nmdb_counts, crnp_timestamps):\n\"\"\"Function to interpolate incoming neutron flux to match the timestamps of the observations.\n\n    Args:\n        nmdb_timestamps (pd.Series): Series of timestamps in datetime format from the NMDB.\n        nmdb_counts (pd.Series): Series of neutron counts from the NMDB\n        crnp_timestamps (pd.Series): Series of timestamps in datetime format from the station or device.\n\n    Returns:\n        (pd.Series): Series containing interpolated incoming neutron flux. Length of Series is the same as crnp_timestamps\n    \"\"\"\n    incoming_flux = np.array([])\n    for k,timestamp in enumerate(crnp_timestamps):\n        if timestamp in nmdb_timestamps.values:\n            idx = timestamp == nmdb_timestamps\n            incoming_flux = np.append(incoming_flux, nmdb_counts.loc[idx])\n        else:\n            incoming_flux = np.append(incoming_flux, np.nan)\n\n    # Interpolate nan values\n    incoming_flux = pd.Series(incoming_flux).interpolate(method='nearest', limit_direction='both')\n\n    # Return only the values for the selected timestamps\n    return incoming_flux\n</code></pre>"},{"location":"reference/#crnpy.crnpy.is_outlier","title":"<code>is_outlier(x, method, window=11, min_val=None, max_val=None)</code>","text":"<p>Function that tests whether values are outliers using a modified moving z-score based on the median absolute difference.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>pandas.DataFrame</code> <p>Variable containing only the columns with neutron counts.</p> required <code>method</code> <code>str</code> <p>Outlier detection method. One of: range, iqr, moviqr, zscore, movzscore, modified_zscore, and scaled_mad</p> required <code>window</code> <code>int</code> <p>Window size for the moving central tendency. Default is 11.</p> <code>11</code> <code>min_val</code> <code>int or float</code> <p>Minimum value for a reading to be considered valid. Default is None.</p> <code>None</code> <code>max_val(int</code> <code>or float</code> <p>Maximum value for a reading to be considered valid. Default is None.</p> required <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>Boolean indicating outliers.</p> References <p>Iglewicz, B. and Hoaglin, D.C., 1993. How to detect and handle outliers (Vol. 16). Asq Press.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def is_outlier(x, method, window=11, min_val=None, max_val=None):\n\"\"\"Function that tests whether values are outliers using a modified moving z-score based on the median absolute difference.\n\n    Args:\n        x (pandas.DataFrame): Variable containing only the columns with neutron counts.\n        method (str): Outlier detection method. One of: range, iqr, moviqr, zscore, movzscore, modified_zscore, and scaled_mad\n        window (int, optional): Window size for the moving central tendency. Default is 11.\n        min_val (int or float): Minimum value for a reading to be considered valid. Default is None.\n        max_val(int or float): Maximum value for a reading to be considered valid. Default is None.\n\n    Returns:\n        (pandas.DataFrame): Boolean indicating outliers.\n\n    References:\n        Iglewicz, B. and Hoaglin, D.C., 1993. How to detect and handle outliers (Vol. 16). Asq Press.\n    \"\"\"\n\n    if not isinstance(x, pd.Series):\n        raise TypeError('x must of type pandas.Series')\n\n    # Separate this method to allow usage together with other methods below\n    if isinstance(min_val, numbers.Number) and isinstance(max_val, numbers.Number):\n        idx_range_outliers = (x &lt; min_val) | (x &gt; max_val)\n    else:\n        idx_range_outliers = np.full_like(x, False)\n\n    # Apply other methods in addition to a range check\n    if method == 'iqr':\n        q1 = x.quantile(0.25)\n        q3 = x.quantile(0.75)\n        iqr = q3 - q1\n        high_fence = q3 + (1.5 * iqr)\n        low_fence = q1 - (1.5 * iqr)\n        idx_outliers = (x&lt;low_fence ) | (x&gt;high_fence )\n\n    elif method == 'moviqr':\n        q1 = x.rolling(window, center=True).quantile(0.25)\n        q3 = x.rolling(window, center=True).quantile(0.75)\n        iqr = q3 - q1\n        ub = q3 + (1.5 * iqr) # Upper boundary\n        lb = q1 - (1.5 * iqr) # Lower boundary\n        idx_outliers = (x &lt; lb) | (x &gt; ub)\n\n    elif method == 'zscore':\n        zscore = (x - x.mean())/x.std()\n        idx_outliers = (zscore &lt; -3) | (zscore &gt; 3)\n\n    elif method == 'movzscore':\n        movmean = x.rolling(window=window, center=True).mean()\n        movstd = x.rolling(window=window, center=True).std()\n        movzscore = (x - movmean)/movstd\n        idx_outliers = (movzscore &lt; -3) | (movzscore &gt; 3)\n\n    elif method == 'modified_zscore':\n        # Compute median absolute difference\n        movmedian = x.rolling(window, center=True).median()\n        abs_diff = np.abs(x - movmedian)\n        mad = abs_diff.rolling(window, center=True).median()\n\n        # Compute modified z-score\n        modified_z_score = 0.6745 * abs_diff / mad\n        idx_outliers = (modified_z_score &lt; -3.5) | (modified_z_score &gt; 3.5)\n\n    elif method == 'scaled_mad':\n        # Returns true for elements more than three scaled MAD from the median. \n        c = -1 / (np.sqrt(2)*erfcinv(3/2))\n        median = np.nanmedian(x)\n        mad = c*np.nanmedian(np.abs(x - median))\n        idx_outliers = x &gt; (median + 3*mad)\n\n    else:\n        raise TypeError('Outlier detection method not found.')\n\n    return idx_outliers | idx_range_outliers\n</code></pre>"},{"location":"reference/#crnpy.crnpy.latlon_to_utm","title":"<code>latlon_to_utm(lat, lon, utm_zone_number, missing_values=None)</code>","text":"<p>Convert geographic coordinates (lat, lon) to projected coordinates (utm) using the Military Grid Reference System.</p> <p>Function only applies to non-polar coordinates. If further functionality is required, consider using the utm module. See references for more information.</p> <p> UTM zones on an equirectangular world map with irregular zones in red and New York City's zone highlighted. See UTM zones for a full description.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float, array</code> <p>Latitude in decimal degrees.</p> required <code>lon</code> <code>float, array</code> <p>Longitude in decimal degrees.</p> required <code>utm_zone_number</code> <code>int</code> <p>Universal Transverse Mercator (UTM) zone.</p> required <p>Returns:</p> Type Description <code>float, float</code> <p>Tuple of easting and northing coordinates in meters. First element is easting, second is northing.</p> References <p>Code adapted from utm module created by Tobias Bieniek (Github username: Turbo87) https://github.com/Turbo87/utm</p> <p>https://www.maptools.com/tutorials/grid_zone_details#</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def latlon_to_utm(lat, lon, utm_zone_number, missing_values=None):\n\"\"\"Convert geographic coordinates (lat, lon) to projected coordinates (utm) using the Military Grid Reference System.\n\n    Function only applies to non-polar coordinates.\n    If further functionality is required, consider using the utm module. See references for more information.\n\n    ![UTM zones](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/Universal_Transverse_Mercator_zones.svg/1920px-Universal_Transverse_Mercator_zones.svg.png)\n    UTM zones on an equirectangular world map with irregular zones in red and New York City's zone highlighted. See [UTM zones](https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system#UTM_zones) for a full description.\n\n\n    Args:\n        lat (float, array): Latitude in decimal degrees.\n        lon (float, array): Longitude in decimal degrees.\n        utm_zone_number (int): Universal Transverse Mercator (UTM) zone.\n\n    Returns:\n        (float, float): Tuple of easting and northing coordinates in meters. First element is easting, second is northing.\n\n    References:\n         Code adapted from utm module created by Tobias Bieniek (Github username: Turbo87)\n         [https://github.com/Turbo87/utm](https://github.com/Turbo87/utm)\n\n         [https://www.maptools.com/tutorials/grid_zone_details#](https://www.maptools.com/tutorials/grid_zone_details#)\n    \"\"\"\n\n\n    # Define constants\n    R = 6_378_137  # Earth's radius at the Equator in meters\n\n    # Convert input data to Numpy arrays\n    if (type(lat) is not np.ndarray) or (type(lon) is not np.ndarray):\n        try:\n            lat = np.array(lat)\n            lon = np.array(lon)\n        except:\n            raise \"Input values cannot be converted to Numpy arrays.\"\n\n    # Check latitude range\n    if np.any(lat &lt; -80) | np.any(lat &gt; 84):\n        raise \"One or more latitude values exceed the range -80 to 84\"\n\n    # Check longitude range\n    if np.any(lon &lt; -180) | np.any(lon &gt; 180):\n        raise \"One or more longitude values exceed the range -180 to 180\"\n\n    # Constants\n    K0 = 0.9996\n    E = 0.00669438\n    E_P2 = E / (1 - E)\n\n    M1 = (1 - E / 4 - 3 * E ** 2 / 64 - 5 * E ** 3 / 256)\n    M2 = (3 * E / 8 + 3 * E ** 2 / 32 + 45 * E ** 3 / 1024)\n    M3 = (15 * E ** 2 / 256 + 45 * E ** 3 / 1024)\n    M4 = (35 * E ** 3 / 3072)\n\n    # Trigonometric operations\n    lat_rad = np.radians(lat)\n    lon_rad = np.radians(lon)\n\n    lat_sin = np.sin(lat_rad)\n    lat_cos = np.cos(lat_rad)\n    lat_tan = lat_sin / lat_cos\n    lat_tan2 = lat_tan * lat_tan\n    lat_tan4 = lat_tan2 * lat_tan2\n\n    # Find central meridian.\n    central_lon = (utm_zone_number * 6 - 180) - 3  # Zones are every 6 degrees.\n    central_lon_rad = np.radians(central_lon)\n\n    n = R / np.sqrt(1 - E * lat_sin ** 2)\n    c = E_P2 * lat_cos ** 2\n\n    with np.errstate(divide='ignore', invalid='ignore'):\n        a = lat_cos * (np.remainder(((lon_rad - central_lon_rad) + np.pi), (2 * np.pi)) - np.pi)\n    m = R * (M1 * lat_rad - M2 * np.sin(2 * lat_rad) + M3 * np.sin(4 * lat_rad) - M4 * np.sin(6 * lat_rad))\n\n    easting = K0 * n * (a + a ** 3 / 6 * (1 - lat_tan2 + c) + a ** 5 / 120 * (\n                5 - 18 * lat_tan2 + lat_tan4 + 72 * c - 58 * E_P2)) + 500_000\n    northing = K0 * (m + n * lat_tan * (\n                a ** 2 / 2 + a ** 4 / 24 * (5 - lat_tan2 + 9 * c + 4 * c ** 2) + a ** 6 / 720 * (\n                    61 - 58 * lat_tan2 + lat_tan4 + 600 * c - 330 * E_P2)))\n\n    if np.any(lat &lt; 0):\n        northing += 10_000_000\n\n    return easting, northing\n</code></pre>"},{"location":"reference/#crnpy.crnpy.lattice_water","title":"<code>lattice_water(clay_content, total_carbon=None)</code>","text":"<p>Estimate the amount of water in the lattice of clay minerals.</p> $\\omega_{lat} = 0.097 * clay(\\%)$ $\\omega_{lat} = -0.028 + 0.077 * clay(\\%) + 0.459 * carbon(\\%)$ Linear regression [lattice water (%) as a function of clay (%)] done with data from Kansas Sate University - Soil Water Processes Lab. Multiple linear regression [lattice water (%) as a function of clay (%) and soil carbon (%)] done with data from Soil Water Processes Lab. <p>Parameters:</p> Name Type Description Default <code>clay_content</code> <code>float</code> <p>Clay content in the soil in percent.</p> required <code>total_carbon</code> <code>float</code> <p>Total carbon content in the soil in percent. If None, the amount of water is estimated based on clay content only.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Amount of water in the lattice of clay minerals in percent</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def lattice_water(clay_content, total_carbon=None):\nr\"\"\"Estimate the amount of water in the lattice of clay minerals.\n\n    ![img1](img/lattice_water_simple.png) | ![img2](img/lattice_water_multiple.png)\n    :-------------------------:|:-------------------------:\n    $\\omega_{lat} = 0.097 * clay(\\%)$ | $\\omega_{lat} = -0.028 + 0.077 * clay(\\%) + 0.459 * carbon(\\%)$\n    Linear regression [lattice water (%) as a function of clay (%)] done with data from Kansas Sate University - Soil Water Processes Lab. |  Multiple linear regression [lattice water (%) as a function of clay (%) and soil carbon (%)] done with data from Soil Water Processes Lab.\n\n    Args:\n        clay_content (float): Clay content in the soil in percent.\n        total_carbon (float, optional): Total carbon content in the soil in percent.\n            If None, the amount of water is estimated based on clay content only.\n\n    Returns:\n        (float): Amount of water in the lattice of clay minerals in percent\n    \"\"\"\n    if total_carbon is None:\n        lattice_water = 0.097 * clay_content\n    else:\n        lattice_water = -0.028 + 0.077 * clay_content + 0.459 * total_carbon\n    return lattice_water\n</code></pre>"},{"location":"reference/#crnpy.crnpy.nrad_weight","title":"<code>nrad_weight(h, theta, distances, depth, rhob=1.4)</code>","text":"<p>Function to compute distance weights corresponding to each soil sample.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Air Humidity  from 0.1  to 50 in g/m^3. When h=0, the function will skip the distance weighting.</p> required <code>theta</code> <code>array or pd.Series or pd.DataFrame</code> <p>Soil Moisture for each sample (0.02 - 0.50 m^3/m^3)</p> required <code>distances</code> <code>array or pd.Series or pd.DataFrame</code> <p>Distances from the location of each sample to the origin (0.5 - 600 m)</p> required <code>depth</code> <code>array or pd.Series or pd.DataFrame</code> <p>Depths for each sample (m)</p> required <code>rhob</code> <code>float</code> <p>Bulk density in g/cm^3</p> <code>1.4</code> <p>Returns:</p> Type Description <code>array or pd.Series or pd.DataFrame</code> <p>Distance weights for each sample.</p> References <p>K\u00f6hli, M., Schr\u00f6n, M., Zreda, M., Schmidt, U., Dietrich, P., and Zacharias, S. (2015). Footprint characteristics revised for field-scale soil moisture monitoring with cosmic-ray neutrons. Water Resour. Res. 51, 5772\u20135790. doi:10.1002/2015WR017169</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def nrad_weight(h,theta,distances,depth,rhob=1.4):\n\"\"\"Function to compute distance weights corresponding to each soil sample.\n\n    Args:\n        h (float): Air Humidity  from 0.1  to 50 in g/m^3. When h=0, the function will skip the distance weighting.\n        theta (array or pd.Series or pd.DataFrame): Soil Moisture for each sample (0.02 - 0.50 m^3/m^3)\n        distances (array or pd.Series or pd.DataFrame): Distances from the location of each sample to the origin (0.5 - 600 m)\n        depth (array or pd.Series or pd.DataFrame): Depths for each sample (m)\n        rhob (float): Bulk density in g/cm^3\n\n    Returns:\n        (array or pd.Series or pd.DataFrame): Distance weights for each sample.\n\n    References:\n        K\u00f6hli, M., Schr\u00f6n, M., Zreda, M., Schmidt, U., Dietrich, P., and Zacharias, S. (2015).\n        Footprint characteristics revised for field-scale soil moisture monitoring with cosmic-ray\n        neutrons. Water Resour. Res. 51, 5772\u20135790. doi:10.1002/2015WR017169\n    \"\"\"\n\n    # Table A1. Parameters for Fi and D86\n    p10 = 8735;       p11 = 17.1758; p12 = 11720;      p13 = 0.00978;   p14 = 7045;      p15 = 0.003632;\n    p20 = 2.7925e-2;  p21 = 5.0399;  p22 = 2.8544e-2;  p23 = 0.002455;  p24 = 6.851e-5;  p25 = 9.2926;\n    p30 = 247970;     p31 = 17.63;   p32 = 374655;     p33 = 0.00191;   p34 = 195725;\n    p40 = 5.4818e-2;  p41 = 15.921;  p42 = 0.6373;     p43 = 5.99e-2;   p44 = 5.425e-4;\n    p50 = 1383702;    p51 = 4.156;   p52 = 5325;       p53 = 0.00238;   p54 = 0.0156;    p55 = 0.130;     p56 = 1521;\n    p60 = 6.031e-5;   p61 = 98.5;    p62 = 1.0466e-3;\n    p70 = 11747;      p71 = 41.66;   p72 = 4521;       p73 = 0.01998;   p74 = 0.00604;   p75 = 2534;      p76 = 0.00475;\n    p80 = 1.543e-2;   p81 = 10.06;   p82 = 1.807e-2;   p83 = 0.0011;    p84 = 8.81e-5;   p85 = 0.0405;    p86 = 20.24;\n    p90 = 8.321;      p91 = 0.14249; p92 = 0.96655;    p93 = 26.42;     p94 = 0.0567;\n\n\n    # Numerical determination of the penetration depth (86%) (Eq. 8)\n    D86 = 1/rhob*(p90+p91*(p92+np.exp(-1*distances/100))*(p93+theta)/(p94+theta))\n\n    # Depth weights (Eq. 7)\n    Wd = np.exp(-2*depth/D86)\n\n    if h == 0:\n        W = 1 # skip distance weighting\n\n    elif (h &gt;= 0.1) and (h&lt;= 50):\n        # Functions for Fi (Appendix A in K\u00f6hli et al., 2015)\n        F1 = p10*(1+p13*h)*np.exp(-p11*theta)+p12*(1+p15*h)-p14*theta\n        F2 = ((-p20+p24*h)*np.exp(-p21*theta/(1+p25*theta))+p22)*(1+h*p23)\n        F3 = (p30*(1+p33*h)*np.exp(-p31*theta)+p32-p34*theta)\n        F4 = p40*np.exp(-p41*theta)+p42-p43*theta+p44*h\n        F5 = p50*(0.02-1/p55/(h-p55+p56*theta))*(p54-theta)*np.exp(-p51*(theta-p54))+p52*(0.7-h*theta*p53)\n        F6 = p60*(h+p61)+p62*theta\n        F7 = (p70*(1-p76*h)*np.exp(-p71*theta*(1-h*p74))+p72-p75*theta)*(2+h*p73)\n        F8 = ((-p80+p84*h)*np.exp(-p81*theta/(1+p85*h+p86*theta))+p82)*(2+h*p83)\n\n        # Distance weights (Eq. 3)\n        W = np.ones_like(distances)*np.nan\n        for i in range(len(distances)):\n            if (distances[i]&lt;=50) and (distances[i]&gt;0.5):\n                W[i]=F1[i]*(np.exp(-F2[i]*distances[i]))+F3[i]*np.exp(-F4[i]*distances[i])\n\n            elif (distances[i]&gt;50) and (distances[i]&lt;600):\n                W[i]=F5[i]*(np.exp(-F6[i]*distances[i]))+F7[i]*np.exp(-F8[i]*distances[i])\n\n            else:\n                raise ValueError('Input distances are not valid.')\n\n    else:\n        raise ValueError('Air humidity values are out of range.')\n\n\n    # Combined and normalized weights\n    weights = Wd*W/np.nansum(Wd*W)\n\n    return weights\n</code></pre>"},{"location":"reference/#crnpy.crnpy.remove_incomplete_intervals","title":"<code>remove_incomplete_intervals(df, timestamp_col, integration_time, remove_first=False)</code>","text":"<p>Function that removes rows with incomplete integration intervals.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>Pandas Dataframe with data from stationary or roving CRNP devices.</p> required <code>timestamp_col</code> <code>str</code> <p>Name of the column with timestamps in datetime format.</p> required <code>integration_time</code> <code>int</code> <p>Duration of the neutron counting interval in seconds. Typical values are 60 seconds and 3600 seconds.</p> required <code>remove_first</code> <code>bool</code> <p>Remove first row. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def remove_incomplete_intervals(df, timestamp_col, integration_time, remove_first=False):\n\"\"\"Function that removes rows with incomplete integration intervals.\n\n    Args:\n        df (pandas.DataFrame): Pandas Dataframe with data from stationary or roving CRNP devices.\n        timestamp_col (str): Name of the column with timestamps in datetime format.\n        integration_time (int): Duration of the neutron counting interval in seconds. Typical values are 60 seconds and 3600 seconds.\n        remove_first (bool, optional): Remove first row. Default is False.\n\n    Returns:\n        (pandas.DataFrame): \n    \"\"\"\n\n    # Check format of timestamp column\n    if df[timestamp_col].dtype != 'datetime64[ns]':\n        raise TypeError('timestamp_col must be datetime64. Use `pd.to_datetime()` to fix this issue.')\n\n    # Check if differences in timestamps are below or above the provided integration time\n    idx_delta = df[timestamp_col].diff().dt.total_seconds() != integration_time\n\n    if remove_first:\n        idx_delta[0] = True\n\n    # Select rows that meet the specified integration time\n    df = df[~idx_delta]\n    df.reset_index(drop=True, inplace=True)\n\n    # Notify user about the number of rows that have been removed\n    print(f\"Removed a total of {sum(idx_delta)} rows.\")\n\n    return df\n</code></pre>"},{"location":"reference/#crnpy.crnpy.rover_centered_coordinates","title":"<code>rover_centered_coordinates(x, y)</code>","text":"<p>Function to estimate the intermediate locations between two points, assuming the measurements were taken at a constant speed.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>x coordinates.</p> required <code>y</code> <code>array</code> <p>y coordinates.</p> required <p>Returns:</p> Name Type Description <code>x_est</code> <code>array</code> <p>Estimated x coordinates.</p> <code>y_est</code> <code>array</code> <p>Estimated y coordinates.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def rover_centered_coordinates(x, y):\n\"\"\"Function to estimate the intermediate locations between two points, assuming the measurements were taken at a constant speed.\n\n    Args:\n        x (array): x coordinates.\n        y (array): y coordinates.\n\n    Returns:\n        x_est (array): Estimated x coordinates.\n        y_est (array): Estimated y coordinates.\n    \"\"\"\n\n    # Make it datatype agnostic\n    if(isinstance(x, pd.Series)):\n        x = x.values\n    if(isinstance(y, pd.Series)):\n        y = y.values\n\n    # Do the average of the two points\n    x_est = (x[1:] + x[:-1]) / 2\n    y_est = (y[1:] + y[:-1]) / 2\n\n    # Add the first point to match the length of the original array\n    x_est = np.insert(x_est, 0, x[0])\n    y_est = np.insert(y_est, 0, y[0])\n\n\n    return x_est, y_est\n</code></pre>"},{"location":"reference/#crnpy.crnpy.sensing_depth","title":"<code>sensing_depth(vwc, pressure, p_ref, bulk_density, Wlat, dist=None, method='Schron_2017')</code>","text":"<p>Function that computes the estimated sensing depth of the cosmic-ray neutron probe. The function offers several methods to compute the depth at which 86 % of the neutrons probe the soil profile.</p> <p>Parameters:</p> Name Type Description Default <code>vwc</code> <code>array or pd.Series or pd.DataFrame</code> <p>Estimated volumetric water content for each timestamp.</p> required <code>pressure</code> <code>array or pd.Series or pd.DataFrame</code> <p>Atmospheric pressure in hPa for each timestamp.</p> required <code>p_ref</code> <code>float</code> <p>Reference pressure in hPa.</p> required <code>bulk_density</code> <code>float</code> <p>Soil bulk density.</p> required <code>Wlat</code> <code>float</code> <p>Lattice water content.</p> required <code>method</code> <code>str</code> <p>Method to compute the sensing depth. Options are 'Schron_2017' or 'Franz_2012'.</p> <code>'Schron_2017'</code> <code>dist</code> <code>list or array</code> <p>List of radial distances at which to estimate the sensing depth. Only used for the 'Schron_2017' method.</p> <code>None</code> <p>Returns:</p> Type Description <code>array or pd.Series or pd.DataFrame</code> <p>Estimated sensing depth in m.</p> References <p>Franz, T.E., Zreda, M., Ferre, T.P.A., Rosolem, R., Zweck, C., Stillman, S., Zeng, X. and Shuttleworth, W.J., 2012. Measurement depth of the cosmic ray soil moisture probe affected by hydrogen from various sources. Water Resources Research, 48(8). doi.org/10.1029/2012WR011871</p> <p>Schr\u00f6n, M., K\u00f6hli, M., Scheiffele, L., Iwema, J., Bogena, H. R., Lv, L., et al. (2017). Improving calibration and validation of cosmic-ray neutron sensors in the light of spatial sensitivity. Hydrol. Earth Syst. Sci. 21, 5009\u20135030. doi.org/10.5194/hess-21-5009-2017</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def sensing_depth(vwc, pressure, p_ref, bulk_density, Wlat, dist=None, method='Schron_2017'):\n    # Convert docstring to google format\n\"\"\"Function that computes the estimated sensing depth of the cosmic-ray neutron probe.\n    The function offers several methods to compute the depth at which 86 % of the neutrons\n    probe the soil profile.\n\n    Args:\n        vwc (array or pd.Series or pd.DataFrame): Estimated volumetric water content for each timestamp.\n        pressure (array or pd.Series or pd.DataFrame): Atmospheric pressure in hPa for each timestamp.\n        p_ref (float): Reference pressure in hPa.\n        bulk_density (float): Soil bulk density.\n        Wlat (float): Lattice water content.\n        method (str): Method to compute the sensing depth. Options are 'Schron_2017' or 'Franz_2012'.\n        dist (list or array): List of radial distances at which to estimate the sensing depth. Only used for the 'Schron_2017' method.\n\n    Returns:\n        (array or pd.Series or pd.DataFrame): Estimated sensing depth in m.\n\n    References:\n        Franz, T.E., Zreda, M., Ferre, T.P.A., Rosolem, R., Zweck, C., Stillman, S., Zeng, X. and Shuttleworth, W.J., 2012.\n        Measurement depth of the cosmic ray soil moisture probe affected by hydrogen from various sources.\n        Water Resources Research, 48(8). doi.org/10.1029/2012WR011871\n\n        Schr\u00f6n, M., K\u00f6hli, M., Scheiffele, L., Iwema, J., Bogena, H. R., Lv, L., et al. (2017).\n        Improving calibration and validation of cosmic-ray neutron sensors in the light of spatial sensitivity.\n        Hydrol. Earth Syst. Sci. 21, 5009\u20135030. doi.org/10.5194/hess-21-5009-2017\n    \"\"\"\n\n    # Determine sensing depth (D86)\n    if method == 'Schron_2017':\n        # See Appendix A of Schr\u00f6n et al. (2017)\n        Fp = 0.4922 / (0.86 - np.exp(-1 * pressure / p_ref));\n        Fveg = 0\n        results = []\n        for d in dist:\n            # Compute r_star\n            r_start = d/Fp\n\n            # Compute soil depth that accounts for 86% of the neutron flux\n            D86 = 1/ bulk_density * (8.321+0.14249*(0.96655 + np.exp(-0.01*r_start))*(20+(Wlat+vwc)) / (0.0429+(Wlat+vwc)))\n            results.append(D86)\n\n    elif method == 'Franz_2012':\n        results = 5.8/(bulk_density*Wlat+vwc+0.0829)\n    else:\n        raise ValueError('Method not recognized. Please select either \"Schron_2017\" or \"Franz_2012\".')\n\n    return results\n</code></pre>"},{"location":"reference/#crnpy.crnpy.smooth_1d","title":"<code>smooth_1d(values, window=5, order=3, method='moving_median')</code>","text":"<p>Use a Savitzky-Golay filter to smooth the signal of corrected neutron counts or another one-dimensional array (e.g. computed volumetric water content).</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.DataFrame or pd.Serie</code> <p>Dataframe containing the values to smooth.</p> required <code>window</code> <code>int</code> <p>Window size for the Savitzky-Golay filter. Default is 5.</p> <code>5</code> <code>method</code> <code>str</code> <p>Method to use for smoothing the data. Default is 'moving_median'. Options are 'moving_average', 'moving_median' and 'savitzky_golay'.</p> <code>'moving_median'</code> <code>order</code> <code>int</code> <p>Order of the Savitzky-Golay filter. Default is 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>DataFrame with smoothed values.</p> References <p>Franz, T.E., Wahbi, A., Zhang, J., Vreugdenhil, M., Heng, L., Dercon, G., Strauss, P., Brocca, L. and Wagner, W., 2020. Practical data products from cosmic-ray neutron sensing for hydrological applications. Frontiers in Water, 2, p.9. doi.org/10.3389/frwa.2020.00009</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def smooth_1d(values, window=5, order=3, method='moving_median'):\n\"\"\"Use a Savitzky-Golay filter to smooth the signal of corrected neutron counts or another one-dimensional array (e.g. computed volumetric water content).\n\n    Args:\n        values (pd.DataFrame or pd.Serie): Dataframe containing the values to smooth.\n        window (int): Window size for the Savitzky-Golay filter. Default is 5.\n        method (str): Method to use for smoothing the data. Default is 'moving_median'.\n            Options are 'moving_average', 'moving_median' and 'savitzky_golay'.\n        order (int): Order of the Savitzky-Golay filter. Default is 3.\n\n    Returns:\n        (pd.DataFrame): DataFrame with smoothed values.\n\n    References:\n        Franz, T.E., Wahbi, A., Zhang, J., Vreugdenhil, M., Heng, L., Dercon, G., Strauss, P., Brocca, L. and Wagner, W., 2020.\n        Practical data products from cosmic-ray neutron sensing for hydrological applications. Frontiers in Water, 2, p.9.\n        doi.org/10.3389/frwa.2020.00009\n    \"\"\"\n\n    if method == 'moving_average':\n        corrected_counts = values.rolling(window=window, center=True, min_periods=1).mean()\n    elif method == 'moving_median':\n        corrected_counts = values.rolling(window=window, center=True, min_periods=1).median()\n\n    elif method == 'savitzky_golay':\n        if values.isna().any():\n            print('Dataframe contains NaN values. Please remove NaN values before smoothing the data.')\n\n        if type(values) == pd.core.series.Series:\n            filtered = savgol_filter(values,window,order)\n            corrected_counts = pd.DataFrame(filtered,columns=['smoothed'], index=values.index)\n        elif type(values) == pd.core.frame.DataFrame:\n            for col in values.columns:\n                values[col] = savgol_filter(values[col],window,order)\n    else:\n        raise ValueError('Invalid method. Please select a valid filtering method., options are: moving_average, moving_median, savitzky_golay')\n    corrected_counts = corrected_counts.ffill(limit=window).bfill(limit=window).copy()\n    return corrected_counts\n</code></pre>"},{"location":"reference/#crnpy.crnpy.spatial_average","title":"<code>spatial_average(x, y, z, buffer=100, min_neighbours=3, method='mean', rnd=False)</code>","text":"<p>Moving buffer filter to smooth georeferenced two-dimensional data.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list or array</code> <p>UTM x coordinates in meters.</p> required <code>y</code> <code>list or array</code> <p>UTM y coordinates in meters.</p> required <code>z</code> <code>list or array</code> <p>Values to be smoothed.</p> required <code>buffer</code> <code>float</code> <p>Radial buffer distance in meters.</p> <code>100</code> <code>min_neighbours</code> <code>int</code> <p>Minimum number of neighbours to consider for the smoothing.</p> <code>3</code> <code>method</code> <code>str</code> <p>One of 'mean' or 'median'.</p> <code>'mean'</code> <code>rnd</code> <code>bool</code> <p>Boolean to round the final result. Useful in case of z representing neutron counts.</p> <code>False</code> <p>Returns:</p> Type Description <code>array</code> <p>Smoothed version of z with the same dimension as z.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def spatial_average(x, y, z, buffer=100, min_neighbours=3, method='mean', rnd=False):\n\"\"\"Moving buffer filter to smooth georeferenced two-dimensional data.\n\n    Args:\n        x (list or array): UTM x coordinates in meters.\n        y (list or array): UTM y coordinates in meters.\n        z (list or array): Values to be smoothed.\n        buffer (float): Radial buffer distance in meters.\n        min_neighbours (int): Minimum number of neighbours to consider for the smoothing.\n        method (str): One of 'mean' or 'median'.\n        rnd (bool): Boolean to round the final result. Useful in case of z representing neutron counts.\n\n    Returns:\n        (array): Smoothed version of z with the same dimension as z.\n    \"\"\"\n\n    # Convert input data to Numpy arrays\n    if (type(x) is not np.ndarray) or (type(y) is not np.ndarray):\n        try:\n            x = np.array(x)\n            y = np.array(y)\n        except:\n            raise \"Input values cannot be converted to Numpy arrays.\"\n\n    if len(x) != len(y):\n        raise f\"The number of x and y must be equal. Input x has {len(x)} values and y has {len(y)} values.\"\n\n    # Compute distances\n    N = len(x)\n    z_smooth = np.array([])\n    for k in range(N):\n        px = x[k]\n        py = y[k]\n\n        distances = euclidean_distance(px, py, x, y)\n        idx_within_buffer = distances &lt;= buffer\n\n\n        if np.isnan(z[k]):\n            z_new_val = np.nan\n        elif len(distances[idx_within_buffer]) &gt; min_neighbours:\n            if method == 'mean':\n                z_new_val = np.nanmean(z[idx_within_buffer])\n            elif method == 'median':\n                z_new_val = np.nanmedian(z[idx_within_buffer])\n            else:\n                raise f\"Method {method} does not exist. Provide either 'mean' or 'median'.\"\n        else:\n            z_new_val = z[k] # If there are not enough neighbours, keep the original value\n\n        # Append smoothed value to array\n        z_smooth = np.append(z_smooth, z_new_val)\n\n    if rnd:\n        z_smooth = np.round(z_smooth, 0)\n\n    return z_smooth\n</code></pre>"},{"location":"reference/#crnpy.crnpy.total_raw_counts","title":"<code>total_raw_counts(counts, nan_strategy=None, timestamp_col=None)</code>","text":"<p>Compute the sum of uncorrected neutron counts for all detectors.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>pandas.DataFrame</code> <p>Dataframe containing only the columns with neutron counts.</p> required <code>nan_strategy</code> <code>str</code> <p>Strategy to use for NaN values. Options are 'interpolate', 'average', or None. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>Dataframe with the sum of uncorrected neutron counts for all detectors.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def total_raw_counts(counts, nan_strategy=None, timestamp_col=None):\n\"\"\"Compute the sum of uncorrected neutron counts for all detectors.\n\n    Args:\n        counts (pandas.DataFrame): Dataframe containing only the columns with neutron counts.\n        nan_strategy (str): Strategy to use for NaN values. Options are 'interpolate', 'average', or None. Default is None.\n\n    Returns:\n        (pandas.DataFrame): Dataframe with the sum of uncorrected neutron counts for all detectors.\n    \"\"\"\n\n    if counts.shape[0] &gt; 1:\n        counts = counts.apply(lambda x: x.fillna(counts.mean(axis=1)),axis=0)\n\n    # Compute sum of counts\n    total_raw_counts = counts.sum(axis=1)\n\n    # Replace zeros with NaN\n    total_raw_counts = total_raw_counts.replace(0, np.nan)\n\n    return total_raw_counts\n</code></pre>"},{"location":"reference/#crnpy.crnpy.uncertainty_counts","title":"<code>uncertainty_counts(raw_counts, metric='std', fp=1, fw=1, fi=1)</code>","text":"<p>Function to estimate the uncertainty of raw counts.</p> <p>Measurements of a proportional neutron detector system are governed by counting statistics that follow a Poissonian probability distribution (Zreda et al., 2012). The expected uncertainty in the neutron count rate N is defined by the standard deviation $ \\sqrt{N} $. (Jakobi et al., 2020) It can be expressed as CV% as $ N^{-1/2} $</p> <p>Parameters:</p> Name Type Description Default <code>raw_counts</code> <code>array</code> <p>Raw neutron counts.</p> required <p>Returns:</p> Name Type Description <code>uncertainty</code> <code>float</code> <p>Uncertainty of raw counts.</p> References <p>Jakobi J, Huisman JA, Schr\u00f6n M, Fiedler J, Brogi C, Vereecken H and Bogena HR (2020) Error Estimation for Soil Moisture Measurements With Cosmic Ray Neutron Sensing and Implications for Rover Surveys. Front. Water 2:10. doi: 10.3389/frwa.2020.00010</p> <p>Zreda, M., Shuttleworth, W. J., Zeng, X., Zweck, C., Desilets, D., Franz, T., and Rosolem, R.: COSMOS: the COsmic-ray Soil Moisture Observing System, Hydrol. Earth Syst. Sci., 16, 4079\u20134099, https://doi.org/10.5194/hess-16-4079-2012, 2012.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def uncertainty_counts(raw_counts, metric=\"std\", fp=1, fw=1, fi=1):\n\"\"\"Function to estimate the uncertainty of raw counts.\n\n    Measurements of a proportional neutron detector system are governed by counting statistics that follow a Poissonian probability distribution (Zreda et al., 2012).\n    The expected uncertainty in the neutron count rate N is defined by the standard deviation $ \\sqrt{N} $. (Jakobi et al., 2020)\n    It can be expressed as CV% as $ N^{-1/2} $\n\n    Args:\n        raw_counts (array): Raw neutron counts.\n\n    Returns:\n        uncertainty (float): Uncertainty of raw counts.\n\n    References:\n        Jakobi J, Huisman JA, Schr\u00f6n M, Fiedler J, Brogi C, Vereecken H and Bogena HR (2020) Error Estimation for Soil Moisture Measurements With\n        Cosmic Ray Neutron Sensing and Implications for Rover Surveys. Front. Water 2:10. doi: 10.3389/frwa.2020.00010\n\n        Zreda, M., Shuttleworth, W. J., Zeng, X., Zweck, C., Desilets, D., Franz, T., and Rosolem, R.: COSMOS: the COsmic-ray Soil Moisture Observing System,\n        Hydrol. Earth Syst. Sci., 16, 4079\u20134099, https://doi.org/10.5194/hess-16-4079-2012, 2012.\n\n    \"\"\"\n\n    s = fw / (fp * fi)\n    if metric == \"std\":\n        uncertainty = np.sqrt(raw_counts) * s\n    elif metric == \"cv\":\n        uncertainty = 1 /  np.sqrt(raw_counts) * s\n    else:\n        raise f\"Metric {metric} does not exist. Provide either 'std' or 'cv' for standard deviation or coefficient of variation.\"\n    return uncertainty\n</code></pre>"},{"location":"reference/#crnpy.crnpy.uncertainty_vwc","title":"<code>uncertainty_vwc(raw_counts, N0, bulk_density, fp=1, fw=1, fi=1, a0=0.0808, a1=0.372, a2=0.115)</code>","text":"<p>Function to estimate the uncertainty propagated to volumetric water content.</p> <p>The uncertainty of the volumetric water content is estimated by propagating the uncertainty of the raw counts. Following Eq. 10 in Jakobi et al. (2020), the uncertainty of the volumetric water content is estimated as: $$ \\sigma_{\\theta_g}(N) = \\sigma_N \\frac{a_0 N_0}{(N_{cor} - a_1 N_0)^4} \\sqrt{(N_{cor} - a_1 N_0)^4 + 8 \\sigma_N^2 (N_{cor} - a_1 N_0)^2 + 15 \\sigma_N^4} $$</p> <p>Parameters:</p> Name Type Description Default <code>raw_counts</code> <code>array</code> <p>Raw neutron counts.</p> required <code>N0</code> <code>float</code> <p>Calibration parameter N0.</p> required <code>bulk_density</code> <code>float</code> <p>Bulk density in kg/m3.</p> required <code>fp</code> <code>float</code> <p>Calibration parameter fp.</p> <code>1</code> <code>fw</code> <code>float</code> <p>Calibration parameter fw.</p> <code>1</code> <code>fi</code> <code>float</code> <p>Calibration parameter fi.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>sigma_VWC</code> <code>float</code> <p>Uncertainty in terms of volumetric water content.</p> References <p>Jakobi J, Huisman JA, Schr\u00f6n M, Fiedler J, Brogi C, Vereecken H and Bogena HR (2020) Error Estimation for Soil Moisture Measurements With Cosmic Ray Neutron Sensing and Implications for Rover Surveys. Front. Water 2:10. doi: 10.3389/frwa.2020.00010</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def uncertainty_vwc(raw_counts, N0, bulk_density, fp=1, fw=1, fi=1, a0=0.0808,a1=0.372,a2=0.115):\nr\"\"\"Function to estimate the uncertainty propagated to volumetric water content.\n\n    The uncertainty of the volumetric water content is estimated by propagating the uncertainty of the raw counts.\n    Following Eq. 10 in Jakobi et al. (2020), the uncertainty of the volumetric water content is estimated as:\n    $$\n    \\sigma_{\\theta_g}(N) = \\sigma_N \\frac{a_0 N_0}{(N_{cor} - a_1 N_0)^4} \\sqrt{(N_{cor} - a_1 N_0)^4 + 8 \\sigma_N^2 (N_{cor} - a_1 N_0)^2 + 15 \\sigma_N^4}\n    $$\n\n    Args:\n        raw_counts (array): Raw neutron counts.\n        N0 (float): Calibration parameter N0.\n        bulk_density (float): Bulk density in kg/m3.\n        fp (float): Calibration parameter fp.\n        fw (float): Calibration parameter fw.\n        fi (float): Calibration parameter fi.\n\n    Returns:\n        sigma_VWC (float): Uncertainty in terms of volumetric water content.\n\n    References:\n        Jakobi J, Huisman JA, Schr\u00f6n M, Fiedler J, Brogi C, Vereecken H and Bogena HR (2020) Error Estimation for Soil Moisture Measurements With\n        Cosmic Ray Neutron Sensing and Implications for Rover Surveys. Front. Water 2:10. doi: 10.3389/frwa.2020.00010\n    \"\"\"\n\n    Ncorr = raw_counts * fw / (fp * fi)\n    sigma_N = uncertainty_counts(raw_counts, metric=\"std\", fp=fp, fw=fw, fi=fi)\n    sigma_GWC = sigma_N * ((a0*N0) / ((Ncorr - a1*N0)**4)) * np.sqrt((Ncorr - a1 * N0)**4 + 8 * sigma_N**2 * (Ncorr - a1 * N0)**2 + 15 * sigma_N**4)\n    sigma_VWC = sigma_GWC * bulk_density\n\n    return sigma_VWC\n</code></pre>"},{"location":"reference/#crnpy.data--crnpydata","title":"crnpy.data","text":"<p>Data module for crnpy.</p> <p>This module contains data for the crnpy package.</p> <p>Attributes:</p> Name Type Description <code>cutoff_rigidity</code> <code>list</code> <p>Cutoff rigidity values for the whole world. See crnpy.crnpy.cutoff_rigidity</p> <code>neutron_detectors</code> <code>list</code> <p>Neutron detector locations. See crnpy.crnpy.find_neutron_monitor</p>"},{"location":"sensor_description/","title":"Sensor description","text":"<p>The cosmic-ray neutron sensing technology is an innovative and non-invasive method for monitoring soil moisture. The sensing principle is based on the detection of neutrons that are generated when cosmic rays interact with atoms in the Earth's atmosphere. These neutrons, in turn, interact with hydrogen pools in the land surface, and thus, the intensity of neutrons detected near the ground surface is inversely related to the amunt of water in land biomass and the top layers of the soil. Typically, cosmic-ray neutron probes have a large sensing footprint, covering an area of approximately 12 hectares (about 30 acres) and can measure soil moisture up to a depth of 70 cm (about 28 inches), although typically most field applications span a depth between 5 and 40 cm. This makes the technology particularly useful for capturing spatially-averaged soil moisture over large areas, bridging the gap between point measurements and remote sensing. In hydrology, cosmic-ray neutron sensors are used for watershed studies, understanding water balance, and improving hydrological models. In agriculture, they are employed for irrigation management, crop yield prediction, and understanding the effects of soil moisture on plant growth. The technology's ability to provide continuous, real-time data without disturbing the soil makes it a valuable tool for both hydrological and agricultural research.</p> <p> Figure 1. A) Stationary detector manufactured by Radiation Detection Technologies, Inc. (Manhattan, KS). B) Stationary detector manufactured by Hydroinnova, Inc. (Albuquerque, NM). C) Roving detector manufactured by Hydroinnova, Inc. (Albuquerque, NM).</p> <p> Figure 2. Illustration showing the approximate sensing footprint of stationary detectors.</p>"},{"location":"examples/calibration/calibration/","title":"Device-specific field calibration","text":"In\u00a0[1]: Copied! <pre># Importing required libraries\nimport crnpy\n\nimport numpy as np\nimport pandas as pd\nfrom scipy.optimize import root\n</pre> # Importing required libraries import crnpy  import numpy as np import pandas as pd from scipy.optimize import root  In\u00a0[2]: Copied! <pre># Load the soil samples data and the CRNP dataset using pandas\nurl_soil_samples = \"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/calibration/soil_data.csv\"\ndf_soil = pd.read_csv(url_soil_samples)\ndf_soil.head(3)\n</pre> # Load the soil samples data and the CRNP dataset using pandas url_soil_samples = \"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/calibration/soil_data.csv\" df_soil = pd.read_csv(url_soil_samples) df_soil.head(3)  Out[2]: field date core_number distance_from_station latitude longitude top_depth bottom_depth core_diameter wet_mass_with_bag ... can_number mass_empty_can wet_mass_with_can dry_mass_with_can mass_water theta_g volume bulk_density theta_v Observation 0 Flickner 22-Oct 1 5 N38.23459 W97.57101 0 5 30.49 45.31 ... 1 52.10 92.03 85.31 6.72 0.202 36.514864 0.909 0.184403 NaN 1 Flickner 22-Oct 1 5 N38.23459 W97.57101 5 10 30.49 69.53 ... 2 51.85 115.97 103.85 12.12 0.233 36.514864 1.424 0.332585 NaN 2 Flickner 22-Oct 1 5 N38.23459 W97.57101 10 25 30.49 214.90 ... 3 51.56 260.97 219.77 41.20 0.245 109.544592 1.536 0.376856 NaN <p>3 rows \u00d7 21 columns</p> In\u00a0[3]: Copied! <pre># Define start and end of field survey calibration\ncalibration_start = pd.to_datetime(\"2021-10-22 08:00\")\ncalibration_end = pd.to_datetime(\"2021-10-22 16:00\")\n</pre> # Define start and end of field survey calibration calibration_start = pd.to_datetime(\"2021-10-22 08:00\") calibration_end = pd.to_datetime(\"2021-10-22 16:00\")  In\u00a0[4]: Copied! <pre># Load the station data\nurl_station_data = \"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/calibration/station_data.csv\"\ndf_station = pd.read_csv(url_station_data, skiprows=[0,2,3])\n\n#  Parse dates (you can also use the option `parse_dates=['TIMESTAMP]` in pd.read_csv()\ndf_station['timestamp'] = pd.to_datetime(df_station['TIMESTAMP'], format='%Y-%m-%d %H:%M:%S')\n\ndf_station.head(3)\n</pre> # Load the station data url_station_data = \"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/calibration/station_data.csv\" df_station = pd.read_csv(url_station_data, skiprows=[0,2,3])  #  Parse dates (you can also use the option `parse_dates=['TIMESTAMP]` in pd.read_csv() df_station['timestamp'] = pd.to_datetime(df_station['TIMESTAMP'], format='%Y-%m-%d %H:%M:%S')  df_station.head(3)  Out[4]: TIMESTAMP RECORD station farm field latitude longitude altitude battery_voltage_Min PTemp_Avg ... wind_speed_gust_Max air_temperature_Avg vapor_pressure_Avg barometric_pressure_Avg relative_humidity_Avg humidity_sensor_temperature_Avg tilt_north_south_Avg tilt_west_east_Avg NDVI_Avg timestamp 0 2021-09-22 12:00:00 0 KS003 Flickner Rainfed South 38.23461 -97.57095 455 13.52 29.04 ... 4.20 22.30 9.20 973 41.30 26.4 -1.000 1.000 0.311 2021-09-22 12:00:00 1 2021-09-22 13:00:00 1 KS003 Flickner Rainfed South 38.23461 -97.57095 455 13.53 29.98 ... 9.02 22.90 9.08 972 32.63 26.8 -0.975 0.950 0.308 2021-09-22 13:00:00 2 2021-09-22 14:00:00 2 KS003 Flickner Rainfed South 38.23461 -97.57095 455 13.53 30.43 ... 5.54 23.38 8.68 971 30.25 27.2 -0.775 0.625 0.31 2021-09-22 14:00:00 <p>3 rows \u00d7 28 columns</p> In\u00a0[5]: Copied! <pre># Select station data only until the calibration date\n\n# Define date in which the probe was deployed in the field (i.e., first record)\ndeployment_date = df_station['timestamp'].iloc[0]\n\n# Filter station data from the first record to the end of the field survey calibration\n# This is important since we are considering the incoming flux on the first day as the reference value\nidx_period = (df_station['timestamp'] &gt;= deployment_date) &amp; (df_station['timestamp'] &lt;= calibration_end)\ndf_station = df_station[idx_period]\ndf_station.head(3)\n</pre> # Select station data only until the calibration date  # Define date in which the probe was deployed in the field (i.e., first record) deployment_date = df_station['timestamp'].iloc[0]  # Filter station data from the first record to the end of the field survey calibration # This is important since we are considering the incoming flux on the first day as the reference value idx_period = (df_station['timestamp'] &gt;= deployment_date) &amp; (df_station['timestamp'] &lt;= calibration_end) df_station = df_station[idx_period] df_station.head(3)  Out[5]: TIMESTAMP RECORD station farm field latitude longitude altitude battery_voltage_Min PTemp_Avg ... wind_speed_gust_Max air_temperature_Avg vapor_pressure_Avg barometric_pressure_Avg relative_humidity_Avg humidity_sensor_temperature_Avg tilt_north_south_Avg tilt_west_east_Avg NDVI_Avg timestamp 0 2021-09-22 12:00:00 0 KS003 Flickner Rainfed South 38.23461 -97.57095 455 13.52 29.04 ... 4.20 22.30 9.20 973 41.30 26.4 -1.000 1.000 0.311 2021-09-22 12:00:00 1 2021-09-22 13:00:00 1 KS003 Flickner Rainfed South 38.23461 -97.57095 455 13.53 29.98 ... 9.02 22.90 9.08 972 32.63 26.8 -0.975 0.950 0.308 2021-09-22 13:00:00 2 2021-09-22 14:00:00 2 KS003 Flickner Rainfed South 38.23461 -97.57095 455 13.53 30.43 ... 5.54 23.38 8.68 971 30.25 27.2 -0.775 0.625 0.31 2021-09-22 14:00:00 <p>3 rows \u00d7 28 columns</p> <p>This step is useful to trim large timeseries. For instance, the station data in our case extends until <code>2022-07-11 09:45:00</code>, but the field calibration was conducted in <code>2021-10-22 16:00</code>. Since all the station observation after the date of the field calibration are not relevent, we decided to only work with the data that we need from <code>2021-09-22 12:00:00</code> until <code>2021-10-22 16:00</code>. This could help getting data of incoming neutron flux from a single reference neutron monitor. So, if you are running this code shortly after the calibration field survey, then there is no need to filter station data.</p> In\u00a0[6]: Copied! <pre># Compute total neutron counts by adding the counts from both probe detectors\ndf_station['total_raw_counts'] = crnpy.total_raw_counts(df_station[['counts_1_Tot','counts_2_Tot']],\n                                                    nan_strategy='average')\n</pre> # Compute total neutron counts by adding the counts from both probe detectors df_station['total_raw_counts'] = crnpy.total_raw_counts(df_station[['counts_1_Tot','counts_2_Tot']],                                                     nan_strategy='average')  In\u00a0[7]: Copied! <pre># Atmospheric corrections\n\n# Fill NaN values in atmospheric data\ndf_station[['barometric_pressure_Avg','relative_humidity_Avg', 'air_temperature_Avg']] = df_station[['barometric_pressure_Avg','relative_humidity_Avg', 'air_temperature_Avg']].interpolate(method='pchip', limit=24, limit_direction='both')\n\n# Calculate absolute humidity\ndf_station['abs_humidity'] = crnpy.abs_humidity(df_station['relative_humidity_Avg'], df_station['air_temperature_Avg'])\n\n# Compute correction factor for atmospheric pressure\n# Reference atmospheric pressure for the location is 976 Pa\n# Using an atmospheric attentuation coefficient of 130 g/cm2\ndf_station['fp'] = crnpy.correction_pressure(pressure=df_station['barometric_pressure_Avg'],\n                                             Pref=976, L=130)\n\n# Compute correction factor for air humidity\ndf_station['fw'] = crnpy.correction_humidity(abs_humidity=df_station['abs_humidity'],\n                                             Aref=0)\n</pre> # Atmospheric corrections  # Fill NaN values in atmospheric data df_station[['barometric_pressure_Avg','relative_humidity_Avg', 'air_temperature_Avg']] = df_station[['barometric_pressure_Avg','relative_humidity_Avg', 'air_temperature_Avg']].interpolate(method='pchip', limit=24, limit_direction='both')  # Calculate absolute humidity df_station['abs_humidity'] = crnpy.abs_humidity(df_station['relative_humidity_Avg'], df_station['air_temperature_Avg'])  # Compute correction factor for atmospheric pressure # Reference atmospheric pressure for the location is 976 Pa # Using an atmospheric attentuation coefficient of 130 g/cm2 df_station['fp'] = crnpy.correction_pressure(pressure=df_station['barometric_pressure_Avg'],                                              Pref=976, L=130)  # Compute correction factor for air humidity df_station['fw'] = crnpy.correction_humidity(abs_humidity=df_station['abs_humidity'],                                              Aref=0)  In\u00a0[8]: Copied! <pre># Find the cutoff rigidity for the location\ncutoff_rigidity = crnpy.cutoff_rigidity(39.1, -96.6)\n\n# Filtering the time window from experiment setup to the end of the calibration\ncrnpy.find_neutron_monitor(cutoff_rigidity,\n                           start_date=df_station['timestamp'].iloc[0],\n                           end_date=df_station['timestamp'].iloc[-1])\n</pre> # Find the cutoff rigidity for the location cutoff_rigidity = crnpy.cutoff_rigidity(39.1, -96.6)  # Filtering the time window from experiment setup to the end of the calibration crnpy.find_neutron_monitor(cutoff_rigidity,                            start_date=df_station['timestamp'].iloc[0],                            end_date=df_station['timestamp'].iloc[-1])  <pre>\nSelect a station with an altitude similar to that of your location. For more information go to: 'https://www.nmdb.eu/nest/help.php#helpstations\n\nYour cutoff rigidity is 2.87 GV\n     STID     NAME     R  Altitude_m  Period available\n13   DRBS  Dourbes  3.18         225              True\n40   NEWK   Newark  2.40          50              True\n28  KIEL2   KielRT  2.36          54              True\n</pre> Out[8]: STID NAME R Altitude_m Period available 13 DRBS Dourbes 3.18 225 True 40 NEWK Newark 2.40 50 True 28 KIEL2 KielRT 2.36 54 True In\u00a0[9]: Copied! <pre># Incoming neutron flux correction\n\n# Download data for the reference neutron monitor and add to the DataFrame\nnmdb = crnpy.get_incoming_neutron_flux(deployment_date,\n                                        calibration_end,\n                                        station=\"DRBS\",\n                                        utc_offset=-6)\n\n# Interpolate incoming neutron flux to match the timestamps in our station data\ndf_station['incoming_flux'] = crnpy.interpolate_incoming_flux(nmdb['timestamp'], nmdb['counts'], df_station['timestamp'])\n\n# Compute correction factor for incoming neutron flux\ndf_station['fi'] = crnpy.correction_incoming_flux(incoming_neutrons=df_station['incoming_flux'],\n                                                  incoming_Ref=df_station['incoming_flux'].iloc[0])\n</pre> # Incoming neutron flux correction  # Download data for the reference neutron monitor and add to the DataFrame nmdb = crnpy.get_incoming_neutron_flux(deployment_date,                                         calibration_end,                                         station=\"DRBS\",                                         utc_offset=-6)  # Interpolate incoming neutron flux to match the timestamps in our station data df_station['incoming_flux'] = crnpy.interpolate_incoming_flux(nmdb['timestamp'], nmdb['counts'], df_station['timestamp'])  # Compute correction factor for incoming neutron flux df_station['fi'] = crnpy.correction_incoming_flux(incoming_neutrons=df_station['incoming_flux'],                                                   incoming_Ref=df_station['incoming_flux'].iloc[0])   In\u00a0[10]: Copied! <pre># Apply correction factors\ndf_station['total_corrected_neutrons'] = df_station['total_raw_counts'] * df_station['fw'] / (df_station['fp'] * df_station['fi'])\n</pre> # Apply correction factors df_station['total_corrected_neutrons'] = df_station['total_raw_counts'] * df_station['fw'] / (df_station['fp'] * df_station['fi'])  In\u00a0[11]: Copied! <pre># Compute the weights of each sample for the field average\nnrad_weights = crnpy.nrad_weight(df_station['abs_humidity'].mean(), df_soil['theta_v'], df_soil['distance_from_station'], (df_soil['bottom_depth']+df_soil['top_depth'])/2, rhob=df_soil['bulk_density'].mean())\n\n# Apply distance weights to volumetric water content and bulk density\nfield_theta_v = np.sum(df_soil['theta_v']*nrad_weights)\nfield_bulk_density = np.sum(df_soil['bulk_density']*nrad_weights)\n</pre> # Compute the weights of each sample for the field average nrad_weights = crnpy.nrad_weight(df_station['abs_humidity'].mean(), df_soil['theta_v'], df_soil['distance_from_station'], (df_soil['bottom_depth']+df_soil['top_depth'])/2, rhob=df_soil['bulk_density'].mean())  # Apply distance weights to volumetric water content and bulk density field_theta_v = np.sum(df_soil['theta_v']*nrad_weights) field_bulk_density = np.sum(df_soil['bulk_density']*nrad_weights)  In\u00a0[12]: Copied! <pre># Determine the mean corrected counts during the calibration survey\nidx_cal_period = (df_station['timestamp'] &gt;= calibration_start) &amp; (df_station['timestamp'] &lt;= calibration_end)\nmean_cal_counts = df_station.loc[idx_cal_period, 'total_corrected_neutrons'].mean()\n\nprint(f\"Mean volumetric Water content during calibration survey: {round(field_theta_v,3)}\")\nprint(f\"Mean corrected counts during calibration: {round(mean_cal_counts)} counts\")\n</pre> # Determine the mean corrected counts during the calibration survey idx_cal_period = (df_station['timestamp'] &gt;= calibration_start) &amp; (df_station['timestamp'] &lt;= calibration_end) mean_cal_counts = df_station.loc[idx_cal_period, 'total_corrected_neutrons'].mean()  print(f\"Mean volumetric Water content during calibration survey: {round(field_theta_v,3)}\") print(f\"Mean corrected counts during calibration: {round(mean_cal_counts)} counts\")  <pre>Mean volumetric Water content during calibration survey: 0.263\nMean corrected counts during calibration: 1542 counts\n</pre> In\u00a0[13]: Copied! <pre># Define the function for which we want to find the roots\nVWC_func = lambda N0 : crnpy.counts_to_vwc(mean_cal_counts, N0, bulk_density=field_bulk_density, Wlat=0.03, Wsoc=0.01) - field_theta_v\n\n# Make an initial guess for N0\nN0_initial_guess = 1000\n\n# Find the root\nsol = int(root(VWC_func, N0_initial_guess).x)\n\n# Print the solution\nprint(f\"The solved value for N0 is: {sol}\")\n</pre> # Define the function for which we want to find the roots VWC_func = lambda N0 : crnpy.counts_to_vwc(mean_cal_counts, N0, bulk_density=field_bulk_density, Wlat=0.03, Wsoc=0.01) - field_theta_v  # Make an initial guess for N0 N0_initial_guess = 1000  # Find the root sol = int(root(VWC_func, N0_initial_guess).x)  # Print the solution print(f\"The solved value for N0 is: {sol}\")  <pre>The solved value for N0 is: 2644\n</pre>"},{"location":"examples/calibration/calibration/#device-specific-field-calibration","title":"Device-specific field calibration\u00b6","text":"<p>The calibration of a cosmic-ray neutron probe (CRNP) is an essential step to ensure accurate soil moisture measurements. The CRNP operates by counting fast neutrons produced from cosmic rays, which are predominantly moderated by water molecules in the soil. The parameter $N_0$ is typically considered a device-specific constant that represents the neutron count rate in the absence of soil moisture conditions.</p> <p>$\\theta(N) =\\frac{a_0}{(\\frac{N}{N_0}) - a_1} - a_2 $ (Desilets et al., 2010).</p> <p>For the calibration of the stationary detector, a total of 14 undisturbed soil cores were collected at radial distances of 5, 50, and 100 m from the detector. In this example each soil sample was split into four depth segments: 0-5 cm, 5-10 cm, 10-25 cm, and 25-40 cm. Soil samples were processed and soil moisture was determined using the thermo-gravimetric method.</p> <p>Figure 1. Horizontal layout and vertical layout used in this particular example calibration, it can be customized by the user depending on their needs.</p> <p>Download the following template  for collecting your own calibration soil samples:</p>"},{"location":"examples/calibration/calibration/#read-calibration-field-survey-data","title":"Read calibration field survey data\u00b6","text":"<p>For each sample it is required to know the bulk density ($\\rho_\\beta$) and the volumetric water content ($\\theta_v$). See the details of the calculation used in the filled example.</p>"},{"location":"examples/calibration/calibration/#read-data-from-crnp","title":"Read data from CRNP\u00b6","text":""},{"location":"examples/calibration/calibration/#correct-neutron-counts","title":"Correct neutron counts\u00b6","text":""},{"location":"examples/calibration/calibration/#determine-field-average-soil-moisture-and-bulk-density","title":"Determine field-average soil moisture and bulk density\u00b6","text":"<p>Using the function <code>nrad_weight()</code> the weights corresponding to each soil sample will be computed considering air-humidity, sample depth, distance from station and bulk density.</p>"},{"location":"examples/calibration/calibration/#solving-for-n_0","title":"Solving for $N_0$\u00b6","text":"<p>Previous steps estimated the a field volumetric water content of <code>0.263</code> and an average neutron count of <code>1542</code>. Using <code>scipy.optimize.root()</code> $N_0$ is estimated given the observed value of $\\theta_v$ and neutron counts.</p>"},{"location":"examples/calibration/calibration/#references","title":"References:\u00b6","text":"<p>Desilets, D., Zreda, M., &amp; Ferr\u00e9, T. P. (2010). Nature's neutron probe: Land surface hydrology at an elusive scale with cosmic rays. Water Resources Research, 46(11).</p> <p>Dong, J., &amp; Ochsner, T. E. (2018). Soil texture often exerts a stronger influence than precipitation on mesoscale soil moisture patterns. Water Resources Research, 54(3), 2199-2211.</p> <p>Patrignani, A., Ochsner, T. E., Montag, B., &amp; Bellinger, S. (2021). A novel lithium foil cosmic-ray neutron detector for measuring field-scale soil moisture. Frontiers in Water, 3, 673185.</p>"},{"location":"examples/rover/Hydroinnova_rover_example/","title":"Processing and analyzing data from a roving detector","text":"In\u00a0[1]: Copied! <pre># Import modules\nimport crnpy\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n</pre> # Import modules import crnpy  import numpy as np import pandas as pd import matplotlib.pyplot as plt  <p>Load the data stored in the .csv file.</p> In\u00a0[2]: Copied! <pre># Load sample dataset\nfilepath = \"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/rover/gypsum_transect_01_may_2018.KSU\"\ncol_names = 'RecordNum,Date Time(UTC),barometric_pressure_Avg,P4_mb,P1_mb,T1_C,RH1,air_temperature_Avg,relative_humidity_Avg,Vbat,N1Cts,N2Cts,N3Cts,N4Cts,N5Cts,N6Cts,N7Cts,N8Cts,N1ETsec,N3ETsec,N5ETsec,N7ETsec,N1T(C),N1RH,N5T(C),N5RH,GpsUTC,LatDec,LongDec,Alt,Qual,NumSats,HDOP,Speed_kmh,COG,SpeedQuality,strDate'.split(',')\n\ndf = pd.read_csv(filepath, skiprows=20, names=col_names)\ndf['LongDec'] = df['LongDec'] * -1 # Raw data is in absolute values\n\n# Parse timestamps and set as index\ndf['timestamp'] = pd.to_datetime(df['Date Time(UTC)'])\n\n# Remove rows with missing coordinates\ndf['LatDec'].replace(0.0, np.nan, inplace=True)\ndf['LongDec'].replace(0.0, np.nan, inplace=True)\ndf.dropna(axis=0, subset=['LatDec','LongDec'], inplace=True)\ndf.reset_index(drop=True, inplace=True)\n\n# Display a few rows to visualize dataset\ndf.head(3)\n</pre> # Load sample dataset filepath = \"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/rover/gypsum_transect_01_may_2018.KSU\" col_names = 'RecordNum,Date Time(UTC),barometric_pressure_Avg,P4_mb,P1_mb,T1_C,RH1,air_temperature_Avg,relative_humidity_Avg,Vbat,N1Cts,N2Cts,N3Cts,N4Cts,N5Cts,N6Cts,N7Cts,N8Cts,N1ETsec,N3ETsec,N5ETsec,N7ETsec,N1T(C),N1RH,N5T(C),N5RH,GpsUTC,LatDec,LongDec,Alt,Qual,NumSats,HDOP,Speed_kmh,COG,SpeedQuality,strDate'.split(',')  df = pd.read_csv(filepath, skiprows=20, names=col_names) df['LongDec'] = df['LongDec'] * -1 # Raw data is in absolute values  # Parse timestamps and set as index df['timestamp'] = pd.to_datetime(df['Date Time(UTC)'])  # Remove rows with missing coordinates df['LatDec'].replace(0.0, np.nan, inplace=True) df['LongDec'].replace(0.0, np.nan, inplace=True) df.dropna(axis=0, subset=['LatDec','LongDec'], inplace=True) df.reset_index(drop=True, inplace=True)  # Display a few rows to visualize dataset df.head(3)  Out[2]: RecordNum Date Time(UTC) barometric_pressure_Avg P4_mb P1_mb T1_C RH1 air_temperature_Avg relative_humidity_Avg Vbat ... LongDec Alt Qual NumSats HDOP Speed_kmh COG SpeedQuality strDate timestamp 0 2 2018/05/01 14:15:00 962.95 962.8 961.4 23.2 35.4 20.9 72.7 13.574 ... -97.37195 393.2 2.0 10 0.8 0.00 270.7 A 10518.0 2018-05-01 14:15:00 1 3 2018/05/01 14:16:00 962.88 962.7 961.3 23.3 35.5 21.0 72.7 13.417 ... -97.37197 387.2 2.0 11 0.8 0.00 270.7 A 10518.0 2018-05-01 14:16:00 2 4 2018/05/01 14:17:00 962.64 962.5 961.1 23.4 35.4 21.2 72.2 13.282 ... -97.37199 388.2 1.0 11 0.8 3.89 356.3 A 10518.0 2018-05-01 14:17:00 <p>3 rows \u00d7 38 columns</p> <p>Next, convert the latitude and longitude to UTM coordinates (x and y). A scatter plot is created to visualize the survey points.</p> In\u00a0[3]: Copied! <pre># Convert Lat and Lon to X and Y\ndf['x'],df['y'] = crnpy.latlon_to_utm(df['LatDec'], df['LongDec'], 14, missing_values=0.0)\n\n# Create figure of survey points\nplt.figure(figsize = (5,5))\nplt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w', label = \"Observation end\")\n\n# Estimate the center of the observation, assuming each timestamp is observation end time.\ndf['x'],df['y'] = crnpy.rover_centered_coordinates(df['x'], df['y']) \nplt.scatter(df['x'], df['y'], marker='+', label=\"Observation center\")\n\nplt.ticklabel_format(scilimits = (-5,5))\nplt.xlabel('Easting')\nplt.ylabel('Northing')\nplt.legend(loc=[1.1,.8])\nplt.show()\n</pre> # Convert Lat and Lon to X and Y df['x'],df['y'] = crnpy.latlon_to_utm(df['LatDec'], df['LongDec'], 14, missing_values=0.0)  # Create figure of survey points plt.figure(figsize = (5,5)) plt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w', label = \"Observation end\")  # Estimate the center of the observation, assuming each timestamp is observation end time. df['x'],df['y'] = crnpy.rover_centered_coordinates(df['x'], df['y'])  plt.scatter(df['x'], df['y'], marker='+', label=\"Observation center\")  plt.ticklabel_format(scilimits = (-5,5)) plt.xlabel('Easting') plt.ylabel('Northing') plt.legend(loc=[1.1,.8]) plt.show()  <p>The counts are normalized to counts per minute in case some observations covered a different timespan and total neutron counts are computed.</p> In\u00a0[4]: Copied! <pre># Define columns names\ncounts_colums = ['N1Cts', 'N2Cts', 'N3Cts','N4Cts', 'N5Cts', 'N6Cts', 'N7Cts', 'N8Cts']\ncont_times_col = ['N1ETsec', 'N1ETsec', 'N3ETsec','N3ETsec', 'N5ETsec', 'N5ETsec', 'N7ETsec', 'N7ETsec']\n\n# Compute total neutron counts\ndf['total_raw_counts'] = crnpy.total_raw_counts(df[counts_colums])\n</pre> # Define columns names counts_colums = ['N1Cts', 'N2Cts', 'N3Cts','N4Cts', 'N5Cts', 'N6Cts', 'N7Cts', 'N8Cts'] cont_times_col = ['N1ETsec', 'N1ETsec', 'N3ETsec','N3ETsec', 'N5ETsec', 'N5ETsec', 'N7ETsec', 'N7ETsec']  # Compute total neutron counts df['total_raw_counts'] = crnpy.total_raw_counts(df[counts_colums])  In\u00a0[5]: Copied! <pre># Define transect start and end dates\nstart_date = df.iloc[0]['timestamp']\nend_date = df.iloc[-1]['timestamp']\n\n#Find stations with cutoff rigidity similar to estimated by lat,lon\ncrnpy.find_neutron_monitor(crnpy.cutoff_rigidity(df['LatDec'][0], df['LongDec'][0]), \n                             start_date=start_date, end_date=end_date)\n</pre> # Define transect start and end dates start_date = df.iloc[0]['timestamp'] end_date = df.iloc[-1]['timestamp']  #Find stations with cutoff rigidity similar to estimated by lat,lon crnpy.find_neutron_monitor(crnpy.cutoff_rigidity(df['LatDec'][0], df['LongDec'][0]),                               start_date=start_date, end_date=end_date)  <pre>\nSelect a station with an altitude similar to that of your location. For more information go to: 'https://www.nmdb.eu/nest/help.php#helpstations\n\nYour cutoff rigidity is 2.99 GV\n    STID                          NAME     R  Altitude_m  Period available\n13  DRBS                       Dourbes  3.18         225              True\n31  MCRL  Mobile Cosmic Ray Laboratory  2.46         200              True\n33  MOSC                        Moscow  2.43         200              True\n40  NEWK                        Newark  2.40          50              True\n20  IRK3                     Irkustk 3  3.64        3000              True\n21  IRKT                       Irkustk  3.64         435              True\n</pre> Out[5]: STID NAME R Altitude_m Period available 13 DRBS Dourbes 3.18 225 True 31 MCRL Mobile Cosmic Ray Laboratory 2.46 200 True 33 MOSC Moscow 2.43 200 True 40 NEWK Newark 2.40 50 True 20 IRK3 Irkustk 3 3.64 3000 True 21 IRKT Irkustk 3.64 435 True In\u00a0[6]: Copied! <pre># Download incoming neutron flux data from the Neutron Monitor Database (NMDB).\n# Use utc_offset for Central Standard Time.\nnmdb = crnpy.get_incoming_neutron_flux(start_date, end_date, station=\"NEWK\", utc_offset=-6)\n</pre> # Download incoming neutron flux data from the Neutron Monitor Database (NMDB). # Use utc_offset for Central Standard Time. nmdb = crnpy.get_incoming_neutron_flux(start_date, end_date, station=\"NEWK\", utc_offset=-6)  In\u00a0[7]: Copied! <pre># Interpolate incoming neutron flux to match the timestamps in our rover data\ndf['incoming_flux'] = crnpy.interpolate_incoming_flux(nmdb['timestamp'], nmdb['counts'], df['timestamp'])\n</pre> # Interpolate incoming neutron flux to match the timestamps in our rover data df['incoming_flux'] = crnpy.interpolate_incoming_flux(nmdb['timestamp'], nmdb['counts'], df['timestamp'])  In\u00a0[8]: Copied! <pre># Compute correction factor for incoming neutron flux\ndf['fi'] = crnpy.correction_incoming_flux(incoming_neutrons=df['incoming_flux'],\n                                          incoming_Ref=df['incoming_flux'].iloc[0])\n</pre> # Compute correction factor for incoming neutron flux df['fi'] = crnpy.correction_incoming_flux(incoming_neutrons=df['incoming_flux'],                                           incoming_Ref=df['incoming_flux'].iloc[0])  In\u00a0[9]: Copied! <pre># Fill NaN values in atmospheric data\ndf[['barometric_pressure_Avg', 'relative_humidity_Avg', 'air_temperature_Avg']] = df[['barometric_pressure_Avg','relative_humidity_Avg', 'air_temperature_Avg']].interpolate(method='pchip', limit=24, limit_direction='both')\n\n# Compute the pressure correction factor\ndf['fp'] = crnpy.correction_pressure(pressure=df['barometric_pressure_Avg'], Pref=df['barometric_pressure_Avg'].mean(), L=130)\n\n# Estimate the absolute humidity and compute the vapor pressure correction factor\ndf['abs_humidity'] = crnpy.abs_humidity(df['relative_humidity_Avg'], df['air_temperature_Avg'])\ndf['fw'] = crnpy.correction_humidity(df['abs_humidity'], Aref=0)\n</pre> # Fill NaN values in atmospheric data df[['barometric_pressure_Avg', 'relative_humidity_Avg', 'air_temperature_Avg']] = df[['barometric_pressure_Avg','relative_humidity_Avg', 'air_temperature_Avg']].interpolate(method='pchip', limit=24, limit_direction='both')  # Compute the pressure correction factor df['fp'] = crnpy.correction_pressure(pressure=df['barometric_pressure_Avg'], Pref=df['barometric_pressure_Avg'].mean(), L=130)  # Estimate the absolute humidity and compute the vapor pressure correction factor df['abs_humidity'] = crnpy.abs_humidity(df['relative_humidity_Avg'], df['air_temperature_Avg']) df['fw'] = crnpy.correction_humidity(df['abs_humidity'], Aref=0)  In\u00a0[10]: Copied! <pre># Apply correction factors\ndf['total_corrected_neutrons'] = df['total_raw_counts'] * df['fw'] / (df['fp'] * df['fi'])\n</pre> # Apply correction factors df['total_corrected_neutrons'] = df['total_raw_counts'] * df['fw'] / (df['fp'] * df['fi'])  <p>The corrected counts are smoothed using a 2D smoothing function. The smoothed counts are then converted to volumetric water content (VWC) using the counts_to_vwc function.</p> In\u00a0[11]: Copied! <pre># Smooth variable\ndf['corrected_neutrons_smoothed'] = crnpy.spatial_average(df['x'],\n                                        df['y'],\n                                        df['total_corrected_neutrons'],\n                                        buffer= 800, method='median', rnd=True)\n\n# Estimate lattice water based on texture\nlattice_water = crnpy.lattice_water(clay_content=0.35)\n\n# Estimate Soil Columetric Water Content\ndf['VWC'] = crnpy.counts_to_vwc(df['corrected_neutrons_smoothed'], N0=550, bulk_density=1.3, Wlat=lattice_water, Wsoc=0.01)\n\n# Drop VWC NaN values before interpolating values\ndf = df.dropna(subset = ['VWC'])\n\n# Interpolate variable using IDW (https://en.wikipedia.org/wiki/Inverse_distance_weighting)\nX_pred, Y_pred, Z_pred = crnpy.interpolate_2d(df['x'],\n                                        df['y'],\n                                        df['VWC'],\n                                        dx=250, dy=250, method='idw')\n</pre> # Smooth variable df['corrected_neutrons_smoothed'] = crnpy.spatial_average(df['x'],                                         df['y'],                                         df['total_corrected_neutrons'],                                         buffer= 800, method='median', rnd=True)  # Estimate lattice water based on texture lattice_water = crnpy.lattice_water(clay_content=0.35)  # Estimate Soil Columetric Water Content df['VWC'] = crnpy.counts_to_vwc(df['corrected_neutrons_smoothed'], N0=550, bulk_density=1.3, Wlat=lattice_water, Wsoc=0.01)  # Drop VWC NaN values before interpolating values df = df.dropna(subset = ['VWC'])  # Interpolate variable using IDW (https://en.wikipedia.org/wiki/Inverse_distance_weighting) X_pred, Y_pred, Z_pred = crnpy.interpolate_2d(df['x'],                                         df['y'],                                         df['VWC'],                                         dx=250, dy=250, method='idw')  <p>A gridded map of the Volumetric Water Content (VWC) is created using the interpolated x, y, and VWC values.</p> In\u00a0[12]: Copied! <pre># Show interpolated grid\ncmap = 'RdYlBu'\n\nplt.figure(figsize=(6,6))\nplt.title('Gridded map')\nplt.pcolormesh(X_pred, Y_pred, Z_pred, cmap=cmap)\nplt.colorbar(label=r\"Volumetric Water Content $(cm^3 \\cdot cm^{-3})$\", location='right')\nplt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w')\nplt.ticklabel_format(scilimits=(-5,5))\nplt.xlabel('Easting', size=14)\nplt.ylabel('Northing', size=14)\nplt.show()\n</pre> # Show interpolated grid cmap = 'RdYlBu'  plt.figure(figsize=(6,6)) plt.title('Gridded map') plt.pcolormesh(X_pred, Y_pred, Z_pred, cmap=cmap) plt.colorbar(label=r\"Volumetric Water Content $(cm^3 \\cdot cm^{-3})$\", location='right') plt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w') plt.ticklabel_format(scilimits=(-5,5)) plt.xlabel('Easting', size=14) plt.ylabel('Northing', size=14) plt.show()  <p>Finally, a contour map of the VWC is created and displayed.</p> In\u00a0[13]: Copied! <pre># Show contour map\ncmap = 'RdYlBu'\n\nplt.figure(figsize=(7,6))\nplt.title('Contours')\nplt.contourf(X_pred, Y_pred, Z_pred, cmap=cmap)\nplt.ticklabel_format(scilimits=(-5,5))\nplt.colorbar(label=r\"Volumetric Water Content $(cm^3 \\cdot cm^{-3})$\", location='right')\nplt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w')\nplt.show()\n</pre> # Show contour map cmap = 'RdYlBu'  plt.figure(figsize=(7,6)) plt.title('Contours') plt.contourf(X_pred, Y_pred, Z_pred, cmap=cmap) plt.ticklabel_format(scilimits=(-5,5)) plt.colorbar(label=r\"Volumetric Water Content $(cm^3 \\cdot cm^{-3})$\", location='right') plt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w') plt.show()"},{"location":"examples/rover/Hydroinnova_rover_example/#processing-and-analyzing-data-from-a-roving-detector","title":"Processing and analyzing data from a roving detector\u00b6","text":"<p>This tutorial demonstrates how to process and analyze data from a rover using the Cosmic Ray Neutron Python (CRNPy) library. The steps include loading the data, converting geographical coordinates to Cartesian coordinates, normalizing neutron counts, correcting for atmospheric effects, and visualizing the results.</p> <p>First import the required packages.</p>"},{"location":"examples/rover/Hydroinnova_rover_example/#neutron-count-correction","title":"Neutron count correction\u00b6","text":""},{"location":"examples/rover/Hydroinnova_rover_example/#incommng-neutron-flux","title":"Incommng neutron flux\u00b6","text":"<p>Find stations with a cutoff rigidity similar to the estimated value based on the latitude and longitude, ensuring that the reference station is under a similar earth electromagnetic field. Note that the station is hardcoded in the second line as <code>station=\"NEWK\"</code>. The user is required to manually define this after considering the potential options suggested. See <code>get_incoming_neutron_flux()</code>, <code>find_neutron_monitor()</code> and <code>correction_incoming_flux()</code>.</p>"},{"location":"examples/rover/Hydroinnova_rover_example/#atmospheric-correction","title":"Atmospheric correction\u00b6","text":"<p>NaN values in the atmospheric data are filled. The neutron counts are then corrected for atmospheric variables. See <code>correction_humidity()</code> and <code>correction_pressure()</code></p>"},{"location":"examples/stationary/example_RDT_station/","title":"Processing and analyzing data from a stationary detector","text":"In\u00a0[1]: Copied! <pre># Import required libraries\nimport crnpy\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> # Import required libraries import crnpy  import pandas as pd import numpy as np import matplotlib.pyplot as plt  In\u00a0[2]: Copied! <pre># Load observations from a stationary detector\nfilepath = \"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/stationary/rdt.csv\"\n\n# Read the DataFrame\ndf = pd.read_csv(filepath, names=['timestamp','barometric_pressure_Avg','relative_humidity_Avg', 'air_temperature_Avg','DP','BattVolt','counts_1_Tot','counts_2_Tot','counts_3_Tot'])\n\n# Parse timestamps\ndf['timestamp'] = pd.to_datetime(df['timestamp'])\n\n# Display a few rows of the dataset\ndf.head(3)\n</pre> # Load observations from a stationary detector filepath = \"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/stationary/rdt.csv\"  # Read the DataFrame df = pd.read_csv(filepath, names=['timestamp','barometric_pressure_Avg','relative_humidity_Avg', 'air_temperature_Avg','DP','BattVolt','counts_1_Tot','counts_2_Tot','counts_3_Tot'])  # Parse timestamps df['timestamp'] = pd.to_datetime(df['timestamp'])  # Display a few rows of the dataset df.head(3)  Out[2]: timestamp barometric_pressure_Avg relative_humidity_Avg air_temperature_Avg DP BattVolt counts_1_Tot counts_2_Tot counts_3_Tot 0 2020-04-10 09:47:00 983.8 29.0 9.6 -7.4 14.4 848 716.0 742 1 2020-04-10 10:47:00 982.3 25.0 10.9 -7.9 14.3 436 7200.0 796 2 2020-04-10 11:17:00 980.8 25.0 11.5 -7.4 13.7 389 396.0 354 In\u00a0[3]: Copied! <pre># Remove rows with incomplete intervals\ndf = crnpy.remove_incomplete_intervals(df, timestamp_col='timestamp', integration_time=3600, remove_first=True)\n\n# Fill missing timestamps to create a conplete record\ndf = crnpy.fill_missing_timestamps(df, timestamp_col='timestamp', freq='H', round_timestamp=True)\n</pre> # Remove rows with incomplete intervals df = crnpy.remove_incomplete_intervals(df, timestamp_col='timestamp', integration_time=3600, remove_first=True)  # Fill missing timestamps to create a conplete record df = crnpy.fill_missing_timestamps(df, timestamp_col='timestamp', freq='H', round_timestamp=True)  <pre>Removed a total of 48 rows.\nAdded a total of 60 missing timestamps.\n</pre> <p>Utilize the <code>total_raw_counts()</code> function to calculate the total counts across all detectors. After calculating the total counts, identify outliers using the <code>is_outlier()</code> function.</p> In\u00a0[4]: Copied! <pre># Flag and fill outliers\ncols_counts = ['counts_1_Tot','counts_2_Tot','counts_3_Tot']\nfor col in cols_counts:\n    \n    # Find outliers\n    idx_outliers = crnpy.is_outlier(df[col], method='scaled_mad', min_val=500, max_val=2000)\n    df.loc[idx_outliers,col] = np.nan\n    \n    # Fill missing values with linear interpolation and round to nearest integer\n    df[col] = df[col].interpolate(method='linear', limit=3, limit_direction='both').round()\n</pre> # Flag and fill outliers cols_counts = ['counts_1_Tot','counts_2_Tot','counts_3_Tot'] for col in cols_counts:          # Find outliers     idx_outliers = crnpy.is_outlier(df[col], method='scaled_mad', min_val=500, max_val=2000)     df.loc[idx_outliers,col] = np.nan          # Fill missing values with linear interpolation and round to nearest integer     df[col] = df[col].interpolate(method='linear', limit=3, limit_direction='both').round()  In\u00a0[5]: Copied! <pre># Compute total cunts\ndf['total_raw_counts'] = crnpy.total_raw_counts(df[cols_counts], nan_strategy='average')\n</pre> # Compute total cunts df['total_raw_counts'] = crnpy.total_raw_counts(df[cols_counts], nan_strategy='average')  In\u00a0[6]: Copied! <pre># Plot total counts\n# Create a new figure and plot the data\nfig, ax = plt.subplots(figsize=(10, 3))  # Set the figure size\nax.plot(df['timestamp'], df['total_raw_counts'], label='Raw Counts', color='black', linewidth=.8)\n# Set the labels for the x-axis and y-axis\nax.set_ylabel(\"Total Raw Counts\", fontsize=14)\n\n# Set the title of the plot\nax.set_title('Total Raw Counts Over Time')\n\n# Adjust size of axes labels\nax.tick_params(axis='both', which='major', labelsize=14)\n\n# Show the plot\nplt.show()\n</pre> # Plot total counts # Create a new figure and plot the data fig, ax = plt.subplots(figsize=(10, 3))  # Set the figure size ax.plot(df['timestamp'], df['total_raw_counts'], label='Raw Counts', color='black', linewidth=.8) # Set the labels for the x-axis and y-axis ax.set_ylabel(\"Total Raw Counts\", fontsize=14)  # Set the title of the plot ax.set_title('Total Raw Counts Over Time')  # Adjust size of axes labels ax.tick_params(axis='both', which='major', labelsize=14)  # Show the plot plt.show()  In\u00a0[7]: Copied! <pre># Define study start and end dates\nstart_date = df.iloc[0]['timestamp']\nend_date = df.iloc[-1]['timestamp']\n\n# Define geographic coordiantes\nlat = 39.110596\nlon = -96.613050\n\n# Find stations with cutoff rigidity similar to estimated by lat,lon\ncrnpy.find_neutron_monitor(crnpy.cutoff_rigidity(lat, lon), start_date=start_date, end_date=end_date, verbose=False)\n</pre> # Define study start and end dates start_date = df.iloc[0]['timestamp'] end_date = df.iloc[-1]['timestamp']  # Define geographic coordiantes lat = 39.110596 lon = -96.613050  # Find stations with cutoff rigidity similar to estimated by lat,lon crnpy.find_neutron_monitor(crnpy.cutoff_rigidity(lat, lon), start_date=start_date, end_date=end_date, verbose=False)  <pre>\nSelect a station with an altitude similar to that of your location. For more information go to: 'https://www.nmdb.eu/nest/help.php#helpstations\n\nYour cutoff rigidity is 2.87 GV\n     STID     NAME     R  Altitude_m  Period available\n13   DRBS  Dourbes  3.18         225              True\n40   NEWK   Newark  2.40          50              True\n28  KIEL2   KielRT  2.36          54              True\n21   IRKT  Irkustk  3.64         435              True\n</pre> Out[7]: STID NAME R Altitude_m Period available 13 DRBS Dourbes 3.18 225 True 40 NEWK Newark 2.40 50 True 28 KIEL2 KielRT 2.36 54 True 21 IRKT Irkustk 3.64 435 True In\u00a0[8]: Copied! <pre># Download incoming neutron flux data from the Neutron Monitor Database (NMDB).\n# Use utc_offset for Central Standard Time.\nnmdb = crnpy.get_incoming_neutron_flux(start_date, end_date, station=\"IRKT\", utc_offset=-6)\n</pre> # Download incoming neutron flux data from the Neutron Monitor Database (NMDB). # Use utc_offset for Central Standard Time. nmdb = crnpy.get_incoming_neutron_flux(start_date, end_date, station=\"IRKT\", utc_offset=-6)  In\u00a0[9]: Copied! <pre># Interpolate incoming neutron flux to match the timestamps in our station data\ndf['incoming_flux'] = crnpy.interpolate_incoming_flux(nmdb['timestamp'], nmdb['counts'], df['timestamp'])\n</pre> # Interpolate incoming neutron flux to match the timestamps in our station data df['incoming_flux'] = crnpy.interpolate_incoming_flux(nmdb['timestamp'], nmdb['counts'], df['timestamp'])  In\u00a0[10]: Copied! <pre># Compute correction factor for incoming neutron flux\ndf['fi'] = crnpy.correction_incoming_flux(incoming_neutrons=df['incoming_flux'],\n                                          incoming_Ref=df['incoming_flux'].iloc[0])\n</pre> # Compute correction factor for incoming neutron flux df['fi'] = crnpy.correction_incoming_flux(incoming_neutrons=df['incoming_flux'],                                           incoming_Ref=df['incoming_flux'].iloc[0])  In\u00a0[11]: Copied! <pre># Fill NaN values in atmospheric data and neutron counts\ndf[['barometric_pressure_Avg','relative_humidity_Avg', 'air_temperature_Avg']] = df[['barometric_pressure_Avg','relative_humidity_Avg', 'air_temperature_Avg']].interpolate(method='pchip', limit=24, limit_direction='both')\n\n# Compute the pressure correction factor \ndf['fp'] = crnpy.correction_pressure(pressure=df['barometric_pressure_Avg'], Pref=df['barometric_pressure_Avg'].mean(), L=130)\n\n# Calculate the absolute humidity (g cm^-3) and the vapor pressure correction factor\ndf['abs_humidity'] = crnpy.abs_humidity(df['relative_humidity_Avg'], df['air_temperature_Avg'])\ndf['fw'] = crnpy.correction_humidity(abs_humidity=df['abs_humidity'], Aref=0)\n</pre> # Fill NaN values in atmospheric data and neutron counts df[['barometric_pressure_Avg','relative_humidity_Avg', 'air_temperature_Avg']] = df[['barometric_pressure_Avg','relative_humidity_Avg', 'air_temperature_Avg']].interpolate(method='pchip', limit=24, limit_direction='both')  # Compute the pressure correction factor  df['fp'] = crnpy.correction_pressure(pressure=df['barometric_pressure_Avg'], Pref=df['barometric_pressure_Avg'].mean(), L=130)  # Calculate the absolute humidity (g cm^-3) and the vapor pressure correction factor df['abs_humidity'] = crnpy.abs_humidity(df['relative_humidity_Avg'], df['air_temperature_Avg']) df['fw'] = crnpy.correction_humidity(abs_humidity=df['abs_humidity'], Aref=0)  In\u00a0[12]: Copied! <pre># Plot all the correction factors\nfig, ax = plt.subplots(figsize=(10, 3))  # Set the figure size\nax.plot(df['timestamp'], df['fp'], label='Pressure',color='tomato', linewidth=1)\nax.plot(df['timestamp'], df['fw'], label='Humidity', color='navy', linewidth=1)\nax.plot(df['timestamp'], df['fi'], label='Incoming Flux', color='olive', linewidth=1)\nax.set_ylabel('Correction Factor')\nax.legend()\nax.set_title('Correction Factors for Pressure, Humidity, and Incoming Flux')\n</pre> # Plot all the correction factors fig, ax = plt.subplots(figsize=(10, 3))  # Set the figure size ax.plot(df['timestamp'], df['fp'], label='Pressure',color='tomato', linewidth=1) ax.plot(df['timestamp'], df['fw'], label='Humidity', color='navy', linewidth=1) ax.plot(df['timestamp'], df['fi'], label='Incoming Flux', color='olive', linewidth=1) ax.set_ylabel('Correction Factor') ax.legend() ax.set_title('Correction Factors for Pressure, Humidity, and Incoming Flux')  Out[12]: <pre>Text(0.5, 1.0, 'Correction Factors for Pressure, Humidity, and Incoming Flux')</pre> In\u00a0[13]: Copied! <pre># Apply correction factors\ndf['total_corrected_neutrons'] = df['total_raw_counts'] * df['fw'] / (df['fp'] * df['fi'])\n</pre> # Apply correction factors df['total_corrected_neutrons'] = df['total_raw_counts'] * df['fw'] / (df['fp'] * df['fi'])  In\u00a0[14]: Copied! <pre>fig, ax = plt.subplots(figsize=(10, 3))  # Set the figure size\n\n# Subplot 1: Raw and Corrected Counts\nax.plot(df['timestamp'], df['total_raw_counts'], label='Raw Counts', color='black', linestyle='dashed', linewidth=.8)\nax.plot(df['timestamp'], df['total_corrected_neutrons'], label='Corrected Counts', color='teal', linewidth=.8)\nax.set_ylabel('Counts')\nax.legend()\nax.set_title('Raw and Corrected Counts')\n</pre> fig, ax = plt.subplots(figsize=(10, 3))  # Set the figure size  # Subplot 1: Raw and Corrected Counts ax.plot(df['timestamp'], df['total_raw_counts'], label='Raw Counts', color='black', linestyle='dashed', linewidth=.8) ax.plot(df['timestamp'], df['total_corrected_neutrons'], label='Corrected Counts', color='teal', linewidth=.8) ax.set_ylabel('Counts') ax.legend() ax.set_title('Raw and Corrected Counts')  Out[14]: <pre>Text(0.5, 1.0, 'Raw and Corrected Counts')</pre> <p>Convert the smoothed neutron counts to Volumetric Water Content (VWC) using the <code>counts_to_vwc()</code>. The function considers the smoothed neutron counts, $N_0$ specific parameter, soil bulk density, weight percent of latent water (Wlat), and weight percent of soil organic carbon (Wsoc). After conversion, plot the VWC against the timestamp for visual analysis. <code>smooth_1d()</code> is pplied for smothing the data using a Savitzky-Golay filter.</p> In\u00a0[15]: Copied! <pre># Device N0 parameter\nN0_rdt = 3767 # Patrignani, A., Ochsner, T. E., Montag, B., &amp; Bellinger, S. (2021). A novel lithium foil cosmic-ray neutron detector for measuring field-scale soil moisture. Frontiers in Water, 3, 673185.\n\n# Estimate lattice water (%) based on texture\nlattice_water = crnpy.lattice_water(clay_content=0.35)\n\ndf['VWC'] = crnpy.counts_to_vwc(df['total_corrected_neutrons'], N0=N0_rdt, bulk_density=1.33, Wlat=lattice_water, Wsoc=0.01)\n\n# Drop any NaN beofre smoothing\ndf = df.dropna(subset=['VWC']).copy().reset_index()\n\n# Filter using the Savitzky-Golay filter, drop NaN values and timestamps\ndf['VWC'] = crnpy.smooth_1d(df['VWC'], window=11, order=3, method=\"savitzky_golay\")\n</pre> # Device N0 parameter N0_rdt = 3767 # Patrignani, A., Ochsner, T. E., Montag, B., &amp; Bellinger, S. (2021). A novel lithium foil cosmic-ray neutron detector for measuring field-scale soil moisture. Frontiers in Water, 3, 673185.  # Estimate lattice water (%) based on texture lattice_water = crnpy.lattice_water(clay_content=0.35)  df['VWC'] = crnpy.counts_to_vwc(df['total_corrected_neutrons'], N0=N0_rdt, bulk_density=1.33, Wlat=lattice_water, Wsoc=0.01)  # Drop any NaN beofre smoothing df = df.dropna(subset=['VWC']).copy().reset_index()  # Filter using the Savitzky-Golay filter, drop NaN values and timestamps df['VWC'] = crnpy.smooth_1d(df['VWC'], window=11, order=3, method=\"savitzky_golay\")  In\u00a0[16]: Copied! <pre># Plot the obtained time series of volumetric water content\n# Create a new figure and plot the data\nfig, ax = plt.subplots(figsize=(10, 4))  # Set the figure size\nax.plot(df['timestamp'], df['VWC'], color='teal', linewidth=1.0)\n\n# Set the labels for the x-axis and y-axis\nax.set_xlabel(\"Date\", fontsize=14)\nax.set_ylabel(\"Volumetric Water Content\", fontsize=14)\n\n# Set the title of the plot\nax.set_title('Soil Moisture')\n\n# Show the plot\nplt.show()\n</pre> # Plot the obtained time series of volumetric water content # Create a new figure and plot the data fig, ax = plt.subplots(figsize=(10, 4))  # Set the figure size ax.plot(df['timestamp'], df['VWC'], color='teal', linewidth=1.0)  # Set the labels for the x-axis and y-axis ax.set_xlabel(\"Date\", fontsize=14) ax.set_ylabel(\"Volumetric Water Content\", fontsize=14)  # Set the title of the plot ax.set_title('Soil Moisture')  # Show the plot plt.show()  In\u00a0[17]: Copied! <pre># Estimate sensing depth\ndf['sensing_depth'] = crnpy.sensing_depth(df['VWC'], df['barometric_pressure_Avg'], df['barometric_pressure_Avg'].mean(), bulk_density=1.33, Wlat=lattice_water, method = \"Franz_2012\")\nprint(f\"Average sensing depth: {np.round(df['sensing_depth'].mean(),2)} cm\")\n</pre> # Estimate sensing depth df['sensing_depth'] = crnpy.sensing_depth(df['VWC'], df['barometric_pressure_Avg'], df['barometric_pressure_Avg'].mean(), bulk_density=1.33, Wlat=lattice_water, method = \"Franz_2012\") print(f\"Average sensing depth: {np.round(df['sensing_depth'].mean(),2)} cm\")  <pre>Average sensing depth: 15.36 cm\n</pre> In\u00a0[18]: Copied! <pre># Compute the storage using the exponential filter\nsurface = df['VWC']\nsubsurface = crnpy.exp_filter(df['VWC'])\n\nz_surface = 150 # Average depth in mm obtained from previous cell using crnpy.sensing_depth()\nz_subsurface = 350 # Arbitrary subsurface depth in mm\ndf['storage'] = np.sum([surface*z_surface, subsurface*z_subsurface], axis=0)\n</pre> # Compute the storage using the exponential filter surface = df['VWC'] subsurface = crnpy.exp_filter(df['VWC'])  z_surface = 150 # Average depth in mm obtained from previous cell using crnpy.sensing_depth() z_subsurface = 350 # Arbitrary subsurface depth in mm df['storage'] = np.sum([surface*z_surface, subsurface*z_subsurface], axis=0)  In\u00a0[19]: Copied! <pre># Plot the obtained time series of soil water storage\n# Create a new figure and plot the data\nfig, ax = plt.subplots(figsize=(10, 4))  # Set the figure size\nax.plot(df['timestamp'], df['storage'], color='teal', linewidth=1.0)\n\n# Set the labels for the x-axis and y-axis\nax.set_xlabel(\"Date\", fontsize=14)\nax.set_ylabel(\"Storage\", fontsize=14)\n\n# Set the title of the plot\nax.set_title('Soil Water Storage')\n\n# Show the plot\nplt.show()\n</pre> # Plot the obtained time series of soil water storage # Create a new figure and plot the data fig, ax = plt.subplots(figsize=(10, 4))  # Set the figure size ax.plot(df['timestamp'], df['storage'], color='teal', linewidth=1.0)  # Set the labels for the x-axis and y-axis ax.set_xlabel(\"Date\", fontsize=14) ax.set_ylabel(\"Storage\", fontsize=14)  # Set the title of the plot ax.set_title('Soil Water Storage')  # Show the plot plt.show()  In\u00a0[20]: Copied! <pre># Estimate the uncertainty of the volumetric water content\ndf['sigma_VWC'] = crnpy.uncertainty_vwc(df['total_raw_counts'], N0=N0_rdt, bulk_density=1.33, fp=df['fp'], fi=df['fi'], fw=df['fw'])\n\n# Plot the VWC with uncertainty as a shaded area\nfig, ax = plt.subplots(figsize=(10, 4))  # Set the figure size\nax.plot(df['timestamp'], df['VWC'], color='black', linewidth=1.0)\nax.fill_between(df['timestamp'], df['VWC']-df['sigma_VWC'], df['VWC']+df['sigma_VWC'], color='teal', alpha=0.5)\nax.set_title('Volumentric Water Content with Uncertainty')\nax.set_xlabel(\"Date\")\nax.set_ylabel(\"Volumetric Water Content\")\nplt.show()\n</pre> # Estimate the uncertainty of the volumetric water content df['sigma_VWC'] = crnpy.uncertainty_vwc(df['total_raw_counts'], N0=N0_rdt, bulk_density=1.33, fp=df['fp'], fi=df['fi'], fw=df['fw'])  # Plot the VWC with uncertainty as a shaded area fig, ax = plt.subplots(figsize=(10, 4))  # Set the figure size ax.plot(df['timestamp'], df['VWC'], color='black', linewidth=1.0) ax.fill_between(df['timestamp'], df['VWC']-df['sigma_VWC'], df['VWC']+df['sigma_VWC'], color='teal', alpha=0.5) ax.set_title('Volumentric Water Content with Uncertainty') ax.set_xlabel(\"Date\") ax.set_ylabel(\"Volumetric Water Content\") plt.show()"},{"location":"examples/stationary/example_RDT_station/#processing-and-analyzing-data-from-a-stationary-detector","title":"Processing and analyzing data from a stationary detector\u00b6","text":"<p>This tutorial demonstrates how to process and analyze neutron counts of epithermal neutrons recorded with a stationary cosmic-ray neutron probe consisting of three lithium-foil detectors manufactured by Radiation Detection Technologies, Inc (RDT). The tutorial covers all the steps from reading the file with raw data obtained from the probe in the field, outlier removal, atmospheric corrections, and conversion of corrected neutron counts into volumetric soil water content.</p> <p>The tutorial assumes that you are working within the <code>Anaconda</code> environment, which has all the necessary modules. Also, make sure that the <code>CRNPy</code> library is installed in your machine.</p> <p>The raw dataset to follow this example can be obtained at the .csv file.</p> <p>This device was installed in the vicinity of the KONA site of the National Ecological Observatory Network within the Konza Prairie Biological station (<code>39.110596, -96.613050, 320 meters a.s.l.</code>)</p>"},{"location":"examples/stationary/example_RDT_station/#neutron-count-correction","title":"Neutron count correction\u00b6","text":""},{"location":"examples/stationary/example_RDT_station/#incomming-neutron-flux","title":"Incomming neutron flux\u00b6","text":"<p>Find similar neutron monitors based on altitude and cutoff rigidity, which is estimated based on the geographic location using latitude and longitude values. See <code>get_incoming_neutron_flux()</code>, <code>find_neutron_monitor()</code> and <code>correction_incoming_flux()</code>.</p> <p>In this particular example we selected the <code>\"IRKT\"</code> monitor since it has a similar cuoff rigidity and altitude as our site. The reference neutron monitor will likely be different for your location. Note that the function only reports neutron monitors based on cutoff rigidity and leaves to the user the selection of a reference neutron monitor based on the altitude of the location.</p>"},{"location":"examples/stationary/example_RDT_station/#atmospheric-correction","title":"Atmospheric correction\u00b6","text":"<p>This section is about correcting the atmospheric variables. First, fill the missing values in the atmospheric data, then correct the count for atmospheric variables using <code>correction_humidity()</code> and <code>correction_pressure()</code>.</p>"},{"location":"examples/stationary/example_RDT_station/#sensing-depth-and-soil-water-storage","title":"Sensing depth and soil water storage\u00b6","text":"<p>Estimate the <code>sensing_depth()</code>  at which 86 % of the neutrons probes the soil profile, and estiamte the soil water <code>storage()</code> of the top 50 cm using and exponential filter.</p>"},{"location":"examples/stationary/example_RDT_station/#uncertainty-estimation","title":"Uncertainty estimation\u00b6","text":"<p>Estimate the uncertainty of the volumetric water content using the <code>uncertainty_vwc()</code> function. Optionally see <code>uncertainty_counts()</code> for estimating the uncertainty of the neutron counts.</p>"}]}