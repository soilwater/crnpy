{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cosmic-Ray Neutron Python (CRNPy) Library","text":""},{"location":"#overview","title":"Overview","text":"<p>Welcome to the homepage of the CRNPy (Cosmic-Ray Neutron Python) library, an open-source Python library designed for the processing and conversion of raw neutron counts from Cosmic-Ray Neutron Probes (CRNP) into accurate field-level soil moisture data.</p> <p>This library has been developed with the intent of providing a comprehensive yet easy-to-use workflow for processing raw data from a variety of CRNP, encompassing multiple manufacturers and models.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Versatility: CRNPy can handle data from various CRNP manufacturers and models. It has been successfully tested on both roving and stationary CRNP.</li> <li>Modularity: The library is designed to be modular, allowing users to easily customize the processing workflow to their needs.</li> <li>Instrument agnostic: It can be used with any CRNP, allowing users to process data from multiple instruments with their own workflow.</li> <li>Correction Routines: The correction functions of the library have been effectively used to represent field and watershed scale soil moisture conditions.</li> </ul> <p> Overview of the proposed CRNPy processing workflow. Final user can choose to use the entire workflow, part of it, or build functions on top of it depending on their needs. Dashed lines indicate optional steps.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the CRNPy library, you can use Python's package manager, pip. Simply open your command line or terminal and type:</p> <p><code>pip install crnpy</code></p>"},{"location":"#authors","title":"Authors","text":"<p>The CRNPy library was developed by:</p> <ul> <li>Joaquin Peraza</li> <li>Andres Patrignani</li> </ul> <p>in the Soil Water Processes Lab at Kansas State University. The team's passion for making soil moisture data more accessible and easier to process culminated in this powerful tool.</p> <p>The Soil Water Processes Lab at Kansas State University is a leading research group focused on understanding and modeling soil water processes. The lab combines a range of experimental and computational approaches to tackle some of the most pressing issues in soil and water research. The development of the CRNPy library is a testament to the lab's commitment to pushing the boundaries of soil science through the innovative use of technology. The authors would like to acknowledge the contributions of the wider scientific community in testing and providing feedback on the library, which has been instrumental in its ongoing development.</p>"},{"location":"correction_routines/","title":"Correction routines","text":"<p> Overview of the proposed CRNPy processing workflow. Final user can choose to use the entire workflow, part of it, or build functions on top of it depending on their needs. Dashed lines indicate optional steps.</p>"},{"location":"correction_routines/#incoming-neutron-flux","title":"Incoming neutron flux","text":"<p>The CRNPy package includes a complete set of methods for correcting the raw observed neutron counts for natural variation in the incoming neutron flux, including a set of tools for searching and downloading data from a reference neutron monitoring station from the NMDB database (www.nmdb.eu) by proposing the most similar stations after analyzing the cut-off rigidity of the reference station and the estimated cut-off rigidity value for the studied location as a form of finding stations under a similar earth electromagnetic field (Klein et al., 2009; Shea &amp; Smart, 2019; Smart &amp; Shea, 2001).</p> Incoming neutron flux correction factor $fi = \\frac{I_{m}}{I_{0}}$ $ fi $: Incoming neutron flux correction factor $ I_{m} $: Measured incoming neutron flux $ I_{0} $: Reference incoming neutron flux at a given time. <p>Implementation</p> <p>See  crnpy.crnpy.cutoff_rigidity, crnpy.crnpy.find_neutron_detectors, crnpy.crnpy.get_incoming_neutron_flux, crnpy.crnpy.interpolate_incoming_flux and crnpy.crnpy.atm_correction documentation for the implementation details.</p>"},{"location":"correction_routines/#atmospheric-corrections","title":"Atmospheric corrections","text":"<p>The package also provides functions for correcting raw neutron counts for atmospheric pressure, humidity, and temperature variations, (Andreasen et al., 2017; Rosolem et al., 2013; Zreda et al., 2012).</p> Pressure correction Atmospheric water correction $fp = exp(\\frac{P_{0} - P}{L})$ $fw = 1 + 0.0054*(A - Aref)$ $fp$: Atmospheric pressure correction factor $fw$: Atmospheric water correction factor $P_{0}$: Reference atmospheric pressure (for e.g. long-term average) $A$: Atmospheric water content $P$: Measured atmospheric pressure $Aref$: Reference atmospheric water content $L$: Mass attenuation factor for high-energy neutrons in air <p>Implementation</p> <p>See crnpy.crnpy.atm_correction documentation for the implementation details.</p>"},{"location":"correction_routines/#biomass-correction","title":"Biomass correction","text":"<p>The library provides a function for correcting neutron counts for the effects of above-ground biomass by combining an approach for estimating biomass water equivalent (BWE) from in-situ biomass samples (Wahbi et al., 2018) and the BWE correction factor described in Baatz et al. (2015).</p> Biomass correction $fb = 1 - bwe*r2_N0$ $fb$: Biomass correction factor $bwe$: Biomass water equivalent $r2_N0$: Ratio of the neutron counts reduction ($counts kg^-1$) to the neutron calibration constant (N0) <p>Implementation</p> <p>See crnpy.crnpy.bwe_correction and crnpy.crnpy.biomass_to_bwe documentation for the implementation details.</p>"},{"location":"correction_routines/#road-correction","title":"Road correction","text":"<p>Due to the known high sensitivity closer to the detector, use cases like rover surveys could require the use of a correction factor accounting for the differences between the field soil water content and the road water content, crnPy implements the methodology proposed by Schr\u00f6n et al. (2018).</p> Road correction $fr = 1 + F1F2F3$ $fr$: Road correction factor $F1$: Road geometry term $F2$: Road moisture term $F3$: Road distance term <p>Implementation</p> <p>See crnpy.crnpy.road_correction documentation for the implementation details.</p>"},{"location":"correction_routines/#additional-corrections","title":"Additional corrections","text":"<p>Extra routines in this module account for other hydrogen environmental pools, lattice water, and total soil carbon that could affect cosmic-ray neutrons attenuation. A function to estimate the soil lattice water content based on texture and soil carbon was developed by analyzing collected soil samples across the state of Kansas combined with data published by Dong &amp; Ochsner (2018)</p> <p>Implementation</p> <p>See crnpy.crnpy.estimate_lattice_water and crnpy.crnpy.counts_to_vwc documentation for the implementation details.</p> <p>References</p> <p>Klein, K.-L., Steigies, C., &amp; Nmdb Team. (2009). WWW.NMDB.EU: The real-time Neutron Monitor database. EGU General Assembly Conference Abstracts, 5633.</p> <p>Shea, M., &amp; Smart, D. (2019). Re-examination of the first five ground-level events. International Cosmic Ray Conference (ICRC2019), 36, 1149.</p> <p>Smart, D., &amp; Shea, M. (2001). Geomagnetic cutoff rigidity computer program: Theory, software description and example.</p> <p>Andreasen, M., Jensen, K. H., Desilets, D., Franz, T. E., Zreda, M., Bogena, H. R., &amp; Looms, M. C. (2017). Status and perspectives on the cosmic-ray neutron method for soil moisture estimation and other environmental science applications. Vadose Zone Journal, 16(8), 1\u201311.</p> <p>Rosolem, R., Shuttleworth, W. J., Zreda, M., Franz, T. E., Zeng, X., &amp; Kurc, S. A. (2013). The effect of atmospheric water vapor on neutron count in the cosmic-ray soil moisture observing system. Journal of Hydrometeorology, 14(5), 1659\u20131671.</p> <p>Zreda, M., Desilets, D., Ferr\u00e9, T., &amp; Scott, R. L. (2008). Measuring soil moisture content non-invasively at intermediate spatial scale using cosmic-ray neutrons. Geophysical Research Letters, 35(21).</p> <p>Dong, J., &amp; Ochsner, T. E. (2018). Soil texture often exerts a stronger influence than precipitation on mesoscale soil moisture patterns. Water Resources Research, 54(3), 2199\u20132211.</p> <p>Wahbi, A., Heng, L., Dercon, G., Wahbi, A., &amp; Avery, W. (2018). In situ destructive sampling. Cosmic Ray Neutron Sensing: Estimation of Agricultural Crop Biomass Water Equivalent, 5\u20139.</p> <p>Baatz, R., Bogena, H., Hendricks Franssen, H.-J., Huisman, J., Montzka, C., &amp; Vereecken, H. (2015). An empirical vegetation correction for soil water content quantification using cosmic ray probes. Water Resources Research, 51(4), 2030\u20132046.</p> <p>Schr\u00f6n, M., Rosolem, R., K\u00f6hli, M., Piussi, L., Schr\u00f6ter, I., Iwema, J., K\u00f6gler, S., Oswald, S. E., Wollschl\u00e4ger, U., Samaniego, L., &amp; others. (2018). Cosmic-ray neutron rover surveys of field soil moisture and the influence of roads. Water Resources Research, 54(9), 6441\u20136459.</p> <p>Zreda, M., Shuttleworth, W. J., Zeng, X., Zweck, C., Desilets, D., Franz, T., and Rosolem, R.: COSMOS: the COsmic-ray Soil Moisture Observing System, Hydrol. Earth Syst. Sci., 16, 4079\u20134099, https://doi.org/10.5194/hess-16-4079-2012, 2012.</p>"},{"location":"reference/","title":"Reference","text":"<p><code>crnpy</code> is a Python package for processing cosmic ray neutron data.</p> <p>Created by Joaquin Peraza and Andres Patrignani.</p>"},{"location":"reference/#crnpy.crnpy.atm_correction","title":"<code>atm_correction(raw_counts, pressure, humidity, temp, Pref, Aref, L, incoming_neutrons=None, incoming_Ref=None)</code>","text":"<p>Correct neutron counts for atmospheric factors and incoming neutron flux.</p> <p>This function corrects neutron counts for atmospheric pressure, and absolute humidity using the method described in Zreda et al. (2012) and Anderson et al. (2017). The correction is performed using the following equation:</p> <p>$$ C_{corrected} = \\frac{C_{raw} \\cdot f_w}{f_p \\cdot f_i} $$</p> <ul> <li>fp: pressure correction factor</li> <li>fw: abosolute humidity correction factor</li> <li>fi: incoming neutron flux correction factor</li> </ul> <p>Parameters:</p> Name Type Description Default <code>raw_counts</code> <code>list or array</code> <p>Neutron counts to correct.</p> required <code>pressure</code> <code>list or array</code> <p>Atmospheric pressure readings.</p> required <code>humidity</code> <code>list or array</code> <p>Atmospheric humidity readings in %.</p> required <code>temp</code> <code>list or array</code> <p>Atmospheric temperature readings in Celsius.</p> required <code>Pref</code> <code>float</code> <p>Reference atmospheric pressure in millibars (mbar).</p> required <code>Aref</code> <code>float</code> <p>Reference absolute humidity.</p> required <code>L</code> <code>float</code> <p>Atmospheric attenuation coefficient.</p> required <code>incoming_neutrons</code> <code>list or array</code> <p>Incoming neutron flux. Default is None.</p> <code>None</code> <code>incoming_Ref</code> <code>float</code> <p>Reference incoming neutron flux. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>numpy.array</code> <p>Total neutron counts corrected by atmospheric conditions.</p> References <p>Zreda, M., Shuttleworth, W. J., Zeng, X., Zweck, C., Desilets, D., Franz, T., et al. (2012). COSMOS: the cosmic-ray soil moisture observing system. Hydrol. Earth Syst. Sci. 16, 4079\u20134099. doi: 10.5194/hess-16-4079-2012</p> <p>Andreasen, M., Jensen, K.H., Desilets, D., Franz, T.E., Zreda, M., Bogena, H.R. and Looms, M.C., 2017. Status and perspectives on the cosmic\u2010ray neutron method for soil moisture estimation and other environmental science applications. Vadose zone journal, 16(8), pp.1-11. doi.org/10.2136/vzj2017.04.0086</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def atm_correction(raw_counts, pressure, humidity, temp, Pref, Aref, L, incoming_neutrons=None, incoming_Ref=None):\nr\"\"\"Correct neutron counts for atmospheric factors and incoming neutron flux.\n\n    This function corrects neutron counts for atmospheric pressure, and absolute humidity using the method described in Zreda et al. (2012) and Anderson et al. (2017). The correction is performed using the following equation:\n\n    $$\n    C_{corrected} = \\frac{C_{raw} \\cdot f_w}{f_p \\cdot f_i}\n    $$\n\n    - fp: pressure correction factor\n    - fw: abosolute humidity correction factor\n    - fi: incoming neutron flux correction factor\n\n    Args:\n        raw_counts (list or array): Neutron counts to correct.\n        pressure (list or array): Atmospheric pressure readings.\n        humidity (list or array): Atmospheric humidity readings in %.\n        temp (list or array): Atmospheric temperature readings in Celsius.\n        Pref (float): Reference atmospheric pressure in millibars (mbar).\n        Aref (float): Reference absolute humidity.\n        L (float): Atmospheric attenuation coefficient.\n        incoming_neutrons (list or array): Incoming neutron flux. Default is None.\n        incoming_Ref (float): Reference incoming neutron flux. Default is None.\n\n    Returns:\n        (numpy.array): Total neutron counts corrected by atmospheric conditions.\n\n    References:\n        Zreda, M., Shuttleworth, W. J., Zeng, X., Zweck, C., Desilets, D., Franz, T., et al. (2012).\n        COSMOS: the cosmic-ray soil moisture observing system. Hydrol. Earth Syst. Sci. 16, 4079\u20134099.\n        doi: 10.5194/hess-16-4079-2012\n\n        Andreasen, M., Jensen, K.H., Desilets, D., Franz, T.E., Zreda, M., Bogena, H.R. and Looms, M.C., 2017.\n        Status and perspectives on the cosmic\u2010ray neutron method for soil moisture estimation and other\n        environmental science applications. Vadose zone journal, 16(8), pp.1-11. doi.org/10.2136/vzj2017.04.0086\n    \"\"\"\n\n    ### Barometric pressure factor\n    fp = np.exp((Pref - pressure) / L) # Zreda et al. 2017 Eq 5.\n\n    ### Atmospheric water vapor factor\n    # Saturation vapor pressure\n    e_sat = 0.611 * np.exp(17.502 * temp / (temp + 240.97)) * 1000 # in Pascals Eq. 3.8 p.41 Environmental Biophysics (Campbell and Norman)\n\n    # Vapor pressure Pascals\n    Pw = e_sat * humidity/100\n\n    # Absolute humidity (g/m^3)\n    C = 2.16679 # g K/J;\n    A = C * Pw / (temp + 273.15)\n    fw = 1 + 0.0054*(A - Aref) # Zreda et al. 2017 Eq 6.\n\n    ### Incoming neutron flux factor\n    if incoming_neutrons is None:\n        fi = 1\n        warnings.warn(\"Ignoring incoming neutron flux correction factor (using value fi=1)\")\n    else:\n        if incoming_Ref is None and not isinstance(incoming_neutrons, type(None)):\n            incoming_Ref = incoming_neutrons[0]\n            warnings.warn('Reference incoming neutron flux not provided. Using first value of incoming neutron flux.')\n\n        fi = incoming_neutrons/incoming_Ref\n        fi.fillna(1.0, inplace=True) # Use a value of 1 for days without data\n\n    # Apply correction factors\n    return np.round((raw_counts*fw)/(fp*fi))\n</code></pre>"},{"location":"reference/#crnpy.crnpy.biomass_to_bwe","title":"<code>biomass_to_bwe(biomass_dry, biomass_fresh, fWE=0.494)</code>","text":"<p>Function to convert biomass to biomass water equivalent.</p> <p>Parameters:</p> Name Type Description Default <code>biomass_dry</code> <code>array or pd.Series or pd.DataFrame</code> <p>Above ground dry biomass in kg m-2.</p> required <code>biomass_fresh</code> <code>array or pd.Series or pd.DataFrame</code> <p>Above ground fresh biomass in kg m-2.</p> required <code>fWE</code> <code>float</code> <p>Stoichiometric ratio of H2O to organic carbon molecules in the plant (assuming this is mostly cellulose) Default is 0.494 (Wahbi &amp; Avery, 2018).</p> <code>0.494</code> <p>Returns:</p> Type Description <code>array or pd.Series or pd.DataFrame</code> <p>Biomass water equivalent in kg m-2.</p> References <p>Wahbi, A., Avery, W. (2018). In Situ Destructive Sampling. In: Cosmic Ray Neutron Sensing: Estimation of Agricultural Crop Biomass Water Equivalent. Springer, Cham. https://doi.org/10.1007/978-3-319-69539-6_2</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def biomass_to_bwe(biomass_dry, biomass_fresh, fWE=0.494):\n\"\"\"Function to convert biomass to biomass water equivalent.\n\n    Args:\n        biomass_dry (array or pd.Series or pd.DataFrame): Above ground dry biomass in kg m-2.\n        biomass_fresh (array or pd.Series or pd.DataFrame): Above ground fresh biomass in kg m-2.\n        fWE (float): Stoichiometric ratio of H2O to organic carbon molecules in the plant (assuming this is mostly cellulose)\n            Default is 0.494 (Wahbi &amp; Avery, 2018).\n\n    Returns:\n        (array or pd.Series or pd.DataFrame): Biomass water equivalent in kg m-2.\n\n    References:\n        Wahbi, A., Avery, W. (2018). In Situ Destructive Sampling. In:\n        Cosmic Ray Neutron Sensing: Estimation of Agricultural Crop Biomass Water Equivalent.\n        Springer, Cham. https://doi.org/10.1007/978-3-319-69539-6_2\n    \"\"\"\n    return (biomass_fresh - biomass_dry) + fWE * biomass_dry\n</code></pre>"},{"location":"reference/#crnpy.crnpy.bwe_correction","title":"<code>bwe_correction(counts, bwe, r2_N0=0.05)</code>","text":"<p>Function to correct for biomass effects in neutron counts. following the approach described in Baatz et al., 2015.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>array or pd.Series or pd.DataFrame</code> <p>Array of ephithermal neutron counts.</p> required <code>bwe</code> <code>float</code> <p>Biomass water equivalent kg m-2.</p> required <code>r2_N0</code> <code>float</code> <p>Ratio of the neutron counts reduction (counts kg-1) to the neutron calibration constant (N0). Default is 0.05 (Baatz et al., 2015).</p> <code>0.05</code> <p>Returns:</p> Type Description <code>array or pd.Series or pd.DataFrame</code> <p>Array of corrected neutron counts for biomass effects.</p> References <p>Baatz, R., H. R. Bogena, H.-J. Hendricks Franssen, J. A. Huisman, C. Montzka, and H. Vereecken (2015), An empiricalvegetation correction for soil water content quantification using cosmic ray probes, Water Resour. Res., 51, 2030\u20132046, doi:10.1002/ 2014WR016443.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def bwe_correction(counts, bwe, r2_N0=0.05):\n\"\"\"Function to correct for biomass effects in neutron counts.\n    following the approach described in Baatz et al., 2015.\n\n    Args:\n        counts (array or pd.Series or pd.DataFrame): Array of ephithermal neutron counts.\n        bwe (float): Biomass water equivalent kg m-2.\n        r2_N0 (float): Ratio of the neutron counts reduction (counts kg-1) to the neutron calibration constant (N0). Default is 0.05 (Baatz et al., 2015).\n\n    Returns:\n        (array or pd.Series or pd.DataFrame): Array of corrected neutron counts for biomass effects.\n\n    References:\n        Baatz, R., H. R. Bogena, H.-J. Hendricks Franssen, J. A. Huisman, C. Montzka, and H. Vereecken (2015),\n        An empiricalvegetation correction for soil water content quantification using cosmic ray probes,\n        Water Resour. Res., 51, 2030\u20132046, doi:10.1002/ 2014WR016443.\n    \"\"\"\n\n    return counts/(1 - bwe*r2_N0)\n</code></pre>"},{"location":"reference/#crnpy.crnpy.compute_total_raw_counts","title":"<code>compute_total_raw_counts(counts, nan_strategy=None)</code>","text":"<p>Compute the sum of uncorrected neutron counts for all detectors.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>pandas.DataFrame</code> <p>Dataframe containing only the columns with neutron counts.</p> required <code>nan_strategy</code> <code>str</code> <p>Strategy to use for NaN values. Options are 'interpolate', 'average', or None. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>Dataframe with the sum of uncorrected neutron counts for all detectors.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def compute_total_raw_counts(counts, nan_strategy=None):\n\"\"\"Compute the sum of uncorrected neutron counts for all detectors.\n\n    Args:\n        counts (pandas.DataFrame): Dataframe containing only the columns with neutron counts.\n        nan_strategy (str): Strategy to use for NaN values. Options are 'interpolate', 'average', or None. Default is None.\n\n    Returns:\n        (pandas.DataFrame): Dataframe with the sum of uncorrected neutron counts for all detectors.\n    \"\"\"\n    counts=counts.copy()\n\n    if counts.isnull().values.any():\n        if nan_strategy is None:\n            raise ValueError('NaN values found. Please fill missing values or provide a strategy. See documentation for more information.')\n        elif nan_strategy == 'interpolate':\n            print('NaN values found. Interpolating missing values using fill_counts().')\n            if type(counts.index) != pd.core.indexes.datetimes.DatetimeIndex:\n                raise ValueError('Index must be a timestamp to use interpolation strategy.')\n            counts = fill_counts(counts)\n        elif nan_strategy == 'average':\n            if len(counts.columns) == 1:\n                raise ValueError('Only one detector found. Cannot use average strategy.')\n            print('NaN values found. Replacing missing values with average of other detectors before summing.')\n            counts = counts.apply(lambda x: x.fillna(counts.mean(axis=1)),axis=0)\n        else:\n            raise ValueError('Invalid strategy.')\n\n    #Compute sum of counts\n    total_raw_counts = counts.sum(axis=1)\n    # Replace zeros with NaN\n    total_raw_counts = total_raw_counts.replace(0, np.nan)\n    return total_raw_counts\n</code></pre>"},{"location":"reference/#crnpy.crnpy.count_time","title":"<code>count_time(df)</code>","text":"<p>Approximate counting time.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>Dataframe containing only the columns with neutron counts and timestamp in the index.</p> required <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>Dataframe with the approximate counting time for each observation.</p> <p>Examples:</p> <p>Using <code>count_time</code> in a console environment:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame(...)\n&gt;&gt;&gt; count_time(df)\n0   3600.0\n1   3600.0\n2   3600.0\n</code></pre> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def count_time(df):\n\"\"\"Approximate counting time.\n\n    Args:\n        df (pandas.DataFrame): Dataframe containing only the columns with neutron counts and timestamp in the index.\n\n    Returns:\n        (pandas.DataFrame): Dataframe with the approximate counting time for each observation.\n\n    Examples:\n        Using `count_time` in a console environment:\n\n        &gt;&gt;&gt; df = pd.DataFrame(...)\n        &gt;&gt;&gt; count_time(df)\n        0   3600.0\n        1   3600.0\n        2   3600.0\n    \"\"\"\n\n    # Check that index is a timestamp\n    if type(df.index) != pd.core.indexes.datetimes.DatetimeIndex:\n        raise ValueError('Index must be a timestamp.')\n\n    # Calculate time difference between rows\n    count_time = df.index.to_series().diff().dt.total_seconds()\n\n    return count_time\n</code></pre>"},{"location":"reference/#crnpy.crnpy.counts_to_vwc","title":"<code>counts_to_vwc(counts, N0, Wlat, Wsoc, bulk_density, a0=0.0808, a1=0.372, a2=0.115)</code>","text":"<p>Function to convert corrected and filtered neutron counts into volumetric water content.</p> <p>This method implements soil moisture estimation using the non-linear relationship between neutron count and soil volumetric water content following the approach described in Desilets et al., 2010.</p> <p>$\\theta(N) =\\frac{a_0}{(\\frac{N}{N_0}) - a_1} - a_2 $</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>array or pd.Series or pd.DataFrame</code> <p>Array of corrected and filtered neutron counts.</p> required <code>N0</code> <code>float</code> <p>Device-specific neutron calibration constant.</p> required <code>Wlat</code> <code>float</code> <p>Lattice water content.</p> required <code>Wsoc</code> <code>float</code> <p>Soil organic carbon content.</p> required <code>bulk_density</code> <code>float</code> <p>Soil bulk density.</p> required <code>a0</code> <code>float</code> <p>Parameter given in Zreda et al., 2012. Default is 0.0808.</p> <code>0.0808</code> <code>a1</code> <code>float</code> <p>Parameter given in Zreda et al., 2012. Default is 0.372.</p> <code>0.372</code> <code>a2</code> <code>float</code> <p>Parameter given in Zreda et al., 2012. Default is 0.115.</p> <code>0.115</code> <p>Returns:</p> Type Description <code>array or pd.Series or pd.DataFrame</code> <p>Volumetric water content in m3 m-3.</p> References <p>Desilets, D., M. Zreda, and T.P.A. Ferr\u00e9. 2010. Nature\u2019s neutron probe: Land surface hydrology at an elusive scale with cosmic rays. Water Resour. Res. 46:W11505. doi.org/10.1029/2009WR008726</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def counts_to_vwc(counts, N0, Wlat, Wsoc ,bulk_density, a0=0.0808,a1=0.372,a2=0.115):\nr\"\"\"Function to convert corrected and filtered neutron counts into volumetric water content.\n\n    This method implements soil moisture estimation using the non-linear relationship between neutron count and soil volumetric water content following the approach described in Desilets et al., 2010.\n\n    $\\theta(N) =\\frac{a_0}{(\\frac{N}{N_0}) - a_1} - a_2 $\n\n    Args:\n        counts (array or pd.Series or pd.DataFrame): Array of corrected and filtered neutron counts.\n        N0 (float): Device-specific neutron calibration constant.\n        Wlat (float): Lattice water content.\n        Wsoc (float): Soil organic carbon content.\n        bulk_density (float): Soil bulk density.\n        a0 (float): Parameter given in Zreda et al., 2012. Default is 0.0808.\n        a1 (float): Parameter given in Zreda et al., 2012. Default is 0.372.\n        a2 (float): Parameter given in Zreda et al., 2012. Default is 0.115.\n\n    Returns:\n        (array or pd.Series or pd.DataFrame): Volumetric water content in m3 m-3.\n\n    References:\n        Desilets, D., M. Zreda, and T.P.A. Ferr\u00e9. 2010. Nature\u2019s neutron probe:\n        Land surface hydrology at an elusive scale with cosmic rays. Water Resour. Res. 46:W11505.\n        doi.org/10.1029/2009WR008726\n    \"\"\"\n\n    # Convert neutron counts into vwc\n    vwc = (a0 / (counts/N0-a1) - a2 - Wlat - Wsoc) * bulk_density\n    return vwc\n</code></pre>"},{"location":"reference/#crnpy.crnpy.cutoff_rigidity","title":"<code>cutoff_rigidity(lat, lon)</code>","text":"<p>Function to estimate the approximate cutoff rigidity for any point on Earth according to the tabulated data of Smart and Shea, 2019. Values are approximations so that users have an idea of what neutron detectors from the Neutron Monitor Database (NMD).</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Geographic latitude in decimal degrees. Value in range -90 to 90</p> required <code>lon</code> <code>float</code> <p>Geographic longitude in decimal degrees. Values in range from 0 to 360. Typical negative longitudes in the west hemisphere will fall in the range 180 to 360.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Cutoff rigidity in GV. Error is about +/- 0.3 GV</p> <p>Examples:</p> <p>Estimate the cutoff rigidity for Newark, NJ, US</p> <pre><code>&gt;&gt;&gt; zq = cutoff_rigidity(39.68, -75.75)\n&gt;&gt;&gt; print(zq)\n2.52 GV (Value from NMD is 2.40 GV)\n</code></pre> References <p>Smart, D. &amp; Shea, Matthew. (2001). Geomagnetic Cutoff Rigidity Computer Program: Theory, Software Description and Example. NASA STI/Recon Technical Report N.</p> <p>Shea, M. A., &amp; Smart, D. F. (2019, July). Re-examination of the First Five Ground-Level Events. In International Cosmic Ray Conference (ICRC2019) (Vol. 36, p. 1149).</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def cutoff_rigidity(lat,lon):\n\"\"\"Function to estimate the approximate cutoff rigidity for any point on Earth according to the\n    tabulated data of Smart and Shea, 2019. Values are approximations so that users have an idea of\n    what neutron detectors from the Neutron Monitor Database (NMD).\n\n    Args:\n        lat (float): Geographic latitude in decimal degrees. Value in range -90 to 90\n        lon (float): Geographic longitude in decimal degrees. Values in range from 0 to 360.\n            Typical negative longitudes in the west hemisphere will fall in the range 180 to 360.\n\n    Returns:\n        (float): Cutoff rigidity in GV. Error is about +/- 0.3 GV\n\n    Examples:\n        Estimate the cutoff rigidity for Newark, NJ, US\n\n        &gt;&gt;&gt; zq = cutoff_rigidity(39.68, -75.75)\n        &gt;&gt;&gt; print(zq)\n        2.52 GV (Value from NMD is 2.40 GV)\n\n    References:\n        Smart, D. &amp; Shea, Matthew. (2001). Geomagnetic Cutoff Rigidity Computer Program:\n        Theory, Software Description and Example. NASA STI/Recon Technical Report N.\n\n        Shea, M. A., &amp; Smart, D. F. (2019, July). Re-examination of the First Five Ground-Level Events.\n        In International Cosmic Ray Conference (ICRC2019) (Vol. 36, p. 1149).\n    \"\"\"\n    xq = lon\n    yq = lat\n\n    if xq &lt; 0:\n        xq = xq*-1 + 180\n    Z = np.array(data.cutoff_rigidity)\n    x = np.linspace(0, 360, Z.shape[1])\n    y = np.linspace(90, -90, Z.shape[0])\n    X, Y = np.meshgrid(x, y)\n    points = np.array( (X.flatten(), Y.flatten()) ).T\n    values = Z.flatten()\n    zq = griddata(points, values, (xq,yq))\n\n    return np.round(zq,2)\n</code></pre>"},{"location":"reference/#crnpy.crnpy.drop_outliers","title":"<code>drop_outliers(raw_counts, window=5, store_outliers=False, min_counts=None, max_counts=None)</code>","text":"<p>Computation of a moving modified Z-score based on the median absolute difference.</p> <p>Parameters:</p> Name Type Description Default <code>raw_counts</code> <code>pandas.DataFrame</code> <p>Dataframe containing only the columns with neutron counts.</p> required <code>window</code> <code>int</code> <p>Window size for the moving median. Default is 11.</p> <code>5</code> <code>store_outliers</code> <code>bool</code> <p>If True, store the outliers in a new column. Default is False.</p> <code>False</code> <code>min_counts</code> <code>int</code> <p>Minimum number of counts for a reading to be considered valid. Default is None.</p> <code>None</code> <code>max_counts</code> <code>int</code> <p>Maximum number of counts for a reading to be considered valid. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>Dataframe without outliers.</p> <p>or</p> <code>pandas.DataFrame, pandas.DataFrame</code> <p>Dataframe without outliers and dataframe with outliers.</p> References <p>Iglewicz, B. and Hoaglin, D.C., 1993. How to detect and handle outliers (Vol. 16). Asq Press.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def drop_outliers(raw_counts, window=5, store_outliers=False, min_counts=None, max_counts=None):\n\"\"\"Computation of a moving modified Z-score based on the median absolute difference.\n\n    Args:\n        raw_counts (pandas.DataFrame): Dataframe containing only the columns with neutron counts.\n        window (int): Window size for the moving median. Default is 11.\n        store_outliers (bool): If True, store the outliers in a new column. Default is False.\n        min_counts (int): Minimum number of counts for a reading to be considered valid. Default is None.\n        max_counts (int): Maximum number of counts for a reading to be considered valid. Default is None.\n\n    Returns:\n        (pandas.DataFrame): Dataframe without outliers.\n        or\n        (pandas.DataFrame, pandas.DataFrame): Dataframe without outliers and dataframe with outliers.\n\n    References:\n        Iglewicz, B. and Hoaglin, D.C., 1993. How to detect and handle outliers (Vol. 16). Asq Press.\n    \"\"\"\n\n\n    if min_counts is not None:\n        lower_count = np.sum(raw_counts &lt; min_counts)\n        if lower_count &gt; len(raw_counts) * 0.25:\n            print(f\"WARNING: Discarded {lower_count} counts below {min_counts}. This is more than 25% of the total number of readings. Consider increasing the minimum counts threshold.\")\n        else:\n            print(f\"Discarded counts below {min_counts}: {lower_count}\")\n        raw_counts = raw_counts[raw_counts &gt;= min_counts]\n    if max_counts is not None:\n        upper_count = np.sum(raw_counts &gt; max_counts)\n        print(f\"Discarded counts above {max_counts}: {upper_count}\")\n        raw_counts = raw_counts[raw_counts &lt;= max_counts]\n\n    # Compute median absolute difference\n    median = raw_counts.rolling(window, center=True).median()\n    diff = np.abs(raw_counts - median)\n    mad = diff.rolling(window, center=True).median()\n\n    # Compute modified Z-score\n    modified_z_score = 0.6745 * diff / mad\n    outliers = raw_counts[modified_z_score &gt; 3.5]\n    # Drop outliers\n    raw_counts = raw_counts[modified_z_score &lt; 3.5]\n\n    if store_outliers:\n        return raw_counts, outliers\n    print(f\"Discarded {len(outliers)} outliers using modified Z-score.\")\n    return raw_counts\n</code></pre>"},{"location":"reference/#crnpy.crnpy.estimate_abs_humidity","title":"<code>estimate_abs_humidity(RH, temp)</code>","text":"<p>Compute the actual vapor pressure (e) in g m^-3 using RH (%) and current temperature (c) observations.</p> <p>Parameters:</p> Name Type Description Default <code>RH</code> <code>float</code> <p>relative humidity (%)</p> required <code>temp</code> <code>float</code> <p>temperature (Celsius)</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>actual vapor pressure (g m^-3)</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def estimate_abs_humidity(RH, temp):\n\"\"\"\n    Compute the actual vapor pressure (e) in g m^-3 using RH (%) and current temperature (c) observations.\n\n    Args:\n        RH (float): relative humidity (%)\n        temp (float): temperature (Celsius)\n\n    Returns:\n        float: actual vapor pressure (g m^-3)\n    \"\"\"\n\n    ### Atmospheric water vapor factor\n    # Saturation vapor pressure\n    e_sat = 0.611 * np.exp(17.502 * temp / (\n                temp + 240.97)) * 1000  # in Pascals Eq. 3.8 p.41 Environmental Biophysics (Campbell and Norman)\n\n    # Vapor pressure Pascals\n    Pw = e_sat * RH / 100\n\n    # Absolute humidity (g/m^3)\n    C = 2.16679  # g K/J;\n    abs_h = C * Pw / (temp + 273.15)\n    return abs_h\n</code></pre>"},{"location":"reference/#crnpy.crnpy.estimate_lattice_water","title":"<code>estimate_lattice_water(clay_content, total_carbon=None)</code>","text":"<p>Estimate the amount of water in the lattice of clay minerals.</p> $\\omega_{lat} = 1.241 + 0.069 * clay(\\%)$ $\\omega_{lat} = -0.028 + 0.077 * clay(\\%) + 0.459 * carbon(\\%)$ Linear regression [lattice water (%) as a function of clay (%)] done with data from Soil Water Processes Lab and Dong and Ochsner (2018) Multiple linear regression [lattice water (%) as a function of clay (%) and soil carbon (%)] done with data from Soil Water Processes Lab. <p>Parameters:</p> Name Type Description Default <code>clay_content</code> <code>float</code> <p>Clay content in the soil in percent.</p> required <code>total_carbon</code> <code>float</code> <p>Total carbon content in the soil in percent. If None, the amount of water is estimated based on clay content only.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Amount of water in the lattice of clay minerals in percent</p> References <p>Dong, J., &amp; Ochsner, T. E. (2018). Soil texture often exerts a stronger influence than precipitation  on mesoscale soil moisture patterns. Water Resources Research, 54, 2199\u2013 2211.  https://doi.org/10.1002/2017WR021692</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def estimate_lattice_water(clay_content, total_carbon=None):\nr\"\"\"Estimate the amount of water in the lattice of clay minerals.\n\n    ![img1](img/lattice_water_simple.png) | ![img2](img/lattice_water_multiple.png)\n    :-------------------------:|:-------------------------:\n    $\\omega_{lat} = 1.241 + 0.069 * clay(\\%)$ | $\\omega_{lat} = -0.028 + 0.077 * clay(\\%) + 0.459 * carbon(\\%)$\n    Linear regression [lattice water (%) as a function of clay (%)] done with data from Soil Water Processes Lab and Dong and Ochsner (2018) |  Multiple linear regression [lattice water (%) as a function of clay (%) and soil carbon (%)] done with data from Soil Water Processes Lab.\n\n    Args:\n        clay_content (float): Clay content in the soil in percent.\n        total_carbon (float, optional): Total carbon content in the soil in percent.\n            If None, the amount of water is estimated based on clay content only.\n\n    Returns:\n        (float): Amount of water in the lattice of clay minerals in percent\n\n    References:\n        Dong, J., &amp; Ochsner, T. E. (2018). Soil texture often exerts a stronger influence than precipitation\n         on mesoscale soil moisture patterns. Water Resources Research, 54, 2199\u2013 2211.\n         https://doi.org/10.1002/2017WR021692\n\n    \"\"\"\n    if total_carbon is None:\n        lattice_water = 1.241 + 0.069 * clay_content\n    else:\n        lattice_water = -0.028 + 0.077 * clay_content + 0.459 * total_carbon\n    return lattice_water\n</code></pre>"},{"location":"reference/#crnpy.crnpy.euclidean_distance","title":"<code>euclidean_distance(px, py, x, y)</code>","text":"<p>Function that computes the Euclidean distance between one point in space and one or more points.</p> <p>Parameters:</p> Name Type Description Default <code>px</code> <code>float</code> <p>x projected coordinate of the point.</p> required <code>py</code> <code>float</code> <p>y projected coordinate of the point.</p> required <code>x</code> <code>list, ndarray, pandas.series</code> <p>vector of x projected coordinates.</p> required <code>y</code> <code>list, ndarray, pandas.series</code> <p>vector of y projected coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Numpy array of distances from the point (px,py) to all the points in x and y vectors.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def euclidean_distance(px, py, x, y):\n\"\"\"Function that computes the Euclidean distance between one point\n    in space and one or more points.\n\n    Args:\n        px (float): x projected coordinate of the point.\n        py (float): y projected coordinate of the point.\n        x (list, ndarray, pandas.series): vector of x projected coordinates.\n        y (list, ndarray, pandas.series): vector of y projected coordinates.\n\n    Returns:\n        (ndarray): Numpy array of distances from the point (px,py) to all the points in x and y vectors.\n    \"\"\"\n    d = np.sqrt((px - x) ** 2 + (py - y) ** 2)\n    return d\n</code></pre>"},{"location":"reference/#crnpy.crnpy.fill_counts","title":"<code>fill_counts(counts, count_times=None, expected_time=False, threshold=0.25, limit=3)</code>","text":"<p>Fill missing neutron counts. Observation periods shorter than threshold are discarded (replaced with NaN).</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>pandas.DataFrame</code> <p>DataFrame with neutron counts, might have count_time column(s).</p> required <code>count_time</code> <code>pandas.Series or pandas.DataFrame</code> <p>Counting time in seconds. If a DataFrame is provided, it must have the same number of columns as df.</p> required <code>expected_time</code> <code>int</code> <p>Expected counting time in seconds. If not provided, it is calculated as the median of the counting times.</p> <code>False</code> <code>threshold</code> <code>float</code> <p>Minimum fraction of the neutron integration time. Default is 0.25.</p> <code>0.25</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>DataFrame with linearly interpolated neutron counts.</p> <p>Examples:</p> <p>Using <code>fill_counts</code> in a console environment:</p> <pre><code>&gt;&gt;&gt; counts = pd.DataFrame({'counts':[100,105,98,102], count_time:[3600,200,3600,3600]})\n&gt;&gt;&gt; fill_counts(counts, count_time=count_time, expected_time=3600, threshold=0.25)\n0   100.0\n1   NaN\n2   98.0\n3   102.0\n</code></pre> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def fill_counts(counts, count_times=None, expected_time=False, threshold=0.25, limit=3):\n\"\"\"Fill missing neutron counts. Observation periods shorter than threshold are discarded (replaced with NaN).\n\n    Args:\n        counts (pandas.DataFrame): DataFrame with neutron counts, might have count_time column(s).\n        count_time (pandas.Series or pandas.DataFrame): Counting time in seconds. If a DataFrame is provided, it must have the same number of columns as df.\n        expected_time (int): Expected counting time in seconds. If not provided, it is calculated as the median of the counting times.\n        threshold (float): Minimum fraction of the neutron integration time. Default is 0.25.\n\n    Returns:\n        (pandas.DataFrame): DataFrame with linearly interpolated neutron counts.\n\n    Examples:\n        Using `fill_counts` in a console environment:\n\n        &gt;&gt;&gt; counts = pd.DataFrame({'counts':[100,105,98,102], count_time:[3600,200,3600,3600]})\n        &gt;&gt;&gt; fill_counts(counts, count_time=count_time, expected_time=3600, threshold=0.25)\n        0   100.0\n        1   NaN\n        2   98.0\n        3   102.0\n    \"\"\"\n\n    counts=counts.copy()\n\n    if type(counts.index) == pd.core.indexes.datetimes.DatetimeIndex and isinstance(count_times, type(None)):\n        print(\"No count time columns provided. Using timestamp index to compute count time.\")\n        count_times = counts.index.to_series().diff().dt.total_seconds()\n\n    if type(counts.index) != pd.core.indexes.datetimes.DatetimeIndex and isinstance(count_times, type(None)):\n        raise ValueError('Index must be a timestamp or count times must be provided.')\n\n    if len(counts) != len(count_times):\n        raise ValueError('Count times length does not match number of readings.')\n\n    if expected_time is False:\n        expected_time = count_times.median()\n        print('Using median count time as expected count time:', expected_time)\n\n    # Replace values below threshold with NaN\n    time_threshold = round(expected_time * threshold)\n\n    if type(count_times) == pd.core.frame.DataFrame:\n        if len(count_times.columns) == 1:\n            idx_nan = count_times[count_times &lt; time_threshold].index\n            counts.loc[idx_nan] = np.nan\n        else:\n            for i in range(len(count_times.columns)):\n                idx_nan = count_times[count_times.iloc[:,i] &lt; time_threshold].index\n                counts.iloc[:,i].loc[idx_nan] = np.nan\n    elif type(count_times) == pd.core.series.Series:\n        idx_nan = count_times[count_times &lt; time_threshold].index\n        counts.loc[idx_nan] = np.nan\n    elif type(count_times) == np.ndarray:\n        idx_nan = np.where(count_times &lt; time_threshold)\n        counts.loc[idx_nan] = np.nan\n\n    # Fill missing values with linear interpolation and round to nearest integer\n    counts = counts.interpolate(method='linear', limit=limit, limit_direction='both').round()\n    return counts\n</code></pre>"},{"location":"reference/#crnpy.crnpy.fill_missing_atm","title":"<code>fill_missing_atm(cols_atm, limit=24)</code>","text":"<p>Fill missing values in atmospheric variables. Gap filling is performed using a piecewise cubic Hermite interpolating polynomial (pchip method) that is restricted to intervals of missing data with a limited number of values and surrounded by valid observations. There is no interpolation at the end of the time series.</p> <p>Parameters:</p> Name Type Description Default <code>col_atm</code> <code>pandas.Series or pandas.DataFrame</code> <p>Atmospheric variables to fill.</p> required <code>limit</code> <code>int</code> <p>Maximum number of consecutive missing values to interpolate. Default is 24.</p> <code>24</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>Atmospheric variables with filled missing values using a piecewise cubic Hermite polynomial.</p> References <p>https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.interpolate.html</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def fill_missing_atm(cols_atm, limit=24):\n\"\"\"Fill missing values in atmospheric variables. Gap filling is performed using a\n    piecewise cubic Hermite interpolating polynomial (pchip method) that is restricted to intervals\n    of missing data with a limited number of values and surrounded by valid observations.\n    There is no interpolation at the end of the time series.\n\n    Args:\n        col_atm (pandas.Series or pandas.DataFrame): Atmospheric variables to fill.\n        limit (int): Maximum number of consecutive missing values to interpolate. Default is 24.\n\n    Returns:\n        (pandas.DataFrame): Atmospheric variables with filled missing values using a piecewise cubic Hermite polynomial.\n\n    References:\n        https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.interpolate.html\n    \"\"\"\n\n    # Fill missing values in atmospheric variables\n    return cols_atm.interpolate(method='pchip', limit=limit, limit_direction='both')\n</code></pre>"},{"location":"reference/#crnpy.crnpy.find_neutron_detectors","title":"<code>find_neutron_detectors(Rc, start_date=None, end_date=None)</code>","text":"<p>Search for potential reference neutron monitoring stations based on cutoff rigidity.</p> <p>Parameters:</p> Name Type Description Default <code>Rc</code> <code>float</code> <p>Cutoff rigidity in GV. Values in range 1.0 to 3.0 GV.</p> required <code>start_date</code> <code>datetime</code> <p>Start date for the period of interest.   </p> <code>None</code> <code>end_date</code> <code>datetime</code> <p>End date for the period of interest.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>List of top five stations with closes cutoff rigidity. User needs to select station according to site altitude.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from crnpy import crnpy\n&gt;&gt;&gt; Rc = 2.40 # 2.40 Newark, NJ, US\n&gt;&gt;&gt; crnpy.find_neutron_detectors(Rc)\nSelect a station with an altitude similar to that of your location. For more information go to: 'https://www.nmdb.eu/nest/help.php#helpstations\n</code></pre> <p>Your cutoff rigidity is 2.4 GV         STID                          NAME     R  Altitude_m 40   NEWK                        Newark  2.40          50 33   MOSC                        Moscow  2.43         200 27   KIEL                          Kiel  2.36          54 28  KIEL2                        KielRT  2.36          54 31   MCRL  Mobile Cosmic Ray Laboratory  2.46         200 32   MGDN                       Magadan  2.10         220 42   NVBK                   Novosibirsk  2.91         163 26   KGSN                      Kingston  1.88          65 9    CLMX                        Climax  3.00        3400 57   YKTK                       Yakutsk  1.65         105</p> References <p>https://www.nmdb.eu/nest/help.php#helpstations</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def find_neutron_detectors(Rc, start_date=None, end_date=None):\n\"\"\"Search for potential reference neutron monitoring stations based on cutoff rigidity.\n\n    Args:\n        Rc (float): Cutoff rigidity in GV. Values in range 1.0 to 3.0 GV.\n        start_date (datetime): Start date for the period of interest.   \n        end_date (datetime): End date for the period of interest.\n\n    Returns:\n        (list): List of top five stations with closes cutoff rigidity.\n            User needs to select station according to site altitude.\n\n    Examples:\n        &gt;&gt;&gt; from crnpy import crnpy\n        &gt;&gt;&gt; Rc = 2.40 # 2.40 Newark, NJ, US\n        &gt;&gt;&gt; crnpy.find_neutron_detectors(Rc)\n        Select a station with an altitude similar to that of your location. For more information go to: 'https://www.nmdb.eu/nest/help.php#helpstations\n\n        Your cutoff rigidity is 2.4 GV\n                STID                          NAME     R  Altitude_m\n        40   NEWK                        Newark  2.40          50\n        33   MOSC                        Moscow  2.43         200\n        27   KIEL                          Kiel  2.36          54\n        28  KIEL2                        KielRT  2.36          54\n        31   MCRL  Mobile Cosmic Ray Laboratory  2.46         200\n        32   MGDN                       Magadan  2.10         220\n        42   NVBK                   Novosibirsk  2.91         163\n        26   KGSN                      Kingston  1.88          65\n        9    CLMX                        Climax  3.00        3400\n        57   YKTK                       Yakutsk  1.65         105\n\n    References:\n        https://www.nmdb.eu/nest/help.php#helpstations\n    \"\"\"\n\n    # Load file with list of neutron monitoring stations\n    stations = pd.DataFrame(data.neutron_detectors, columns=[\"STID\",\"NAME\",\"R\",\"Altitude_m\"])\n\n    # Sort stations by closest cutoff rigidity\n    idx_R = (stations['R'] - Rc).abs().argsort()\n\n    if start_date is not None and end_date is not None:\n        stations[\"Period available\"] = False\n        for i in range(10):\n            station = stations.iloc[idx_R[i]][\"STID\"]\n            try:\n                if get_incoming_neutron_flux(start_date, end_date, station, verbose=-1) is not None:\n                    stations.iloc[idx_R[i],-1] = True\n            except:\n                pass\n        if sum(stations[\"Period available\"] == True) == 0:\n            print(\"No stations available for the selected period!\")\n        else:\n            stations = stations[stations[\"Period available\"] == True]\n            idx_R = (stations['R'] - Rc).abs().argsort()\n            result = stations.iloc[idx_R.iloc[:10]]\n    else:\n        result = stations.reindex(idx_R).head(10).rename_axis(None)\n\n    # Print results\n    print('')\n    print(\"\"\"Select a station with an altitude similar to that of your location. For more information go to: 'https://www.nmdb.eu/nest/help.php#helpstations\"\"\")\n    print('')\n    print(f\"Your cutoff rigidity is {Rc} GV\")\n    print(result)\n    return result\n</code></pre>"},{"location":"reference/#crnpy.crnpy.format_dates_df","title":"<code>format_dates_df(df, col='timestamp', format='%Y-%m-%d %H:%M:%S', freq='H', round_time=True)</code>","text":"<p>Helper function to change the format and round timestamps.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>DataFrame with timestamp in the index.</p> required <code>col</code> <code>str</code> <p>Column with the timestamp. Default is 'timestamp'.</p> <code>'timestamp'</code> <code>format</code> <code>str</code> <p>Format of the timestamp. Default is '%Y-%m-%d %H:%M:%S'.</p> <code>'%Y-%m-%d %H:%M:%S'</code> <code>freq</code> <code>str</code> <p>Rounding interval. 'H' for hourly, 'M' for minute, or None. Default is 'H'.</p> <code>'H'</code> <code>round_time</code> <code>bool</code> <p>Whether to round timestamps to the nearest frequency. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>DataFrame with formatted timestamps and rounded time.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from crnpy import crnpy\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame({'timestamp':['2020-01-01 00:00:00','2020-01-01 00:30:00','2020-01-01 01:00:00']})\n&gt;&gt;&gt; df = crnpy.format_dates_df(df, col='timestamp', format='%Y-%m-%d %H:%M:%S', freq='H', round_time=True)\n&gt;&gt;&gt; df\n                timestamp\n0   2020-01-01 00:00:00\n1   2020-01-01 00:00:00\n2   2020-01-01 01:00:00\n</code></pre> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def format_dates_df(df, col='timestamp', format='%Y-%m-%d %H:%M:%S', freq='H', round_time=True):\n\"\"\"Helper function to change the format and round timestamps.\n\n     Args:\n         df (pandas.DataFrame): DataFrame with timestamp in the index.\n         col (str, optional): Column with the timestamp. Default is 'timestamp'.\n         format (str, optional): Format of the timestamp. Default is '%Y-%m-%d %H:%M:%S'.\n         freq (str, optional): Rounding interval. 'H' for hourly, 'M' for minute, or None. Default is 'H'.\n         round_time (bool, optional): Whether to round timestamps to the nearest frequency. Default is True.\n\n     Returns:\n         (pandas.DataFrame): DataFrame with formatted timestamps and rounded time.\n\n     Examples:\n            &gt;&gt;&gt; from crnpy import crnpy\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; df = pd.DataFrame({'timestamp':['2020-01-01 00:00:00','2020-01-01 00:30:00','2020-01-01 01:00:00']})\n            &gt;&gt;&gt; df = crnpy.format_dates_df(df, col='timestamp', format='%Y-%m-%d %H:%M:%S', freq='H', round_time=True)\n            &gt;&gt;&gt; df\n                            timestamp\n            0   2020-01-01 00:00:00\n            1   2020-01-01 00:00:00\n            2   2020-01-01 01:00:00\n     \"\"\"\n\n    # Change format of timestamp if needed\n    if df[col].dtype != 'datetime64[ns]':\n        df[col] = pd.to_datetime(df[col], format=format)\n\n    # Round timestamps to nearest frequency\n    if round_time:\n        df[col] = df[col].dt.round(freq)\n\n    # Fill in rows with missing timestamps\n    start_date = df[col].iloc[0]\n    end_date = df[col].iloc[-1]\n    date_range = pd.date_range(start_date, end_date, freq=freq)\n    for date in date_range:\n        if date not in df[col].values:\n            print('Adding missing date:',date)\n            new_line = pd.DataFrame({col:date}, index=[-1]) # By default fills columns with np.nan\n            source = pd.concat([df,new_line])\n\n    df.sort_values(by=col, inplace=True)\n    df.reset_index(drop=True, inplace=True)\n    df.set_index(col, inplace=True)\n    return df\n</code></pre>"},{"location":"reference/#crnpy.crnpy.get_incoming_neutron_flux","title":"<code>get_incoming_neutron_flux(start_date, end_date, station, utc_offset=0, expand_window=0, verbose=False)</code>","text":"<p>Function to retrieve neutron flux from the Neutron Monitor Database.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>datetime</code> <p>Start date of the time series.</p> required <code>end_date</code> <code>datetime</code> <p>End date of the time series.</p> required <code>station</code> <code>str</code> <p>Neutron Monitor station to retrieve data from.</p> required <code>utc_offset</code> <code>int</code> <p>UTC offset in hours. Default is 0.</p> <code>0</code> <code>expand_window</code> <code>int</code> <p>Number of hours to expand the time window to retrieve extra data. Default is 0.</p> <code>0</code> <code>verbose</code> <code>bool</code> <p>Print information about the request. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>Neutron flux in counts per hour and timestamps.</p> References <p>Documentation available:https://www.nmdb.eu/nest/help.php#howto</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def get_incoming_neutron_flux(start_date, end_date, station, utc_offset=0, expand_window = 0,  verbose=False):\n\"\"\"Function to retrieve neutron flux from the Neutron Monitor Database.\n\n    Args:\n        start_date (datetime): Start date of the time series.\n        end_date (datetime): End date of the time series.\n        station (str): Neutron Monitor station to retrieve data from.\n        utc_offset (int): UTC offset in hours. Default is 0.\n        expand_window (int): Number of hours to expand the time window to retrieve extra data. Default is 0.\n        verbose (bool): Print information about the request. Default is False.\n\n    Returns:\n        (pandas.DataFrame): Neutron flux in counts per hour and timestamps.\n\n    References:\n        Documentation available:https://www.nmdb.eu/nest/help.php#howto\n    \"\"\"\n\n    # Example: get_incoming_flux(station='IRKT',start_date='2020-04-10 11:00:00',end_date='2020-06-18 17:00:00')\n    # Template url = 'http://nest.nmdb.eu/draw_graph.php?formchk=1&amp;stations[]=KERG&amp;output=ascii&amp;tabchoice=revori&amp;dtype=corr_for_efficiency&amp;date_choice=bydate&amp;start_year=2009&amp;start_month=09&amp;start_day=01&amp;start_hour=00&amp;start_min=00&amp;end_year=2009&amp;end_month=09&amp;end_day=05&amp;end_hour=23&amp;end_min=59&amp;yunits=0'\n\n\n    # Expand the time window by 1 hour to ensure an extra observation is included in the request.\n    start_date -= pd.Timedelta(hours=expand_window)\n    end_date += pd.Timedelta(hours=expand_window)\n\n\n    # Convert local time to UTC\n    start_date = start_date - datetime.timedelta(hours=utc_offset)\n    end_date = end_date - datetime.timedelta(hours=utc_offset)\n    date_format = '%Y-%m-%d %H:%M:%S'\n    root = 'http://www.nmdb.eu/nest/draw_graph.php?'\n    url_par = [ 'formchk=1',\n                'stations[]=' + station,\n                'output=ascii',\n                'tabchoice=revori',\n                'dtype=corr_for_efficiency',\n                'tresolution=' + str(60),\n                'date_choice=bydate',\n                'start_year=' + str(start_date.year),\n                'start_month=' + str(start_date.month),\n                'start_day=' + str(start_date.day),\n                'start_hour=' + str(start_date.hour),\n                'start_min=' + str(start_date.minute),\n                'end_year=' + str(end_date.year),\n                'end_month=' + str(end_date.month),\n                'end_day=' + str(end_date.day),\n                'end_hour=' + str(end_date.hour),\n                'end_min=' + str(end_date.minute),\n                'yunits=0']\n\n    url = root + '&amp;'.join(url_par)\n\n    if verbose &gt; 0:\n        print(f\"Retrieving data from {url}\")\n\n    r = requests.get(url).content.decode('utf-8')\n\n    # Subtract 1 hour to restore the last date included in the request.\n    end_date -= pd.Timedelta('1H')\n    start = r.find(\"RCORR_E\\n\") + 8\n    end = r.find('\\n&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;Total') - 1\n    s = r[start:end]\n    s2 = ''.join([row.replace(';',',') for row in s])\n    try:\n        df_flux = pd.read_csv(io.StringIO(s2), names=['timestamp','counts'])\n    except:\n        if verbose &gt; -1:\n            print(f\"Error retrieving data from {url}\")\n        return None\n\n    # Check if all values from selected detector are NaN. If yes, warn the user\n    if df_flux['counts'].isna().all():\n        warnings.warn('Data for selected neutron detectors appears to be unavailable for the selected period')\n\n    # Convert timestamp to datetime and apply UTC offset\n    df_flux['timestamp'] = pd.to_datetime(df_flux['timestamp'])\n    df_flux['timestamp'] = df_flux['timestamp'] + pd.Timedelta(hours=utc_offset)\n\n    # Print acknowledgement to inform users about restrictions and to acknowledge the NMDB database\n    acknowledgement = \"\"\"Data retrieved via NMDB are the property of the individual data providers. These data are free for non commercial\nuse to within the restriction imposed by the providers. If you use such data for your research or applications, please acknowledge\nthe origin by a sentence like 'We acknowledge the NMDB database (www.nmdb.eu) founded under the European Union's FP7 programme \n(contract no. 213007), and the PIs of individual neutron monitors at: IGY Jungfraujoch \n(Physikalisches Institut, University of Bern, Switzerland)\"\"\"\n    #print(acknowledgement)\n\n    return df_flux.set_index('timestamp')\n</code></pre>"},{"location":"reference/#crnpy.crnpy.idw","title":"<code>idw(x, y, z, X_pred, Y_pred, neighborhood=1000, p=1)</code>","text":"<p>Function to interpolate data using inverse distance weight.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list or array</code> <p>UTM x coordinates in meters.</p> required <code>y</code> <code>list or array</code> <p>UTM y coordinates in meters.</p> required <code>z</code> <code>list or array</code> <p>Values to be interpolated.</p> required <code>X_pred</code> <code>list or array</code> <p>UTM x coordinates where z values need to be predicted.</p> required <code>Y_pred</code> <code>list or array</code> <p>UTM y coordinates where z values need to be predicted.</p> required <code>neighborhood</code> <code>float</code> <p>Only points within this radius in meters are considered for the interpolation.</p> <code>1000</code> <code>p</code> <code>int</code> <p>Exponent of the inverse distance weight formula. Typically, p=1 or p=2.</p> <code>1</code> <p>Returns:</p> Type Description <code>array</code> <p>Interpolated values.</p> References <p>https://soilwater.github.io/pynotes-agriscience/notebooks/inverse_distance_weighting.html</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def idw(x, y, z, X_pred, Y_pred, neighborhood=1000, p=1):\n\"\"\"Function to interpolate data using inverse distance weight.\n\n    Args:\n        x (list or array): UTM x coordinates in meters.\n        y (list or array): UTM y coordinates in meters.\n        z (list or array): Values to be interpolated.\n        X_pred (list or array): UTM x coordinates where z values need to be predicted.\n        Y_pred (list or array): UTM y coordinates where z values need to be predicted.\n        neighborhood (float): Only points within this radius in meters are considered for the interpolation.\n        p (int): Exponent of the inverse distance weight formula. Typically, p=1 or p=2.\n\n    Returns:\n        (array): Interpolated values.\n\n    References:\n        [https://soilwater.github.io/pynotes-agriscience/notebooks/inverse_distance_weighting.html](https://soilwater.github.io/pynotes-agriscience/notebooks/inverse_distance_weighting.html)\n\n\n    \"\"\"\n\n    # Flatten arrays to handle 1D and 2D arrays with the same code\n    s = X_pred.shape  # Save shape\n    X_pred = X_pred.flatten()\n    Y_pred = Y_pred.flatten()\n\n    # Pre-allocate output array\n    Z_pred = np.full_like(X_pred, np.nan)\n\n    for n in range(X_pred.size):\n        # Distance between current and observed points\n        d = euclidean_distance(X_pred[n], Y_pred[n], x, y)\n\n        # Select points within neighborhood only for interpolateion\n        idx_neighbors = d &lt; neighborhood\n\n        # Compute interpolated value at point of interest\n        Z_pred[n] = np.sum(z[idx_neighbors] / d[idx_neighbors] ** p) / np.sum(1 / d[idx_neighbors] ** p)\n\n    return np.reshape(Z_pred, s)\n</code></pre>"},{"location":"reference/#crnpy.crnpy.interpolate_2D","title":"<code>interpolate_2D(x, y, z, dx=100, dy=100, method='cubic', neighborhood=1000)</code>","text":"<p>Function for interpolating irregular spatial data into a regular grid.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list or array</code> <p>UTM x coordinates in meters.</p> required <code>y</code> <code>list or array</code> <p>UTM y coordinates in meters.</p> required <code>z</code> <code>list or array</code> <p>Values to be interpolated.</p> required <code>dx</code> <code>float</code> <p>Pixel width in meters.</p> <code>100</code> <code>dy</code> <code>float</code> <p>Pixel height in meters.</p> <code>100</code> <code>method</code> <code>str</code> <p>Interpolation method. One of 'cubic', 'linear', 'nearest', or 'idw'.</p> <code>'cubic'</code> <code>neighborhood</code> <code>float</code> <p>Only points within this radius in meters are considered for the interpolation.</p> <code>1000</code> <p>Returns:</p> Name Type Description <code>x_pred</code> <code>array</code> <p>2D array with x coordinates.</p> <code>y_pred</code> <code>array</code> <p>2D array with y coordinates.</p> <code>z_pred</code> <code>array</code> <p>2D array with interpolated values.</p> References <p>https://soilwater.github.io/pynotes-agriscience/notebooks/interpolation.html</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def interpolate_2D(x, y, z, dx=100, dy=100, method='cubic', neighborhood=1000):\n\"\"\"Function for interpolating irregular spatial data into a regular grid.\n\n    Args:\n        x (list or array): UTM x coordinates in meters.\n        y (list or array): UTM y coordinates in meters.\n        z (list or array): Values to be interpolated.\n        dx (float): Pixel width in meters.\n        dy (float): Pixel height in meters.\n        method (str): Interpolation method. One of 'cubic', 'linear', 'nearest', or 'idw'.\n        neighborhood (float): Only points within this radius in meters are considered for the interpolation.\n\n    Returns:\n        x_pred (array): 2D array with x coordinates.\n        y_pred (array): 2D array with y coordinates.\n        z_pred (array): 2D array with interpolated values.\n\n    References:\n        [https://soilwater.github.io/pynotes-agriscience/notebooks/interpolation.html](https://soilwater.github.io/pynotes-agriscience/notebooks/interpolation.html)\n    \"\"\"\n\n    # Drop NaN values in x y and z\n    idx_nan = np.isnan(x) | np.isnan(y) | np.isnan(z)\n    x = x[~idx_nan]\n    y = y[~idx_nan]\n    z = z[~idx_nan]\n\n    if idx_nan.any():\n        print(f\"WARNING: {np.isnan(x).sum()}, {np.isnan(y).sum()}, and {np.isnan(z).sum()} NaN values were dropped from x, y, and z.\")\n\n    # Create 2D grid for interpolation\n    Nx = round((np.max(x) - np.min(x)) / dx) + 1\n    Ny = round((np.max(y) - np.min(y)) / dy) + 1\n    X_vec = np.linspace(np.min(x), np.max(x), Nx)\n    Y_vec = np.linspace(np.min(y), np.max(y), Ny)\n    X_pred, Y_pred = np.meshgrid(X_vec, Y_vec)\n\n    if method in ['linear', 'nearest', 'cubic']:\n        points = list(zip(x, y))\n        Z_pred = griddata(points, z, (X_pred, Y_pred), method=method)\n\n    elif method == 'idw':\n        Z_pred = idw(x, y, z, X_pred, Y_pred, neighborhood)\n\n    else:\n        raise f\"Method {method} does not exist. Provide either 'cubic', 'linear', 'nearest', or 'idw'.\"\n\n    return X_pred, Y_pred, Z_pred\n</code></pre>"},{"location":"reference/#crnpy.crnpy.interpolate_incoming_flux","title":"<code>interpolate_incoming_flux(df_flux, timestamps)</code>","text":"<p>Function to interpolate incoming neutron flux to match the timestamps of the observations.</p> <p>Parameters:</p> Name Type Description Default <code>df_flux</code> <code>pd.DataFrame</code> <p>Dataframe returned by get_incoming_flux method.</p> required <code>timestamps</code> <code>pd.series or pd.DataFrame or pd.DatetimeIndex</code> <p>Timestamps to interpolate the incoming neutron flux.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Dataframe containing interpolated incoming neutron flux.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def interpolate_incoming_flux(df_flux, timestamps):\n\"\"\"Function to interpolate incoming neutron flux to match the timestamps of the observations.\n\n    Args:\n        df_flux (pd.DataFrame): Dataframe returned by get_incoming_flux method.\n        timestamps (pd.series or pd.DataFrame or pd.DatetimeIndex): Timestamps to interpolate the incoming neutron flux.\n\n    Returns:\n        (pd.DataFrame): Dataframe containing interpolated incoming neutron flux.\n    \"\"\"\n\n    # Check that index is datetime\n    if not isinstance(df_flux.index, pd.DatetimeIndex):\n        raise ValueError('Index of df_flux must be datetime')\n\n    for timestamp in timestamps:\n        if timestamp not in df_flux.index:\n            df_flux.loc[timestamp] = np.nan\n    df_flux = df_flux.sort_index()\n\n    # Interpolate nan values\n    df_flux = df_flux['counts'].interpolate(method='nearest', limit_direction='both')\n\n    # Retur only the values for the selected timestamps\n    return df_flux.loc[timestamps]\n</code></pre>"},{"location":"reference/#crnpy.crnpy.latlon_to_utm","title":"<code>latlon_to_utm(lat, lon, utm_zone_number, missing_values=None)</code>","text":"<p>Convert geographic coordinates (lat, lon) to projected coordinates (utm) using the Military Grid Reference System.</p> <p>Function only applies to non-polar coordinates. If further functionality is required, consider using the utm module. See references for more information.</p> <p> UTM zones on an equirectangular world map with irregular zones in red and New York City's zone highlighted. See UTM zones for a full description.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float, array</code> <p>Latitude in decimal degrees.</p> required <code>lon</code> <code>float, array</code> <p>Longitude in decimal degrees.</p> required <code>utm_zone_number</code> <code>int</code> <p>Universal Transverse Mercator (UTM) zone.</p> required <p>Returns:</p> Type Description <code>float, float</code> <p>Tuple of easting and northing coordinates in meters. First element is easting, second is northing.</p> References <p>Code adapted from utm module created by Tobias Bieniek (Github username: Turbo87) https://github.com/Turbo87/utm</p> <p>https://www.maptools.com/tutorials/grid_zone_details#</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def latlon_to_utm(lat, lon, utm_zone_number, missing_values=None):\n\"\"\"Convert geographic coordinates (lat, lon) to projected coordinates (utm) using the Military Grid Reference System.\n\n    Function only applies to non-polar coordinates.\n    If further functionality is required, consider using the utm module. See references for more information.\n\n    ![UTM zones](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/Universal_Transverse_Mercator_zones.svg/1920px-Universal_Transverse_Mercator_zones.svg.png)\n    UTM zones on an equirectangular world map with irregular zones in red and New York City's zone highlighted. See [UTM zones](https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system#UTM_zones) for a full description.\n\n\n    Args:\n        lat (float, array): Latitude in decimal degrees.\n        lon (float, array): Longitude in decimal degrees.\n        utm_zone_number (int): Universal Transverse Mercator (UTM) zone.\n\n    Returns:\n        (float, float): Tuple of easting and northing coordinates in meters. First element is easting, second is northing.\n\n    References:\n         Code adapted from utm module created by Tobias Bieniek (Github username: Turbo87)\n         [https://github.com/Turbo87/utm](https://github.com/Turbo87/utm)\n\n         [https://www.maptools.com/tutorials/grid_zone_details#](https://www.maptools.com/tutorials/grid_zone_details#)\n    \"\"\"\n\n\n    # Define constants\n    R = 6_378_137  # Earth's radius at the Equator in meters\n\n    # Convert input data to Numpy arrays\n    if (type(lat) is not np.ndarray) or (type(lon) is not np.ndarray):\n        try:\n            lat = np.array(lat)\n            lon = np.array(lon)\n        except:\n            raise \"Input values cannot be converted to Numpy arrays.\"\n\n    # Check latitude range\n    if np.any(lat &lt; -80) | np.any(lat &gt; 84):\n        raise \"One or more latitude values exceed the range -80 to 84\"\n\n    # Check longitude range\n    if np.any(lon &lt; -180) | np.any(lon &gt; 180):\n        raise \"One or more longitude values exceed the range -180 to 180\"\n\n    # Constants\n    K0 = 0.9996\n    E = 0.00669438\n    E_P2 = E / (1 - E)\n\n    M1 = (1 - E / 4 - 3 * E ** 2 / 64 - 5 * E ** 3 / 256)\n    M2 = (3 * E / 8 + 3 * E ** 2 / 32 + 45 * E ** 3 / 1024)\n    M3 = (15 * E ** 2 / 256 + 45 * E ** 3 / 1024)\n    M4 = (35 * E ** 3 / 3072)\n\n    # Trigonometric operations\n    lat_rad = np.radians(lat)\n    lon_rad = np.radians(lon)\n\n    lat_sin = np.sin(lat_rad)\n    lat_cos = np.cos(lat_rad)\n    lat_tan = lat_sin / lat_cos\n    lat_tan2 = lat_tan * lat_tan\n    lat_tan4 = lat_tan2 * lat_tan2\n\n    # Find central meridian.\n    central_lon = (utm_zone_number * 6 - 180) - 3  # Zones are every 6 degrees.\n    central_lon_rad = np.radians(central_lon)\n\n    n = R / np.sqrt(1 - E * lat_sin ** 2)\n    c = E_P2 * lat_cos ** 2\n\n    with np.errstate(divide='ignore', invalid='ignore'):\n        a = lat_cos * (np.remainder(((lon_rad - central_lon_rad) + np.pi), (2 * np.pi)) - np.pi)\n    m = R * (M1 * lat_rad - M2 * np.sin(2 * lat_rad) + M3 * np.sin(4 * lat_rad) - M4 * np.sin(6 * lat_rad))\n\n    easting = K0 * n * (a + a ** 3 / 6 * (1 - lat_tan2 + c) + a ** 5 / 120 * (\n                5 - 18 * lat_tan2 + lat_tan4 + 72 * c - 58 * E_P2)) + 500_000\n    northing = K0 * (m + n * lat_tan * (\n                a ** 2 / 2 + a ** 4 / 24 * (5 - lat_tan2 + 9 * c + 4 * c ** 2) + a ** 6 / 720 * (\n                    61 - 58 * lat_tan2 + lat_tan4 + 600 * c - 330 * E_P2)))\n\n    if np.any(lat &lt; 0):\n        northing += 10_000_000\n\n    return easting, northing\n</code></pre>"},{"location":"reference/#crnpy.crnpy.normalize_counts","title":"<code>normalize_counts(counts, count_time=3600, count_times=None)</code>","text":"<p>Normalize neutron counts to the desired counting time.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>pandas.DataFrame</code> <p>Dataframe containing only the columns with neutron counts.</p> required <code>count_time</code> <code>int</code> <p>Count time in seconds for normalization. Default is 3600 seconds.</p> <code>3600</code> <code>count_times</code> <code>pandas.Series or pandas.DataFrame</code> <p>Counting time in seconds. If a DataFrame is provided, it must have the same number of columns as df.</p> <code>None</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>Normalized neutron counts.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def normalize_counts(counts, count_time=3600, count_times=None):\n\"\"\"Normalize neutron counts to the desired counting time.\n\n    Args:\n        counts (pandas.DataFrame): Dataframe containing only the columns with neutron counts.\n        count_time (int): Count time in seconds for normalization. Default is 3600 seconds.\n        count_times (pandas.Series or pandas.DataFrame): Counting time in seconds. If a DataFrame is provided, it must have the same number of columns as df.\n\n    Returns:\n        (pandas.DataFrame): Normalized neutron counts.\n\n    \"\"\"\n\n    if count_times is None and type(counts.index) == pd.core.indexes.datetimes.DatetimeIndex:\n        print(\"No count_times columns provided. Using timestamp index to compute count time.\")\n        count_times = counts.index.to_series().diff().dt.total_seconds()\n\n    if isinstance(count_times, type(None)):\n        raise ValueError('Count time must be provided or index must be a timestamp.')\n\n    if len(counts) != len(count_times):\n        raise ValueError('Count times length does not match number of readings.')\n\n\n    #Normalize counts rounded to integer\n    if type(count_times) == pd.core.series.Series or len(count_times.columns) == 1:\n        normalized_counts = counts.div(count_times, axis=0).mul(count_time).round()\n        return normalized_counts\n    else:\n        normalized_counts = counts.copy()\n        count_times = count_times.copy()\n        for i in range(len(count_times.columns)):\n            normalized_counts[normalized_counts.columns[i]] = normalized_counts.iloc[:,i].div(count_times.iloc[:,i], axis=0).mul(count_time).round()\n        return normalized_counts\n</code></pre>"},{"location":"reference/#crnpy.crnpy.nrad_weight","title":"<code>nrad_weight(h, theta, distances, depth, rhob=1.4)</code>","text":"<p>Function to compute distance weights corresponding to each soil sample.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Air Humidity  from 0.1  to 50 in g/m^3. When h=0, the function will skip the distance weighting.</p> required <code>theta</code> <code>array or pd.Series or pd.DataFrame</code> <p>Soil Moisture for each sample (0.02 - 0.50 m^3/m^3)</p> required <code>distances</code> <code>array or pd.Series or pd.DataFrame</code> <p>Distances from the location of each sample to the origin (0.5 - 600 m)</p> required <code>depth</code> <code>array or pd.Series or pd.DataFrame</code> <p>Depths for each sample (m)</p> required <code>rhob</code> <code>float</code> <p>Bulk density in g/cm^3</p> <code>1.4</code> <p>Returns:</p> Type Description <code>array or pd.Series or pd.DataFrame</code> <p>Distance weights for each sample.</p> References <p>K\u00f6hli, M., Schr\u00f6n, M., Zreda, M., Schmidt, U., Dietrich, P., and Zacharias, S. (2015). Footprint characteristics revised for field-scale soil moisture monitoring with cosmic-ray neutrons. Water Resour. Res. 51, 5772\u20135790. doi:10.1002/2015WR017169</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def nrad_weight(h,theta,distances,depth,rhob=1.4):\n\"\"\"Function to compute distance weights corresponding to each soil sample.\n\n    Args:\n        h (float): Air Humidity  from 0.1  to 50 in g/m^3. When h=0, the function will skip the distance weighting.\n        theta (array or pd.Series or pd.DataFrame): Soil Moisture for each sample (0.02 - 0.50 m^3/m^3)\n        distances (array or pd.Series or pd.DataFrame): Distances from the location of each sample to the origin (0.5 - 600 m)\n        depth (array or pd.Series or pd.DataFrame): Depths for each sample (m)\n        rhob (float): Bulk density in g/cm^3\n\n    Returns:\n        (array or pd.Series or pd.DataFrame): Distance weights for each sample.\n\n    References:\n        K\u00f6hli, M., Schr\u00f6n, M., Zreda, M., Schmidt, U., Dietrich, P., and Zacharias, S. (2015).\n        Footprint characteristics revised for field-scale soil moisture monitoring with cosmic-ray\n        neutrons. Water Resour. Res. 51, 5772\u20135790. doi:10.1002/2015WR017169\n    \"\"\"\n\n    # Table A1. Parameters for Fi and D86\n    p10 = 8735;       p11 = 17.1758; p12 = 11720;      p13 = 0.00978;   p14 = 7045;      p15 = 0.003632;\n    p20 = 2.7925e-2;  p21 = 5.0399;  p22 = 2.8544e-2;  p23 = 0.002455;  p24 = 6.851e-5;  p25 = 9.2926;\n    p30 = 247970;     p31 = 17.63;   p32 = 374655;     p33 = 0.00191;   p34 = 195725;\n    p40 = 5.4818e-2;  p41 = 15.921;  p42 = 0.6373;     p43 = 5.99e-2;   p44 = 5.425e-4;\n    p50 = 1383702;    p51 = 4.156;   p52 = 5325;       p53 = 0.00238;   p54 = 0.0156;    p55 = 0.130;     p56 = 1521;\n    p60 = 6.031e-5;   p61 = 98.5;    p62 = 1.0466e-3;\n    p70 = 11747;      p71 = 41.66;   p72 = 4521;       p73 = 0.01998;   p74 = 0.00604;   p75 = 2534;      p76 = 0.00475;\n    p80 = 1.543e-2;   p81 = 10.06;   p82 = 1.807e-2;   p83 = 0.0011;    p84 = 8.81e-5;   p85 = 0.0405;    p86 = 20.24;\n    p90 = 8.321;      p91 = 0.14249; p92 = 0.96655;    p93 = 26.42;     p94 = 0.0567;\n\n\n    # Numerical determination of the penetration depth (86%) (Eq. 8)\n    D86 = 1/rhob*(p90+p91*(p92+np.exp(-1*distances/100))*(p93+theta)/(p94+theta))\n\n    # Depth weights (Eq. 7)\n    Wd = np.exp(-2*depth/D86)\n\n    if h == 0:\n        W = 1 # skip distance weighting\n\n    elif (h &gt;= 0.1) and (h&lt;= 50):\n        # Functions for Fi (Appendix A in K\u00f6hli et al., 2015)\n        F1 = p10*(1+p13*h)*np.exp(-p11*theta)+p12*(1+p15*h)-p14*theta\n        F2 = ((-p20+p24*h)*np.exp(-p21*theta/(1+p25*theta))+p22)*(1+h*p23)\n        F3 = (p30*(1+p33*h)*np.exp(-p31*theta)+p32-p34*theta)\n        F4 = p40*np.exp(-p41*theta)+p42-p43*theta+p44*h\n        F5 = p50*(0.02-1/p55/(h-p55+p56*theta))*(p54-theta)*np.exp(-p51*(theta-p54))+p52*(0.7-h*theta*p53)\n        F6 = p60*(h+p61)+p62*theta\n        F7 = (p70*(1-p76*h)*np.exp(-p71*theta*(1-h*p74))+p72-p75*theta)*(2+h*p73)\n        F8 = ((-p80+p84*h)*np.exp(-p81*theta/(1+p85*h+p86*theta))+p82)*(2+h*p83)\n\n        # Distance weights (Eq. 3)\n        W = np.ones_like(distances)*np.nan\n        for i in range(len(distances)):\n            if (distances[i]&lt;=50) and (distances[i]&gt;0.5):\n                W[i]=F1[i]*(np.exp(-F2[i]*distances[i]))+F3[i]*np.exp(-F4[i]*distances[i])\n\n            elif (distances[i]&gt;50) and (distances[i]&lt;600):\n                W[i]=F5[i]*(np.exp(-F6[i]*distances[i]))+F7[i]*np.exp(-F8[i]*distances[i])\n\n            else:\n                raise ValueError('Input distances are not valid.')\n\n    else:\n        raise ValueError('Air humidity values are out of range.')\n\n\n    # Combined and normalized weights\n    weights = Wd*W/np.nansum(Wd*W)\n\n    return weights\n</code></pre>"},{"location":"reference/#crnpy.crnpy.road_correction","title":"<code>road_correction(counts, theta_N, road_width, road_distance=0.0, theta_road=0.12, p0=0.42, p1=0.5, p2=1.06, p3=4, p4=0.16, p6=0.94, p7=1.1, p8=2.7, p9=0.01)</code>","text":"<p>Function to correct for road effects in neutron counts. following the approach described in Schr\u00f6n et al., 2018.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>array or pd.Series or pd.DataFrame</code> <p>Array of ephithermal neutron counts.</p> required <code>theta_N</code> <code>float</code> <p>Volumetric water content of the soil estimated from the uncorrected neutron counts.</p> required <code>road_width</code> <code>float</code> <p>Width of the road in m.</p> required <code>road_distance</code> <code>float</code> <p>Distance of the road from the sensor in m. Default is 0.0.</p> <code>0.0</code> <code>theta_road</code> <code>float</code> <p>Volumetric water content of the road. Default is 0.12.</p> <code>0.12</code> <code>p0-p9</code> <code>float</code> <p>Parameters of the correction function. Default values are from Schr\u00f6n et al., 2018.</p> required <p>Returns:</p> Type Description <code>array or pd.Series or pd.DataFrame</code> <p>Array of corrected neutron counts for road effects.</p> References <p>Schr\u00f6n,M.,Rosolem,R.,K\u00f6hli,M., Piussi,L.,Schr\u00f6ter,I.,Iwema,J.,etal. (2018).Cosmic-ray neutron rover surveys of field soil moisture and the influence of roads.WaterResources Research,54,6441\u20136459. https://doi. org/10.1029/2017WR021719</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def road_correction(counts, theta_N, road_width, road_distance=0.0, theta_road=0.12, p0=0.42, p1=0.5, p2=1.06, p3=4, p4=0.16, p6=0.94, p7=1.10, p8=2.70, p9=0.01):\n\"\"\"Function to correct for road effects in neutron counts.\n    following the approach described in Schr\u00f6n et al., 2018.\n\n    Args:\n        counts (array or pd.Series or pd.DataFrame): Array of ephithermal neutron counts.\n        theta_N (float): Volumetric water content of the soil estimated from the uncorrected neutron counts.\n        road_width (float): Width of the road in m.\n        road_distance (float): Distance of the road from the sensor in m. Default is 0.0.\n        theta_road (float): Volumetric water content of the road. Default is 0.12.\n        p0-p9 (float): Parameters of the correction function. Default values are from Schr\u00f6n et al., 2018.\n\n    Returns:\n        (array or pd.Series or pd.DataFrame): Array of corrected neutron counts for road effects.\n\n    References:\n        Schr\u00f6n,M.,Rosolem,R.,K\u00f6hli,M., Piussi,L.,Schr\u00f6ter,I.,Iwema,J.,etal. (2018).Cosmic-ray neutron rover surveys\n        of field soil moisture and the influence of roads.WaterResources Research,54,6441\u20136459.\n        https://doi. org/10.1029/2017WR021719\n    \"\"\"\n    F1 = p0 * (1-np.exp(-p1*road_width))\n    F2 = -p2 - p3 * theta_road - ((p4 + theta_road) / (theta_N))\n    F3 = p6 * np.exp(-p7 * (road_width ** -p8) * road_distance ** 4) + (1 - p6) * np.exp(-p9 * road_distance)\n\n    C_roads = 1 + F1 * F2 * F3\n\n    corrected_counts = counts / C_roads\n\n    return corrected_counts\n</code></pre>"},{"location":"reference/#crnpy.crnpy.sensing_depth","title":"<code>sensing_depth(vwc, pressure, p_ref, bulk_density, Wlat, dist, method='Schron_2017')</code>","text":"<p>Function that computes the estimated sensing depth of the cosmic-ray neutron probe. The function offers several methods to compute the depth at which 86 % of the neutrons probes the soil profile.</p> <p>Parameters:</p> Name Type Description Default <code>vwc</code> <code>array or pd.Series or pd.DataFrame</code> <p>Estimated volumetric water content for each timestamp.</p> required <code>pressure</code> <code>array or pd.Series or pd.DataFrame</code> <p>Atmospheric pressure in hPa for each timestamp.</p> required <code>p_ref</code> <code>float</code> <p>Reference pressure in hPa.</p> required <code>bulk_density</code> <code>float</code> <p>Soil bulk density.</p> required <code>Wlat</code> <code>float</code> <p>Lattice water content.</p> required <code>method</code> <code>str</code> <p>Method to compute the sensing depth. Options are 'Schron_2017' or 'Franz_2012'.</p> <code>'Schron_2017'</code> <code>dist</code> <code>list or array</code> <p>List of radial distances at which to estimate the sensing depth. Only used for the 'Schron_2017' method.</p> required <p>Returns:</p> Type Description <code>array or pd.Series or pd.DataFrame</code> <p>Estimated sensing depth in m.</p> References <p>Franz, T.E., Zreda, M., Ferre, T.P.A., Rosolem, R., Zweck, C., Stillman, S., Zeng, X. and Shuttleworth, W.J., 2012. Measurement depth of the cosmic ray soil moisture probe affected by hydrogen from various sources. Water Resources Research, 48(8). doi.org/10.1029/2012WR011871</p> <p>Schr\u00f6n, M., K\u00f6hli, M., Scheiffele, L., Iwema, J., Bogena, H. R., Lv, L., et al. (2017). Improving calibration and validation of cosmic-ray neutron sensors in the light of spatial sensitivity. Hydrol. Earth Syst. Sci. 21, 5009\u20135030. doi.org/10.5194/hess-21-5009-2017</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def sensing_depth(vwc, pressure, p_ref, bulk_density, Wlat, dist, method='Schron_2017'):\n    # Convert docstring to google format\n\"\"\"Function that computes the estimated sensing depth of the cosmic-ray neutron probe.\n    The function offers several methods to compute the depth at which 86 % of the neutrons\n    probes the soil profile.\n\n    Args:\n        vwc (array or pd.Series or pd.DataFrame): Estimated volumetric water content for each timestamp.\n        pressure (array or pd.Series or pd.DataFrame): Atmospheric pressure in hPa for each timestamp.\n        p_ref (float): Reference pressure in hPa.\n        bulk_density (float): Soil bulk density.\n        Wlat (float): Lattice water content.\n        method (str): Method to compute the sensing depth. Options are 'Schron_2017' or 'Franz_2012'.\n        dist (list or array): List of radial distances at which to estimate the sensing depth. Only used for the 'Schron_2017' method.\n\n    Returns:\n        (array or pd.Series or pd.DataFrame): Estimated sensing depth in m.\n\n    References:\n        Franz, T.E., Zreda, M., Ferre, T.P.A., Rosolem, R., Zweck, C., Stillman, S., Zeng, X. and Shuttleworth, W.J., 2012.\n        Measurement depth of the cosmic ray soil moisture probe affected by hydrogen from various sources.\n        Water Resources Research, 48(8). doi.org/10.1029/2012WR011871\n\n        Schr\u00f6n, M., K\u00f6hli, M., Scheiffele, L., Iwema, J., Bogena, H. R., Lv, L., et al. (2017).\n        Improving calibration and validation of cosmic-ray neutron sensors in the light of spatial sensitivity.\n        Hydrol. Earth Syst. Sci. 21, 5009\u20135030. doi.org/10.5194/hess-21-5009-2017\n    \"\"\"\n\n    # Determine sensing depth (D86)\n    if method == 'Schron_2017':\n\n        # See Appendix A of Schr\u00f6n et al. (2017)\n        Fp = 0.4922 / (0.86 - np.exp(-1 * pressure / p_ref));\n        Fveg = 0\n        results = []\n        for d in dist:\n            # Compute r_star\n            r_start = d/Fp\n\n            # Compute soil depth that accounts for 86% of the neutron flux\n            D86 = 1/ bulk_density * (8.321+0.14249*(0.96655 + np.exp(-0.01*r_start))*(20+(Wlat+vwc)) / (0.0429+(Wlat+vwc)))\n            results.append(D86)\n\n    elif method == 'Franz_2012':\n        results = [5.8/(bulk_density*Wlat+vwc+0.0829)]\n\n    return results\n</code></pre>"},{"location":"reference/#crnpy.crnpy.smooth_1D","title":"<code>smooth_1D(corrected_counts, window=5, order=3, method='moving_median')</code>","text":"<p>Use a Savitzky-Golay filter to smooth the signal of corrected neutron counts or another one-dimensional array (e.g. computed volumetric water content).</p> <p>Parameters:</p> Name Type Description Default <code>corrected_counts</code> <code>pd.DataFrame</code> <p>Dataframe containing the corrected neutron counts.</p> required <code>window</code> <code>int</code> <p>Window size for the Savitzky-Golay filter. Default is 5.</p> <code>5</code> <code>method</code> <code>str</code> <p>Method to use for smoothing the data. Default is 'moving_median'. Options are 'moving_average', 'moving_median' and 'savitzky_golay'.</p> <code>'moving_median'</code> <code>order</code> <code>int</code> <p>Order of the Savitzky-Golay filter. Default is 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>DataFrame with smoothed neutron counts.</p> References <p>Franz, T.E., Wahbi, A., Zhang, J., Vreugdenhil, M., Heng, L., Dercon, G., Strauss, P., Brocca, L. and Wagner, W., 2020. Practical data products from cosmic-ray neutron sensing for hydrological applications. Frontiers in Water, 2, p.9. doi.org/10.3389/frwa.2020.00009</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def smooth_1D(corrected_counts,window=5,order=3, method='moving_median'):\n\"\"\"Use a Savitzky-Golay filter to smooth the signal of corrected neutron counts or another one-dimensional array (e.g. computed volumetric water content).\n\n    Args:\n        corrected_counts (pd.DataFrame): Dataframe containing the corrected neutron counts.\n        window (int): Window size for the Savitzky-Golay filter. Default is 5.\n        method (str): Method to use for smoothing the data. Default is 'moving_median'.\n            Options are 'moving_average', 'moving_median' and 'savitzky_golay'.\n        order (int): Order of the Savitzky-Golay filter. Default is 3.\n\n    Returns:\n        (pd.DataFrame): DataFrame with smoothed neutron counts.\n\n    References:\n        Franz, T.E., Wahbi, A., Zhang, J., Vreugdenhil, M., Heng, L., Dercon, G., Strauss, P., Brocca, L. and Wagner, W., 2020.\n        Practical data products from cosmic-ray neutron sensing for hydrological applications. Frontiers in Water, 2, p.9.\n        doi.org/10.3389/frwa.2020.00009\n    \"\"\"\n\n    if method == 'moving_average':\n        corrected_counts = corrected_counts.rolling(window=window, center=True, min_periods=1).mean()\n    elif method == 'moving_median':\n        corrected_counts = corrected_counts.rolling(window=window, center=True, min_periods=1).median()\n\n    elif method == 'savitzky_golay':\n        if corrected_counts.isna().any():\n            print('Dataframe contains NaN values. Please remove NaN values before smoothing the data.')\n\n        if type(corrected_counts) == pd.core.series.Series:\n            filtered = np.round(savgol_filter(corrected_counts,window,order))\n            corrected_counts = pd.DataFrame(filtered,columns=['counts'], index=corrected_counts.index)\n        elif type(corrected_counts) == pd.core.frame.DataFrame:\n            for col in corrected_counts.columns:\n                corrected_counts[col] = np.round(savgol_filter(corrected_counts[col],window,order))\n    else:\n        raise ValueError('Invalid method. Please select a valid filtering method., options are: moving_average, moving_median, savitzky_golay')\n    corrected_counts = corrected_counts.ffill(limit=window).bfill(limit=window).copy()\n    return corrected_counts\n</code></pre>"},{"location":"reference/#crnpy.crnpy.smooth_2D","title":"<code>smooth_2D(x, y, z, buffer=100, min_neighbours=3, method='mean', rnd=False)</code>","text":"<p>Moving buffer filter to smooth georeferenced two-dimensional data.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list or array</code> <p>UTM x coordinates in meters.</p> required <code>y</code> <code>list or array</code> <p>UTM y coordinates in meters.</p> required <code>z</code> <code>list or array</code> <p>Values to be smoothed.</p> required <code>buffer</code> <code>float</code> <p>Radial buffer distance in meters.</p> <code>100</code> <code>min_neighbours</code> <code>int</code> <p>Minimum number of neighbours to consider for the smoothing.</p> <code>3</code> <code>method</code> <code>str</code> <p>One of 'mean' or 'median'.</p> <code>'mean'</code> <code>rnd</code> <code>bool</code> <p>Boolean to round the final result. Useful in case of z representing neutron counts.</p> <code>False</code> <p>Returns:</p> Type Description <code>array</code> <p>Smoothed version of z with the same dimension as z.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def smooth_2D(x, y, z, buffer=100, min_neighbours=3, method='mean', rnd=False):\n\"\"\"Moving buffer filter to smooth georeferenced two-dimensional data.\n\n    Args:\n        x (list or array): UTM x coordinates in meters.\n        y (list or array): UTM y coordinates in meters.\n        z (list or array): Values to be smoothed.\n        buffer (float): Radial buffer distance in meters.\n        min_neighbours (int): Minimum number of neighbours to consider for the smoothing.\n        method (str): One of 'mean' or 'median'.\n        rnd (bool): Boolean to round the final result. Useful in case of z representing neutron counts.\n\n    Returns:\n        (array): Smoothed version of z with the same dimension as z.\n    \"\"\"\n\n    # Convert input data to Numpy arrays\n    if (type(x) is not np.ndarray) or (type(y) is not np.ndarray):\n        try:\n            x = np.array(x)\n            y = np.array(y)\n        except:\n            raise \"Input values cannot be converted to Numpy arrays.\"\n\n    if len(x) != len(y):\n        raise f\"The number of x and y must be equal. Input x has {len(x)} values and y has {len(y)} values.\"\n\n    # Compute distances\n    N = len(x)\n    z_smooth = np.array([])\n    for k in range(N):\n        px = x[k]\n        py = y[k]\n\n        distances = euclidean_distance(px, py, x, y)\n        idx_within_buffer = distances &lt;= buffer\n\n\n        if np.isnan(z[k]):\n            z_new_val = np.nan\n        elif len(distances[idx_within_buffer]) &gt; min_neighbours:\n            if method == 'mean':\n                z_new_val = np.nanmean(z[idx_within_buffer])\n            elif method == 'median':\n                z_new_val = np.nanmedian(z[idx_within_buffer])\n            else:\n                raise f\"Method {method} does not exist. Provide either 'mean' or 'median'.\"\n        else:\n            z_new_val = z[k] # If there are not enough neighbours, keep the original value\n\n        # Append smoothed value to array\n        z_smooth = np.append(z_smooth, z_new_val)\n\n    if rnd:\n        z_smooth = np.round(z_smooth, 0)\n\n    return z_smooth\n</code></pre>"},{"location":"reference/#crnpy.crnpy.storage","title":"<code>storage(sm, T=1, Z_surface=150, Z_subsurface=1000)</code>","text":"<p>Exponential filter to estimate soil moisture in the rootzone from surface observtions.</p> <p>Parameters:</p> Name Type Description Default <code>sm</code> <code>list or array</code> <p>Soil moisture in mm of water.</p> required <code>T</code> <code>float</code> <p>Characteristic time length in the same units as the measurement interval.</p> <code>1</code> <code>Z_surface</code> <code>float</code> <p>Depth of surface layer in mm. This should be an intermediate value according to the sensing depth computed using the D86 method.</p> <code>150</code> <code>Z_subsurface</code> <code>float</code> <p>Depth of subsurface layer in mm.</p> <code>1000</code> <p>Returns:</p> Type Description <code>tuple</code> <p>tuple containing: - Surface soil water storage (array): Surface soil water storage in mm of water. - Subsurface soil water storage (array): Subsurface soil water storage in mm of water.</p> References <p>Albergel, C., R\u00fcdiger, C., Pellarin, T., Calvet, J.C., Fritz, N., Froissard, F., Suquia, D., Petitpa, A., Piguet, B. and Martin, E., 2008. From near-surface to root-zone soil moisture using an exponential filter: an assessment of the method based on in-situ observations and model simulations. Hydrology and Earth System Sciences, 12(6), pp.1323-1337.</p> <p>Franz, T.E., Wahbi, A., Zhang, J., Vreugdenhil, M., Heng, L., Dercon, G., Strauss, P., Brocca, L. and Wagner, W., 2020. Practical data products from cosmic-ray neutron sensing for hydrological applications. Frontiers in Water, 2, p.9.</p> <p>Rossini, P. and Patrignani, A., 2021. Predicting rootzone soil moisture from surface observations in cropland using an exponential filter. Soil Science Society of America Journal.</p> Source code in <code>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py</code> <pre><code>def storage(sm,T=1,Z_surface=150,Z_subsurface=1000):\n\"\"\"Exponential filter to estimate soil moisture in the rootzone from surface observtions.\n\n    Args:\n        sm (list or array): Soil moisture in mm of water.\n        T (float): Characteristic time length in the same units as the measurement interval.\n        Z_surface (float): Depth of surface layer in mm. This should be an intermediate value according to the\n            sensing depth computed using the D86 method.\n        Z_subsurface (float): Depth of subsurface layer in mm.\n\n    Returns:\n        (tuple): tuple containing:\n            - **Surface soil water storage** (*array*): Surface soil water storage in mm of water.\n            - **Subsurface soil water storage** (*array*): Subsurface soil water storage in mm of water.\n\n    References:\n        Albergel, C., R\u00fcdiger, C., Pellarin, T., Calvet, J.C., Fritz, N., Froissard, F., Suquia, D., Petitpa, A., Piguet, B. and Martin, E., 2008.\n        From near-surface to root-zone soil moisture using an exponential filter: an assessment of the method based on in-situ observations and model\n        simulations. Hydrology and Earth System Sciences, 12(6), pp.1323-1337.\n\n        Franz, T.E., Wahbi, A., Zhang, J., Vreugdenhil, M., Heng, L., Dercon, G., Strauss, P., Brocca, L. and Wagner, W., 2020.\n        Practical data products from cosmic-ray neutron sensing for hydrological applications. Frontiers in Water, 2, p.9.\n\n        Rossini, P. and Patrignani, A., 2021. Predicting rootzone soil moisture from surface observations in cropland using an exponential filter.\n        Soil Science Society of America Journal.\n    \"\"\"\n\n    # Parameters\n    t_delta = 1\n    sm_min = np.min(sm)\n    sm_max = np.max(sm)\n    ms = (sm-sm_min)/(sm_max-sm_min)\n\n    # Pre-allocate soil water index array\n    SWI = np.ones_like(ms)*np.nan\n    K = np.ones_like(ms)*np.nan\n\n    # Initial conditions\n    SWI[0] = ms[0]\n    K[0] = 1\n\n    # Values from 2 to N\n    for n in range(1,len(SWI)):\n        if ~np.isnan(ms[n]) &amp; ~np.isnan(ms[n-1]):\n            K[n] = K[n-1] / (K[n-1] + np.exp(-t_delta/T))\n            SWI[n] = SWI[n-1] + K[n]*(ms[n] - SWI[n-1])\n        else:\n            continue\n\n    # Surface storage\n    storage_surface = sm*Z_surface\n\n    # Rootzone storage\n    storage_subsurface = (SWI*(sm_max-sm_min) + sm_min)*Z_subsurface\n\n    return storage_surface, storage_subsurface\n</code></pre>"},{"location":"reference/#crnpy.data--crnpydata","title":"crnpy.data","text":"<p>Data module for crnpy.</p> <p>This module contains data for the crnpy package.</p> <p>Attributes:</p> Name Type Description <code>cutoff_rigidity</code> <code>list</code> <p>Cutoff rigidity values for the whole world. See crnpy.crnpy.cutoff_rigidity</p> <code>neutron_detectors</code> <code>list</code> <p>Neutron detector locations. See crnpy.crnpy.find_neutron_detectors</p>"},{"location":"examples/overview/","title":"CRNPy Examples Overview","text":"<p>The examples demonstrate how to process and analyze neutron detection data from various detectors.</p> <p>Download the source code for the notebooks and demo datasets from the CRNPy GitHub repository.</p>"},{"location":"examples/overview/#stationary-example-rdt-station","title":"Stationary example: RDT Station","text":""},{"location":"examples/overview/#rover-example-hydroinnova-rover","title":"Rover example: Hydroinnova Rover","text":""},{"location":"examples/overview/#device-calibration-example","title":"Device calibration example","text":""},{"location":"examples/calibration/calibration/","title":"CRNP field calibration of N0 device-specific parameter.","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport numpy as np\nfrom crnpy import crnpy\n\ndf_soil = pd.read_csv(\"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/calibration/soil_data.csv\")\ndf_soil.head()\n</pre> import pandas as pd import numpy as np from crnpy import crnpy  df_soil = pd.read_csv(\"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/calibration/soil_data.csv\") df_soil.head() Out[1]: field date core_number distance_from_station latitude longitude top_depth bottom_depth core_diameter wet_mass_with_bag ... can_number mass_empty_can wet_mass_with_can dry_mass_with_can mass_water theta_g volume bulk_density theta_v Observation 0 Flickner 22-Oct 1 5 N38.23459 W97.57101 0 5 30.49 45.31 ... 1 52.10 92.03 85.31 6.72 0.202 36.514864 0.909 0.184403 NaN 1 Flickner 22-Oct 1 5 N38.23459 W97.57101 5 10 30.49 69.53 ... 2 51.85 115.97 103.85 12.12 0.233 36.514864 1.424 0.332585 NaN 2 Flickner 22-Oct 1 5 N38.23459 W97.57101 10 25 30.49 214.90 ... 3 51.56 260.97 219.77 41.20 0.245 109.544592 1.536 0.376856 NaN 3 Flickner 22-Oct 1 5 N38.23459 W97.57101 25 40 30.49 217.52 ... 4 52.35 264.46 222.23 42.23 0.249 109.544592 1.551 0.386278 NaN 4 Flickner 22-Oct 2 5 N38.23464 W97.57101 0 5 30.49 45.92 ... 5 52.15 92.59 85.93 6.66 0.197 36.514864 0.925 0.182757 NaN <p>5 rows \u00d7 21 columns</p> <p>Loading station data is necessary to calculate the absolute humidty from temperature an relative humidity data with <code>estimate_abs_humidity()</code>.</p> In\u00a0[2]: Copied! <pre>df_station = pd.read_csv(\"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/calibration/station_data.csv\", skiprows=[0,2,3])\n\n#  Parse dates\ndf_station['TIMESTAMP'] = pd.to_datetime(df_station['TIMESTAMP'])\n\n# Filter data matching the sampling date\ndf_station_calib = df_station[(df_station['TIMESTAMP'] &gt; pd.to_datetime(\"2021-10-22 08:00\")) &amp; (df_station['TIMESTAMP'] &lt; pd.to_datetime(\"2021-10-22 16:00\"))].copy()\ndf_station_calib['abs_h'] = crnpy.estimate_abs_humidity(df_station_calib['relative_humidity_Avg'], df_station_calib['air_temperature_Avg'])\nnrad_weights = crnpy.nrad_weight(df_station_calib['abs_h'].mean(), df_soil['theta_v'], df_soil['distance_from_station'], (df_soil['bottom_depth']+df_soil['top_depth'])/2, rhob=df_soil['bulk_density'])\n\nfield_theta_v = np.sum(df_soil['theta_v']*nrad_weights)\nfield_bulk_density = np.sum(df_soil['bulk_density']*nrad_weights)\nprint(f\"Field Volumetric Water content: {round(field_theta_v,3)}\")\n</pre> df_station = pd.read_csv(\"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/calibration/station_data.csv\", skiprows=[0,2,3])  #  Parse dates df_station['TIMESTAMP'] = pd.to_datetime(df_station['TIMESTAMP'])  # Filter data matching the sampling date df_station_calib = df_station[(df_station['TIMESTAMP'] &gt; pd.to_datetime(\"2021-10-22 08:00\")) &amp; (df_station['TIMESTAMP'] &lt; pd.to_datetime(\"2021-10-22 16:00\"))].copy() df_station_calib['abs_h'] = crnpy.estimate_abs_humidity(df_station_calib['relative_humidity_Avg'], df_station_calib['air_temperature_Avg']) nrad_weights = crnpy.nrad_weight(df_station_calib['abs_h'].mean(), df_soil['theta_v'], df_soil['distance_from_station'], (df_soil['bottom_depth']+df_soil['top_depth'])/2, rhob=df_soil['bulk_density'])  field_theta_v = np.sum(df_soil['theta_v']*nrad_weights) field_bulk_density = np.sum(df_soil['bulk_density']*nrad_weights) print(f\"Field Volumetric Water content: {round(field_theta_v,3)}\") <pre>Field Volumetric Water content: 0.256\n</pre> In\u00a0[3]: Copied! <pre>df = df_station_calib.copy()\n# Set timestamp as index\ndf.set_index(df['TIMESTAMP'], inplace=True)\ndf.head()\n</pre> df = df_station_calib.copy() # Set timestamp as index df.set_index(df['TIMESTAMP'], inplace=True) df.head() Out[3]: TIMESTAMP RECORD station farm field latitude longitude altitude battery_voltage_Min PTemp_Avg ... wind_speed_gust_Max air_temperature_Avg vapor_pressure_Avg barometric_pressure_Avg relative_humidity_Avg humidity_sensor_temperature_Avg tilt_north_south_Avg tilt_west_east_Avg NDVI_Avg abs_h TIMESTAMP 2021-10-22 09:00:00 2021-10-22 09:00:00 706 KS003 Flickner Rainfed South 38.23461 -97.57095 455 13.77 17.33 ... 8.17 11.68 10.18 965 73.95 13.38 -0.775 0.975 0.26 7.719789 2021-10-22 10:00:00 2021-10-22 10:00:00 707 KS003 Flickner Rainfed South 38.23461 -97.57095 455 13.66 22.37 ... 7.58 15.10 10.98 964 64.33 17.40 -0.775 1.250 0.266 8.293183 2021-10-22 11:00:00 2021-10-22 11:00:00 708 KS003 Flickner Rainfed South 38.23461 -97.57095 455 13.60 25.88 ... 8.05 18.30 10.98 964 52.10 21.20 -0.850 1.150 0.265 8.140162 2021-10-22 12:00:00 2021-10-22 12:00:00 709 KS003 Flickner Rainfed South 38.23461 -97.57095 455 13.58 27.63 ... 8.10 20.75 10.85 963 44.40 23.80 -0.800 1.000 0.262 8.010780 2021-10-22 13:00:00 2021-10-22 13:00:00 710 KS003 Flickner Rainfed South 38.23461 -97.57095 455 13.59 27.94 ... 10.00 21.83 11.10 962 42.25 24.93 -1.575 1.650 0.256 8.114954 <p>5 rows \u00d7 28 columns</p> In\u00a0[4]: Copied! <pre>df['total_counts'] = crnpy.compute_total_raw_counts(df[['counts_1_Tot','counts_2_Tot']], nan_strategy='average')\n</pre> df['total_counts'] = crnpy.compute_total_raw_counts(df[['counts_1_Tot','counts_2_Tot']], nan_strategy='average') In\u00a0[5]: Copied! <pre># Find stations with cutoff rigidity similar to estimated by lat,lon, \n# filtering the time window from experiment setup to the end of the calibration\ncrnpy.find_neutron_detectors(crnpy.cutoff_rigidity(39.1, -96.6), start_date = df_station['TIMESTAMP'].iloc[0], end_date = df['TIMESTAMP'].iloc[-1])\n\n#Download data for one of the similar stations and add to df\nincoming_neutrons = crnpy.get_incoming_neutron_flux(df_station['TIMESTAMP'].iloc[0], df['TIMESTAMP'].iloc[-1], station=\"DRBS\", utc_offset=-5)\ndf['incoming_flux']=crnpy.interpolate_incoming_flux(incoming_neutrons, timestamps=df['TIMESTAMP'])\nref_incoming_flux = incoming_neutrons.iloc[0]\n</pre> # Find stations with cutoff rigidity similar to estimated by lat,lon,  # filtering the time window from experiment setup to the end of the calibration crnpy.find_neutron_detectors(crnpy.cutoff_rigidity(39.1, -96.6), start_date = df_station['TIMESTAMP'].iloc[0], end_date = df['TIMESTAMP'].iloc[-1])  #Download data for one of the similar stations and add to df incoming_neutrons = crnpy.get_incoming_neutron_flux(df_station['TIMESTAMP'].iloc[0], df['TIMESTAMP'].iloc[-1], station=\"DRBS\", utc_offset=-5) df['incoming_flux']=crnpy.interpolate_incoming_flux(incoming_neutrons, timestamps=df['TIMESTAMP']) ref_incoming_flux = incoming_neutrons.iloc[0] <pre>\nSelect a station with an altitude similar to that of your location. For more information go to: 'https://www.nmdb.eu/nest/help.php#helpstations\n\nYour cutoff rigidity is 2.87 GV\n     STID     NAME     R  Altitude_m  Period available\n13   DRBS  Dourbes  3.18         225              True\n40   NEWK   Newark  2.40          50              True\n28  KIEL2   KielRT  2.36          54              True\n</pre> In\u00a0[6]: Copied! <pre># Fill NaN values in atmospheric data\ndf[['pressure', 'RH', 'T']] = crnpy.fill_missing_atm(df[['barometric_pressure_Avg', 'relative_humidity_Avg', 'air_temperature_Avg']])\n# Correct count by atmospheric variables and incoming flux\ndf['total_counts']=crnpy.fill_counts(df['total_counts'])\ndf['corrected']=crnpy.atm_correction(df['total_counts'], pressure=df['pressure'], humidity=df['RH'], temp=df['T'], Pref=976, Aref=0, L=130, incoming_neutrons=df['incoming_flux'], incoming_Ref = ref_incoming_flux).dropna()\n</pre> # Fill NaN values in atmospheric data df[['pressure', 'RH', 'T']] = crnpy.fill_missing_atm(df[['barometric_pressure_Avg', 'relative_humidity_Avg', 'air_temperature_Avg']]) # Correct count by atmospheric variables and incoming flux df['total_counts']=crnpy.fill_counts(df['total_counts']) df['corrected']=crnpy.atm_correction(df['total_counts'], pressure=df['pressure'], humidity=df['RH'], temp=df['T'], Pref=976, Aref=0, L=130, incoming_neutrons=df['incoming_flux'], incoming_Ref = ref_incoming_flux).dropna() <pre>No count time columns provided. Using timestamp index to compute count time.\nUsing median count time as expected count time: 3600.0\n</pre> In\u00a0[7]: Copied! <pre>print(f\"Mean corrected neutron count during sampling: {df['corrected'].mean().round()}\")\n</pre> print(f\"Mean corrected neutron count during sampling: {df['corrected'].mean().round()}\") <pre>Mean corrected neutron count during sampling: 1540.0\n</pre> In\u00a0[8]: Copied! <pre>from scipy.optimize import root\n\n# Define the function for which we want to find the roots\ndef func(N0):\n    return crnpy.counts_to_vwc(df['corrected'].mean(), N0, bulk_density=field_bulk_density, Wlat=0.03, Wsoc=0.01) - field_theta_v\n\n# Make an initial guess for N0\nN0_initial_guess = 1000\n\n# Find the root\nsol = root(func, N0_initial_guess)\n\n# Print the solution\nprint(f\"The solved value for N0 is: {sol.x.round()}\")\n</pre> from scipy.optimize import root  # Define the function for which we want to find the roots def func(N0):     return crnpy.counts_to_vwc(df['corrected'].mean(), N0, bulk_density=field_bulk_density, Wlat=0.03, Wsoc=0.01) - field_theta_v  # Make an initial guess for N0 N0_initial_guess = 1000  # Find the root sol = root(func, N0_initial_guess)  # Print the solution print(f\"The solved value for N0 is: {sol.x.round()}\") <pre>The solved value for N0 is: [2637.]\n</pre>"},{"location":"examples/calibration/calibration/#crnp-field-calibration-of-n0-device-specific-parameter","title":"CRNP field calibration of N0 device-specific parameter.\u00b6","text":""},{"location":"examples/calibration/calibration/#n_0-parameter-calibration","title":"$N_0$ Parameter Calibration\u00b6","text":"<p>The calibration of a Cosmic-Ray Neutron Probe (CRNP) is an essential step to ensure accurate soil moisture measurements. The CRNP operates by counting fast neutrons produced from cosmic rays, which are predominantly moderated by water molecules in the soil. The parameter $N_0$ is a device-specific constant that signifies the neutron count rate under zero soil moisture conditions.</p> <p>$\\theta(N) =\\frac{a_0}{(\\frac{N}{N_0}) - a_1} - a_2 $ (Desilets et al., 2010).</p>"},{"location":"examples/calibration/calibration/#determining-field-soil-moisture","title":"Determining field soil moisture\u00b6","text":""},{"location":"examples/calibration/calibration/#soil-sampling-layout","title":"Soil sampling layout\u00b6","text":"<p>14 cores were collected from different distances. In this example each soil sample was split into four depth segments: 0-5 cm, 5-10 cm, 10-25 cm, and 25-40 cm. Soil samples were processed and soil moisture was determined using the thermo-gravimetric method.</p> <p>Figure 1. Horizontal layout and vertical layout used in this particular example calibration, it can be customized by the user depending on their needs.</p>"},{"location":"examples/calibration/calibration/#template-for-data-collection","title":"Template for data collection\u00b6","text":"<p>Download the following template spreadsheet for collecting soil samples data:</p>"},{"location":"examples/calibration/calibration/#sample-processing","title":"Sample processing\u00b6","text":"<p>For each sample it is required to know the bulk density ($\\rho_\\beta$) and the volumetric water content ($\\theta_v$). See the details of the calculation used in the filled example.</p>"},{"location":"examples/calibration/calibration/#field-average","title":"Field average\u00b6","text":"<p>Load the soil samples data using pandas, and using the function <code>nrad_weight()</code> the weights corresponding to each soil sample will be computed considering air-humidity, sample depth, distance from station and bulk density.</p>"},{"location":"examples/calibration/calibration/#neutron-count-processing","title":"Neutron count processing\u00b6","text":"<p>Following the example for processing CRNP data from RDT detectors neutron counts recorded while the field sampling was done need to be corrected.</p> <p>This dataset contains the raw counts and atmospheric data recorded by the CRNP while the field sampling was done.</p>"},{"location":"examples/calibration/calibration/#computing-total-neutron-counts","title":"Computing total neutron counts\u00b6","text":""},{"location":"examples/calibration/calibration/#incomming-neutron-flux","title":"Incomming neutron flux\u00b6","text":"<p>Download the neutron flux for all the experiment, setting the reference value as the value when the station was deployed.</p>"},{"location":"examples/calibration/calibration/#atmospheric-correction","title":"Atmospheric correction\u00b6","text":"<p>The atmospheric correction factors will correct neutron counts for atmospheric pressure and absolute humidity changes.</p>"},{"location":"examples/calibration/calibration/#solving-the-equation-for-n_0","title":"Solving the equation for $N_0$\u00b6","text":"<p>Previous steps estimated the a field volumetric water content of <code>0.256</code> and an average neutron count of <code>1540</code>. Using scipy.optimize.root() $N_0$ is estimated given the observed value of $\\theta_v$ and neutron counts.</p>"},{"location":"examples/calibration/calibration/#references","title":"References:\u00b6","text":"<p>Desilets, D., Zreda, M., &amp; Ferr\u00e9, T. P. (2010). Nature's neutron probe: Land surface hydrology at an elusive scale with cosmic rays. Water Resources Research, 46(11).</p> <p>Dong, J., &amp; Ochsner, T. E. (2018). Soil texture often exerts a stronger influence than precipitation on mesoscale soil moisture patterns. Water Resources Research, 54(3), 2199-2211.</p> <p>Patrignani, A., Ochsner, T. E., Montag, B., &amp; Bellinger, S. (2021). A novel lithium foil cosmic-ray neutron detector for measuring field-scale soil moisture. Frontiers in Water, 3, 673185.</p>"},{"location":"examples/rover/Hydroinnova_rover_example-Copy1/","title":"Processing and Analyzing Hydroinnova Rover Data with CRNPy","text":"In\u00a0[1]: Copied! <pre># Import modules\nimport numpy as np\nimport pandas as pd\nfrom crnpy import crnpy\nimport matplotlib.pyplot as plt\n</pre> # Import modules import numpy as np import pandas as pd from crnpy import crnpy import matplotlib.pyplot as plt   <p>Load the data stored in the .csv file.</p> In\u00a0[2]: Copied! <pre># Sample dataset\ncol_names = 'RecordNum,Date Time(UTC),PTB110_mb,P4_mb,P1_mb,T1_C,RH1,T_CS215,RH_CS215,Vbat,N1Cts,N2Cts,N3Cts,N4Cts,N5Cts,N6Cts,N7Cts,N8Cts,N1ETsec,N3ETsec,N5ETsec,N7ETsec,N1T(C),N1RH,N5T(C),N5RH,GpsUTC,LatDec,LongDec,Alt,Qual,NumSats,HDOP,Speed_kmh,COG,SpeedQuality,strDate'.split(',')\ndf = pd.read_csv('https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/rover/gypsum_transect_01_may_2018.KSU', skiprows=20, names=col_names)\ndf['LongDec'] = df['LongDec'] * -1 # Raw data is in absolute values\n\n# Parse timestamps and set as index\ndf['timestamp'] = pd.to_datetime(df['Date Time(UTC)'])\ndf.set_index(df['timestamp'], inplace=True)\n\n# Remove rows with missing coordinates\ndf['LatDec'].replace(0.0, np.nan, inplace=True)\ndf['LongDec'].replace(0.0, np.nan, inplace=True)\ndf.dropna(axis=0, subset=['LatDec','LongDec'], inplace=True)\ndf.reset_index(drop=True, inplace=True)\n\n# Display a few rows to visualize dataset\ndf.head(3)\n</pre> # Sample dataset col_names = 'RecordNum,Date Time(UTC),PTB110_mb,P4_mb,P1_mb,T1_C,RH1,T_CS215,RH_CS215,Vbat,N1Cts,N2Cts,N3Cts,N4Cts,N5Cts,N6Cts,N7Cts,N8Cts,N1ETsec,N3ETsec,N5ETsec,N7ETsec,N1T(C),N1RH,N5T(C),N5RH,GpsUTC,LatDec,LongDec,Alt,Qual,NumSats,HDOP,Speed_kmh,COG,SpeedQuality,strDate'.split(',') df = pd.read_csv('https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/rover/gypsum_transect_01_may_2018.KSU', skiprows=20, names=col_names) df['LongDec'] = df['LongDec'] * -1 # Raw data is in absolute values  # Parse timestamps and set as index df['timestamp'] = pd.to_datetime(df['Date Time(UTC)']) df.set_index(df['timestamp'], inplace=True)  # Remove rows with missing coordinates df['LatDec'].replace(0.0, np.nan, inplace=True) df['LongDec'].replace(0.0, np.nan, inplace=True) df.dropna(axis=0, subset=['LatDec','LongDec'], inplace=True) df.reset_index(drop=True, inplace=True)  # Display a few rows to visualize dataset df.head(3)  Out[2]: RecordNum Date Time(UTC) PTB110_mb P4_mb P1_mb T1_C RH1 T_CS215 RH_CS215 Vbat ... LongDec Alt Qual NumSats HDOP Speed_kmh COG SpeedQuality strDate timestamp 0 2 2018/05/01 14:15:00 962.95 962.8 961.4 23.2 35.4 20.9 72.7 13.574 ... -97.37195 393.2 2.0 10 0.8 0.00 270.7 A 10518.0 2018-05-01 14:15:00 1 3 2018/05/01 14:16:00 962.88 962.7 961.3 23.3 35.5 21.0 72.7 13.417 ... -97.37197 387.2 2.0 11 0.8 0.00 270.7 A 10518.0 2018-05-01 14:16:00 2 4 2018/05/01 14:17:00 962.64 962.5 961.1 23.4 35.4 21.2 72.2 13.282 ... -97.37199 388.2 1.0 11 0.8 3.89 356.3 A 10518.0 2018-05-01 14:17:00 <p>3 rows \u00d7 38 columns</p> <p>Next, convert the latitude and longitude to UTM coordinates (x and y). A scatter plot is created to visualize the survey points.</p> In\u00a0[3]: Copied! <pre># Convert Lat and Lon to X and Y\ndf['x'],df['y'] = crnpy.latlon_to_utm(df['LatDec'], df['LongDec'], 14, missing_values=0.0)\n\n# Create figure of survey points\nplt.figure(figsize=(5,5))\nplt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w')\nplt.ticklabel_format(scilimits=(-5,5))\nplt.xlabel('Easting')\nplt.ylabel('Northing')\nplt.show()\n</pre> # Convert Lat and Lon to X and Y df['x'],df['y'] = crnpy.latlon_to_utm(df['LatDec'], df['LongDec'], 14, missing_values=0.0)  # Create figure of survey points plt.figure(figsize=(5,5)) plt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w') plt.ticklabel_format(scilimits=(-5,5)) plt.xlabel('Easting') plt.ylabel('Northing') plt.show()  <p>The counts are normalized to counts per minute in case some observations covered a different timespan and total neutron counts are computed.</p> In\u00a0[4]: Copied! <pre># Define columns names\ncounts_colums = ['N1Cts', 'N2Cts', 'N3Cts','N4Cts', 'N5Cts', 'N6Cts', 'N7Cts', 'N8Cts']\ncont_times_col = ['N1ETsec', 'N1ETsec', 'N3ETsec','N3ETsec', 'N5ETsec', 'N5ETsec', 'N7ETsec', 'N7ETsec']\n\n# Normalize counts to counts/min\ndf[counts_colums] = \\\n    crnpy.normalize_counts(df[counts_colums], \\\n                           count_time=60, count_times=df[cont_times_col])\n\n# Compute total neutron counts\ndf['total_counts'] = crnpy.compute_total_raw_counts(df[counts_colums])\n</pre> # Define columns names counts_colums = ['N1Cts', 'N2Cts', 'N3Cts','N4Cts', 'N5Cts', 'N6Cts', 'N7Cts', 'N8Cts'] cont_times_col = ['N1ETsec', 'N1ETsec', 'N3ETsec','N3ETsec', 'N5ETsec', 'N5ETsec', 'N7ETsec', 'N7ETsec']  # Normalize counts to counts/min df[counts_colums] = \\     crnpy.normalize_counts(df[counts_colums], \\                            count_time=60, count_times=df[cont_times_col])  # Compute total neutron counts df['total_counts'] = crnpy.compute_total_raw_counts(df[counts_colums]) <p>Find stations with a cutoff rigidity similar to the estimated value based on the latitude and longitude, ensuring that the reference station is under a similar earth electromagnetic field. Note that the station is hardcoded in the second line as <code>station=\"NEWK\"</code>. The user is required to manually define this after considering the potential options suggested.</p> In\u00a0[5]: Copied! <pre>#Find stations with cutoff rigidity similar to estimated by lat,lon\ncrnpy.find_neutron_detectors(crnpy.cutoff_rigidity(df['LatDec'][0], df['LongDec'][0]), start_date=df.iloc[0]['timestamp'], end_date=df.iloc[-1]['timestamp'])\n\n#Download data for one of the similar stations and add to df\nincoming_neutrons = crnpy.get_incoming_neutron_flux(start_date=df.iloc[0]['timestamp'], end_date=df.iloc[-1]['timestamp'], station=\"NEWK\", utc_offset=-5, expand_window=2)\n</pre> #Find stations with cutoff rigidity similar to estimated by lat,lon crnpy.find_neutron_detectors(crnpy.cutoff_rigidity(df['LatDec'][0], df['LongDec'][0]), start_date=df.iloc[0]['timestamp'], end_date=df.iloc[-1]['timestamp'])  #Download data for one of the similar stations and add to df incoming_neutrons = crnpy.get_incoming_neutron_flux(start_date=df.iloc[0]['timestamp'], end_date=df.iloc[-1]['timestamp'], station=\"NEWK\", utc_offset=-5, expand_window=2) <pre>\nSelect a station with an altitude similar to that of your location. For more information go to: 'https://www.nmdb.eu/nest/help.php#helpstations\n\nYour cutoff rigidity is 2.99 GV\n    STID                          NAME     R  Altitude_m  Period available\n13  DRBS                       Dourbes  3.18         225              True\n31  MCRL  Mobile Cosmic Ray Laboratory  2.46         200              True\n33  MOSC                        Moscow  2.43         200              True\n40  NEWK                        Newark  2.40          50              True\n20  IRK3                     Irkustk 3  3.64        3000              True\n21  IRKT                       Irkustk  3.64         435              True\n</pre> <p>The incoming neutron flux is interpolated to match the measured timestamps, which is necessary to align the incoming neutron flux data with the rover data.</p> In\u00a0[6]: Copied! <pre># Interpolate incomming flux hourly to measured timestamps (~ every minute)\ndf['incoming_flux']=crnpy.interpolate_incoming_flux(incoming_neutrons, timestamps=df['timestamp']).values\n</pre> # Interpolate incomming flux hourly to measured timestamps (~ every minute) df['incoming_flux']=crnpy.interpolate_incoming_flux(incoming_neutrons, timestamps=df['timestamp']).values <p>NaN values in the atmospheric data are filled. The neutron counts are then corrected for atmospheric variables and the incoming neutron flux. Optionally it is possible to pass <code>incoming_Ref</code> parameter in <code>atm_correction()</code> to fix a desired value as the reference incoming count for the reference station.</p> In\u00a0[7]: Copied! <pre># Fill NaN values in atmospheric data\ndf[['PTB110_mb', 'RH_CS215', 'T_CS215']] = crnpy.fill_missing_atm(df[['PTB110_mb', 'RH_CS215', 'T_CS215']])\n\n# Correct count by atmospheric variables and incoming flux\ndf['corrected_counts']=crnpy.atm_correction(df['total_counts'], pressure=df['PTB110_mb'], humidity=df['RH_CS215'], temp=df['T_CS215'],\n                                     Pref=df['PTB110_mb'].mean(), Aref=0, L=130, incoming_neutrons=df['incoming_flux'])\n</pre> # Fill NaN values in atmospheric data df[['PTB110_mb', 'RH_CS215', 'T_CS215']] = crnpy.fill_missing_atm(df[['PTB110_mb', 'RH_CS215', 'T_CS215']])  # Correct count by atmospheric variables and incoming flux df['corrected_counts']=crnpy.atm_correction(df['total_counts'], pressure=df['PTB110_mb'], humidity=df['RH_CS215'], temp=df['T_CS215'],                                      Pref=df['PTB110_mb'].mean(), Aref=0, L=130, incoming_neutrons=df['incoming_flux']) <pre>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py:366: UserWarning: Reference incoming neutron flux not provided. Using first value of incoming neutron flux.\n  warnings.warn('Reference incoming neutron flux not provided. Using first value of incoming neutron flux.')\n</pre> <p>The corrected counts are smoothed using a 2D smoothing function. The smoothed counts are then converted to volumetric water content (VWC) using the counts_to_vwc function.</p> In\u00a0[8]: Copied! <pre># Smooth variable\ndf['corrected_smoothed'] = crnpy.smooth_2D(df['x'],\n                                        df['y'],\n                                        df['corrected_counts'],\n                                        buffer= 800, method='median', rnd=True)\n\n# Estimate Soil Columetric Water Content\ndf['VWC']=crnpy.counts_to_vwc(df['corrected_smoothed'], N0=550, bulk_density=1.3, Wlat=0.03, Wsoc=0.01)\n\n# Drop VWC NaN values before interpolating values\ndf = df.dropna(subset=['VWC'])\n\n# Interpolate variable\nX_pred, Y_pred, Z_pred = crnpy.interpolate_2D(df['x'],\n                                        df['y'],\n                                        df['VWC'],\n                                        dx=250, dy=250, method='cubic')\n</pre> # Smooth variable df['corrected_smoothed'] = crnpy.smooth_2D(df['x'],                                         df['y'],                                         df['corrected_counts'],                                         buffer= 800, method='median', rnd=True)  # Estimate Soil Columetric Water Content df['VWC']=crnpy.counts_to_vwc(df['corrected_smoothed'], N0=550, bulk_density=1.3, Wlat=0.03, Wsoc=0.01)  # Drop VWC NaN values before interpolating values df = df.dropna(subset=['VWC'])  # Interpolate variable X_pred, Y_pred, Z_pred = crnpy.interpolate_2D(df['x'],                                         df['y'],                                         df['VWC'],                                         dx=250, dy=250, method='cubic')   <p>A gridded map of the Volumetric Water Content (VWC) is created using the interpolated x, y, and VWC values.</p> In\u00a0[9]: Copied! <pre>cmap = plt.colormaps['RdYlBu']\n\nplt.figure(figsize=(6,6))\nplt.title('Gridded map')\nplt.pcolormesh(X_pred, Y_pred, Z_pred, cmap=cmap)\nplt.colorbar(label=r\"Volumetric Water Content $(cm^3 \\cdot cm^{-3})$\", location='right')\nplt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w')\nplt.ticklabel_format(scilimits=(-5,5))\nplt.xlabel('Easting', size=14)\nplt.ylabel('Northing', size=14)\nplt.show()\n</pre> cmap = plt.colormaps['RdYlBu']  plt.figure(figsize=(6,6)) plt.title('Gridded map') plt.pcolormesh(X_pred, Y_pred, Z_pred, cmap=cmap) plt.colorbar(label=r\"Volumetric Water Content $(cm^3 \\cdot cm^{-3})$\", location='right') plt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w') plt.ticklabel_format(scilimits=(-5,5)) plt.xlabel('Easting', size=14) plt.ylabel('Northing', size=14) plt.show()  <p>Finally, a contour map of the VWC is created and displayed.</p> In\u00a0[10]: Copied! <pre># Show contour map\ncmap = plt.colormaps['RdYlBu']\n\nplt.figure(figsize=(7,6))\nplt.title('Contours')\nplt.contourf(X_pred, Y_pred, Z_pred, cmap=cmap)\nplt.ticklabel_format(scilimits=(-5,5))\nplt.colorbar(label=r\"Volumetric Water Content $(cm^3 \\cdot cm^{-3})$\", location='right')\nplt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w')\nplt.show()\n</pre> # Show contour map cmap = plt.colormaps['RdYlBu']  plt.figure(figsize=(7,6)) plt.title('Contours') plt.contourf(X_pred, Y_pred, Z_pred, cmap=cmap) plt.ticklabel_format(scilimits=(-5,5)) plt.colorbar(label=r\"Volumetric Water Content $(cm^3 \\cdot cm^{-3})$\", location='right') plt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w') plt.show()  In\u00a0[16]: Copied! <pre>Z_pred.mean()\n</pre> Z_pred.mean() Out[16]: <pre>nan</pre> In\u00a0[18]: Copied! <pre>np.nanmean(Z_pred)\n</pre> np.nanmean(Z_pred) Out[18]: <pre>0.158903165242229</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/rover/Hydroinnova_rover_example-Copy1/#processing-and-analyzing-hydroinnova-rover-data-with-crnpy","title":"Processing and Analyzing Hydroinnova Rover Data with CRNPy\u00b6","text":"<p>This tutorial demonstrates how to process and analyze data from a rover using the Cosmic Ray Neutron Python (CRNPy) library. The steps include loading the data, converting geographical coordinates to Cartesian coordinates, normalizing neutron counts, correcting for atmospheric effects, and visualizing the results.</p> <p> Overview of the example workflow.</p> <p>First import the required packages.</p>"},{"location":"examples/rover/Hydroinnova_rover_example/","title":"Processing and Analyzing Hydroinnova Rover Data with CRNPy","text":"In\u00a0[1]: Copied! <pre># Import modules\nimport numpy as np\nimport pandas as pd\nfrom crnpy import crnpy\nimport matplotlib.pyplot as plt\n</pre> # Import modules import numpy as np import pandas as pd from crnpy import crnpy import matplotlib.pyplot as plt   <p>Load the data stored in the .csv file.</p> In\u00a0[2]: Copied! <pre># Sample dataset\ncol_names = 'RecordNum,Date Time(UTC),PTB110_mb,P4_mb,P1_mb,T1_C,RH1,T_CS215,RH_CS215,Vbat,N1Cts,N2Cts,N3Cts,N4Cts,N5Cts,N6Cts,N7Cts,N8Cts,N1ETsec,N3ETsec,N5ETsec,N7ETsec,N1T(C),N1RH,N5T(C),N5RH,GpsUTC,LatDec,LongDec,Alt,Qual,NumSats,HDOP,Speed_kmh,COG,SpeedQuality,strDate'.split(',')\ndf = pd.read_csv('https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/rover/gypsum_transect_01_may_2018.KSU', skiprows=20, names=col_names)\ndf['LongDec'] = df['LongDec'] * -1 # Raw data is in absolute values\n\n# Parse timestamps and set as index\ndf['timestamp'] = pd.to_datetime(df['Date Time(UTC)'])\ndf.set_index(df['timestamp'], inplace=True)\n\n# Remove rows with missing coordinates\ndf['LatDec'].replace(0.0, np.nan, inplace=True)\ndf['LongDec'].replace(0.0, np.nan, inplace=True)\ndf.dropna(axis=0, subset=['LatDec','LongDec'], inplace=True)\ndf.reset_index(drop=True, inplace=True)\n\n# Display a few rows to visualize dataset\ndf.head(3)\n</pre> # Sample dataset col_names = 'RecordNum,Date Time(UTC),PTB110_mb,P4_mb,P1_mb,T1_C,RH1,T_CS215,RH_CS215,Vbat,N1Cts,N2Cts,N3Cts,N4Cts,N5Cts,N6Cts,N7Cts,N8Cts,N1ETsec,N3ETsec,N5ETsec,N7ETsec,N1T(C),N1RH,N5T(C),N5RH,GpsUTC,LatDec,LongDec,Alt,Qual,NumSats,HDOP,Speed_kmh,COG,SpeedQuality,strDate'.split(',') df = pd.read_csv('https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/rover/gypsum_transect_01_may_2018.KSU', skiprows=20, names=col_names) df['LongDec'] = df['LongDec'] * -1 # Raw data is in absolute values  # Parse timestamps and set as index df['timestamp'] = pd.to_datetime(df['Date Time(UTC)']) df.set_index(df['timestamp'], inplace=True)  # Remove rows with missing coordinates df['LatDec'].replace(0.0, np.nan, inplace=True) df['LongDec'].replace(0.0, np.nan, inplace=True) df.dropna(axis=0, subset=['LatDec','LongDec'], inplace=True) df.reset_index(drop=True, inplace=True)  # Display a few rows to visualize dataset df.head(3)  Out[2]: RecordNum Date Time(UTC) PTB110_mb P4_mb P1_mb T1_C RH1 T_CS215 RH_CS215 Vbat ... LongDec Alt Qual NumSats HDOP Speed_kmh COG SpeedQuality strDate timestamp 0 2 2018/05/01 14:15:00 962.95 962.8 961.4 23.2 35.4 20.9 72.7 13.574 ... -97.37195 393.2 2.0 10 0.8 0.00 270.7 A 10518.0 2018-05-01 14:15:00 1 3 2018/05/01 14:16:00 962.88 962.7 961.3 23.3 35.5 21.0 72.7 13.417 ... -97.37197 387.2 2.0 11 0.8 0.00 270.7 A 10518.0 2018-05-01 14:16:00 2 4 2018/05/01 14:17:00 962.64 962.5 961.1 23.4 35.4 21.2 72.2 13.282 ... -97.37199 388.2 1.0 11 0.8 3.89 356.3 A 10518.0 2018-05-01 14:17:00 <p>3 rows \u00d7 38 columns</p> <p>Next, convert the latitude and longitude to UTM coordinates (x and y). A scatter plot is created to visualize the survey points.</p> In\u00a0[3]: Copied! <pre># Convert Lat and Lon to X and Y\ndf['x'],df['y'] = crnpy.latlon_to_utm(df['LatDec'], df['LongDec'], 14, missing_values=0.0)\n\n# Create figure of survey points\nplt.figure(figsize=(5,5))\nplt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w')\nplt.ticklabel_format(scilimits=(-5,5))\nplt.xlabel('Easting')\nplt.ylabel('Northing')\nplt.show()\n</pre> # Convert Lat and Lon to X and Y df['x'],df['y'] = crnpy.latlon_to_utm(df['LatDec'], df['LongDec'], 14, missing_values=0.0)  # Create figure of survey points plt.figure(figsize=(5,5)) plt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w') plt.ticklabel_format(scilimits=(-5,5)) plt.xlabel('Easting') plt.ylabel('Northing') plt.show()  <p>The counts are normalized to counts per minute in case some observations covered a different timespan and total neutron counts are computed.</p> In\u00a0[4]: Copied! <pre># Define columns names\ncounts_colums = ['N1Cts', 'N2Cts', 'N3Cts','N4Cts', 'N5Cts', 'N6Cts', 'N7Cts', 'N8Cts']\ncont_times_col = ['N1ETsec', 'N1ETsec', 'N3ETsec','N3ETsec', 'N5ETsec', 'N5ETsec', 'N7ETsec', 'N7ETsec']\n\n# Normalize counts to counts/min\ndf[counts_colums] = \\\n    crnpy.normalize_counts(df[counts_colums], \\\n                           count_time=60, count_times=df[cont_times_col])\n\n# Compute total neutron counts\ndf['total_counts'] = crnpy.compute_total_raw_counts(df[counts_colums])\n</pre> # Define columns names counts_colums = ['N1Cts', 'N2Cts', 'N3Cts','N4Cts', 'N5Cts', 'N6Cts', 'N7Cts', 'N8Cts'] cont_times_col = ['N1ETsec', 'N1ETsec', 'N3ETsec','N3ETsec', 'N5ETsec', 'N5ETsec', 'N7ETsec', 'N7ETsec']  # Normalize counts to counts/min df[counts_colums] = \\     crnpy.normalize_counts(df[counts_colums], \\                            count_time=60, count_times=df[cont_times_col])  # Compute total neutron counts df['total_counts'] = crnpy.compute_total_raw_counts(df[counts_colums]) <p>Find stations with a cutoff rigidity similar to the estimated value based on the latitude and longitude, ensuring that the reference station is under a similar earth electromagnetic field. Note that the station is hardcoded in the second line as <code>station=\"NEWK\"</code>. The user is required to manually define this after considering the potential options suggested.</p> In\u00a0[5]: Copied! <pre>#Find stations with cutoff rigidity similar to estimated by lat,lon\ncrnpy.find_neutron_detectors(crnpy.cutoff_rigidity(df['LatDec'][0], df['LongDec'][0]), start_date=df.iloc[0]['timestamp'], end_date=df.iloc[-1]['timestamp'])\n\n#Download data for one of the similar stations and add to df\nincoming_neutrons = crnpy.get_incoming_neutron_flux(start_date=df.iloc[0]['timestamp'], end_date=df.iloc[-1]['timestamp'], station=\"NEWK\", utc_offset=-5, expand_window=2)\n</pre> #Find stations with cutoff rigidity similar to estimated by lat,lon crnpy.find_neutron_detectors(crnpy.cutoff_rigidity(df['LatDec'][0], df['LongDec'][0]), start_date=df.iloc[0]['timestamp'], end_date=df.iloc[-1]['timestamp'])  #Download data for one of the similar stations and add to df incoming_neutrons = crnpy.get_incoming_neutron_flux(start_date=df.iloc[0]['timestamp'], end_date=df.iloc[-1]['timestamp'], station=\"NEWK\", utc_offset=-5, expand_window=2) <pre>\nSelect a station with an altitude similar to that of your location. For more information go to: 'https://www.nmdb.eu/nest/help.php#helpstations\n\nYour cutoff rigidity is 2.99 GV\n    STID                          NAME     R  Altitude_m  Period available\n13  DRBS                       Dourbes  3.18         225              True\n31  MCRL  Mobile Cosmic Ray Laboratory  2.46         200              True\n33  MOSC                        Moscow  2.43         200              True\n40  NEWK                        Newark  2.40          50              True\n20  IRK3                     Irkustk 3  3.64        3000              True\n21  IRKT                       Irkustk  3.64         435              True\n</pre> <p>The incoming neutron flux is interpolated to match the measured timestamps, which is necessary to align the incoming neutron flux data with the rover data.</p> In\u00a0[6]: Copied! <pre># Interpolate incomming flux hourly to measured timestamps (~ every minute)\ndf['incoming_flux']=crnpy.interpolate_incoming_flux(incoming_neutrons, timestamps=df['timestamp']).values\n</pre> # Interpolate incomming flux hourly to measured timestamps (~ every minute) df['incoming_flux']=crnpy.interpolate_incoming_flux(incoming_neutrons, timestamps=df['timestamp']).values <p>NaN values in the atmospheric data are filled. The neutron counts are then corrected for atmospheric variables and the incoming neutron flux. Optionally it is possible to pass <code>incoming_Ref</code> parameter in <code>atm_correction()</code> to fix a desired value as the reference incoming count for the reference station.</p> In\u00a0[7]: Copied! <pre># Fill NaN values in atmospheric data\ndf[['PTB110_mb', 'RH_CS215', 'T_CS215']] = crnpy.fill_missing_atm(df[['PTB110_mb', 'RH_CS215', 'T_CS215']])\n\n# Correct count by atmospheric variables and incoming flux\ndf['corrected_counts']=crnpy.atm_correction(df['total_counts'], pressure=df['PTB110_mb'], humidity=df['RH_CS215'], temp=df['T_CS215'],\n                                     Pref=df['PTB110_mb'].mean(), Aref=0, L=130, incoming_neutrons=df['incoming_flux'])\n</pre> # Fill NaN values in atmospheric data df[['PTB110_mb', 'RH_CS215', 'T_CS215']] = crnpy.fill_missing_atm(df[['PTB110_mb', 'RH_CS215', 'T_CS215']])  # Correct count by atmospheric variables and incoming flux df['corrected_counts']=crnpy.atm_correction(df['total_counts'], pressure=df['PTB110_mb'], humidity=df['RH_CS215'], temp=df['T_CS215'],                                      Pref=df['PTB110_mb'].mean(), Aref=0, L=130, incoming_neutrons=df['incoming_flux']) <pre>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py:366: UserWarning: Reference incoming neutron flux not provided. Using first value of incoming neutron flux.\n  warnings.warn('Reference incoming neutron flux not provided. Using first value of incoming neutron flux.')\n</pre> <p>The corrected counts are smoothed using a 2D smoothing function. The smoothed counts are then converted to volumetric water content (VWC) using the counts_to_vwc function.</p> In\u00a0[8]: Copied! <pre># Smooth variable\ndf['corrected_smoothed'] = crnpy.smooth_2D(df['x'],\n                                        df['y'],\n                                        df['corrected_counts'],\n                                        buffer= 800, method='median', rnd=True)\n\n# Estimate Soil Columetric Water Content\ndf['VWC']=crnpy.counts_to_vwc(df['corrected_smoothed'], N0=550, bulk_density=1.3, Wlat=0.03, Wsoc=0.01)\n\n# Drop VWC NaN values before interpolating values\ndf = df.dropna(subset=['VWC'])\n\n# Interpolate variable\nX_pred, Y_pred, Z_pred = crnpy.interpolate_2D(df['x'],\n                                        df['y'],\n                                        df['VWC'],\n                                        dx=250, dy=250, method='cubic')\n</pre> # Smooth variable df['corrected_smoothed'] = crnpy.smooth_2D(df['x'],                                         df['y'],                                         df['corrected_counts'],                                         buffer= 800, method='median', rnd=True)  # Estimate Soil Columetric Water Content df['VWC']=crnpy.counts_to_vwc(df['corrected_smoothed'], N0=550, bulk_density=1.3, Wlat=0.03, Wsoc=0.01)  # Drop VWC NaN values before interpolating values df = df.dropna(subset=['VWC'])  # Interpolate variable X_pred, Y_pred, Z_pred = crnpy.interpolate_2D(df['x'],                                         df['y'],                                         df['VWC'],                                         dx=250, dy=250, method='cubic')   <p>A gridded map of the Volumetric Water Content (VWC) is created using the interpolated x, y, and VWC values.</p> In\u00a0[9]: Copied! <pre>cmap = plt.colormaps['RdYlBu']\n\nplt.figure(figsize=(6,6))\nplt.title('Gridded map')\nplt.pcolormesh(X_pred, Y_pred, Z_pred, cmap=cmap)\nplt.colorbar(label=r\"Volumetric Water Content $(cm^3 \\cdot cm^{-3})$\", location='right')\nplt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w')\nplt.ticklabel_format(scilimits=(-5,5))\nplt.xlabel('Easting', size=14)\nplt.ylabel('Northing', size=14)\nplt.show()\n</pre> cmap = plt.colormaps['RdYlBu']  plt.figure(figsize=(6,6)) plt.title('Gridded map') plt.pcolormesh(X_pred, Y_pred, Z_pred, cmap=cmap) plt.colorbar(label=r\"Volumetric Water Content $(cm^3 \\cdot cm^{-3})$\", location='right') plt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w') plt.ticklabel_format(scilimits=(-5,5)) plt.xlabel('Easting', size=14) plt.ylabel('Northing', size=14) plt.show()  <p>Finally, a contour map of the VWC is created and displayed.</p> In\u00a0[10]: Copied! <pre># Show contour map\ncmap = plt.colormaps['RdYlBu']\n\nplt.figure(figsize=(7,6))\nplt.title('Contours')\nplt.contourf(X_pred, Y_pred, Z_pred, cmap=cmap)\nplt.ticklabel_format(scilimits=(-5,5))\nplt.colorbar(label=r\"Volumetric Water Content $(cm^3 \\cdot cm^{-3})$\", location='right')\nplt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w')\nplt.show()\n</pre> # Show contour map cmap = plt.colormaps['RdYlBu']  plt.figure(figsize=(7,6)) plt.title('Contours') plt.contourf(X_pred, Y_pred, Z_pred, cmap=cmap) plt.ticklabel_format(scilimits=(-5,5)) plt.colorbar(label=r\"Volumetric Water Content $(cm^3 \\cdot cm^{-3})$\", location='right') plt.scatter(df['x'], df['y'], marker='o', edgecolor='k', facecolor='w') plt.show()"},{"location":"examples/rover/Hydroinnova_rover_example/#processing-and-analyzing-hydroinnova-rover-data-with-crnpy","title":"Processing and Analyzing Hydroinnova Rover Data with CRNPy\u00b6","text":"<p>This tutorial demonstrates how to process and analyze data from a rover using the Cosmic Ray Neutron Python (CRNPy) library. The steps include loading the data, converting geographical coordinates to Cartesian coordinates, normalizing neutron counts, correcting for atmospheric effects, and visualizing the results.</p> <p> Overview of the example workflow.</p> <p>First import the required packages.</p>"},{"location":"examples/stationary/example_RDT_station/","title":"Processing and Analyzing RDT stationary detector observations with CRNPy","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport numpy as np\nfrom crnpy import crnpy\n</pre> import pandas as pd import numpy as np from crnpy import crnpy In\u00a0[2]: Copied! <pre># Read the DataFrame\ndf = pd.read_csv(\"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/stationary/rdt.csv\", names=['timestamp','pressure','RH', 'T','DP','BattVolt','counts_1','counts_2','counts_3'])\n\n# Parse timestamps and set as index\ndf['timestamp'] = pd.to_datetime(df['timestamp'])\ndf.set_index(df['timestamp'], inplace=True)\n</pre> # Read the DataFrame df = pd.read_csv(\"https://raw.githubusercontent.com/soilwater/crnpy/main/docs/examples/stationary/rdt.csv\", names=['timestamp','pressure','RH', 'T','DP','BattVolt','counts_1','counts_2','counts_3'])  # Parse timestamps and set as index df['timestamp'] = pd.to_datetime(df['timestamp']) df.set_index(df['timestamp'], inplace=True) <p>Count times are computed from timestamp. If 'NaN' values are present, the <code>fill_counts()</code> function will replace them. Recheck for 'NaN' values to confirm that they've been adequately filled.</p> In\u00a0[3]: Copied! <pre># Get counting times\ndf['count_time']=crnpy.count_time(df[['counts_1','counts_2','counts_3']])\n\n# Check counts for nan values in the counts\nprint(\"dectors with nan:\", [df['counts_1'].isna().any(),df['counts_2'].isna().any(),df['counts_3'].isna().any()])\n\n# Fill nan values in detector 2\ndf[['counts_1','counts_2','counts_3']] = crnpy.fill_counts(df[['counts_1','counts_2','counts_3']], count_times=df['count_time'])\n\n# Check counts for nan values in the counts\nprint(\"dectors with nan:\", [df['counts_1'].isna().any(),df['counts_2'].isna().any(),df['counts_3'].isna().any()])\n\ndf[['counts_1','counts_2','counts_3']].head()\n</pre> # Get counting times df['count_time']=crnpy.count_time(df[['counts_1','counts_2','counts_3']])  # Check counts for nan values in the counts print(\"dectors with nan:\", [df['counts_1'].isna().any(),df['counts_2'].isna().any(),df['counts_3'].isna().any()])  # Fill nan values in detector 2 df[['counts_1','counts_2','counts_3']] = crnpy.fill_counts(df[['counts_1','counts_2','counts_3']], count_times=df['count_time'])  # Check counts for nan values in the counts print(\"dectors with nan:\", [df['counts_1'].isna().any(),df['counts_2'].isna().any(),df['counts_3'].isna().any()])  df[['counts_1','counts_2','counts_3']].head()  <pre>dectors with nan: [False, True, False]\nUsing median count time as expected count time: 3600.0\ndectors with nan: [False, False, False]\n</pre> Out[3]: counts_1 counts_2 counts_3 timestamp 2020-04-10 09:47:00 848 716.0 742 2020-04-10 10:47:00 436 7200.0 796 2020-04-10 11:17:00 389 396.0 354 2020-04-10 12:17:00 820 786.0 714 2020-04-10 13:17:00 844 707.0 734 <p>Normalize the counts to counts per hour using the <code>normalize_counts()</code> function from the crnpy library.</p> In\u00a0[4]: Copied! <pre># Normalize counts to counts/h\ndf[['counts_1','counts_2','counts_3']] = crnpy.normalize_counts(df[['counts_1','counts_2','counts_3']], count_time=3600, count_times=df['count_time'])\n\ndf[['counts_1','counts_2','counts_3']].head()\n</pre> # Normalize counts to counts/h df[['counts_1','counts_2','counts_3']] = crnpy.normalize_counts(df[['counts_1','counts_2','counts_3']], count_time=3600, count_times=df['count_time'])  df[['counts_1','counts_2','counts_3']].head() Out[4]: counts_1 counts_2 counts_3 timestamp 2020-04-10 09:47:00 NaN NaN NaN 2020-04-10 10:47:00 436.0 7200.0 796.0 2020-04-10 11:17:00 778.0 792.0 708.0 2020-04-10 12:17:00 820.0 786.0 714.0 2020-04-10 13:17:00 844.0 707.0 734.0 <p>Utilize the <code>compute_total_raw_counts()</code> function to calculate the total counts across all detectors. After calculating the total counts, outliers are discarded using the <code>drop_outliers()</code> function.</p> In\u00a0[5]: Copied! <pre>df['total_counts'] = crnpy.compute_total_raw_counts(df[['counts_1','counts_2','counts_3']], nan_strategy='average')\ndf['total_counts']=crnpy.drop_outliers(df['total_counts'], min_counts=1500, max_counts=3500, window = 11)\ndf.plot('timestamp', 'total_counts')\n</pre> df['total_counts'] = crnpy.compute_total_raw_counts(df[['counts_1','counts_2','counts_3']], nan_strategy='average') df['total_counts']=crnpy.drop_outliers(df['total_counts'], min_counts=1500, max_counts=3500, window = 11) df.plot('timestamp', 'total_counts') <pre>NaN values found. Replacing missing values with average of other detectors before summing.\nDiscarded counts below 1500: 1\nDiscarded counts above 3500: 119\nDiscarded 64 outliers using modified Z-score.\n</pre> Out[5]: <pre>&lt;Axes: xlabel='timestamp'&gt;</pre> <p>Find similar stations based on cutoff rigidity, which is estimated using latitude and longitude values. See <code>get_incoming_neutron_flux()</code> and <code>find_neutron_detectors()</code>. Note that the station is hardcoded in the second line as <code>station=\"IRKT\"</code>. The user is required to manually define this after considering the potential options suggested.</p> In\u00a0[6]: Copied! <pre>#Find stations with cutoff rigidity similar to estimated by lat,lon\ncrnpy.find_neutron_detectors(crnpy.cutoff_rigidity(39.1, -96.6), start_date=df['timestamp'][0], end_date= df['timestamp'][-1])\n\n#Download data for one of the similar stations and add to df\nincoming_neutrons = crnpy.get_incoming_neutron_flux(df['timestamp'][0], df['timestamp'][-1], station=\"IRKT\", utc_offset=-5)\ndf['incoming_flux']=crnpy.interpolate_incoming_flux(incoming_neutrons, timestamps=df['timestamp'])\n</pre> #Find stations with cutoff rigidity similar to estimated by lat,lon crnpy.find_neutron_detectors(crnpy.cutoff_rigidity(39.1, -96.6), start_date=df['timestamp'][0], end_date= df['timestamp'][-1])  #Download data for one of the similar stations and add to df incoming_neutrons = crnpy.get_incoming_neutron_flux(df['timestamp'][0], df['timestamp'][-1], station=\"IRKT\", utc_offset=-5) df['incoming_flux']=crnpy.interpolate_incoming_flux(incoming_neutrons, timestamps=df['timestamp']) <pre>\nSelect a station with an altitude similar to that of your location. For more information go to: 'https://www.nmdb.eu/nest/help.php#helpstations\n\nYour cutoff rigidity is 2.87 GV\n     STID     NAME     R  Altitude_m  Period available\n13   DRBS  Dourbes  3.18         225              True\n40   NEWK   Newark  2.40          50              True\n28  KIEL2   KielRT  2.36          54              True\n21   IRKT  Irkustk  3.64         435              True\n</pre> <p>This section is about correcting the atmospheric variables and incoming neutron flux. First, fill the missing values in the atmospheric data, then correct the count for atmospheric variables and incoming flux using <code>atm_correction()</code>.</p> In\u00a0[7]: Copied! <pre># Fill NaN values in atmospheric data\ndf[['pressure', 'RH', 'T']] = crnpy.fill_missing_atm(df[['pressure', 'RH', 'T']])\n# Correct count by atmospheric variables and incoming flux\ndf['total_counts']=crnpy.fill_counts(df['total_counts'])\ndf['corrected']=crnpy.atm_correction(df['total_counts'], pressure=df['pressure'], humidity=df['RH'], temp=df['T'], Pref=df['pressure'].mean(), Aref=0, L=130, incoming_neutrons=df['incoming_flux']).dropna()\n</pre> # Fill NaN values in atmospheric data df[['pressure', 'RH', 'T']] = crnpy.fill_missing_atm(df[['pressure', 'RH', 'T']]) # Correct count by atmospheric variables and incoming flux df['total_counts']=crnpy.fill_counts(df['total_counts']) df['corrected']=crnpy.atm_correction(df['total_counts'], pressure=df['pressure'], humidity=df['RH'], temp=df['T'], Pref=df['pressure'].mean(), Aref=0, L=130, incoming_neutrons=df['incoming_flux']).dropna()   <pre>No count time columns provided. Using timestamp index to compute count time.\nUsing median count time as expected count time: 3600.0\n</pre> <pre>C:\\Users\\jperaza\\AppData\\Local\\anaconda3\\envs\\crnpy\\lib\\site-packages\\crnpy\\crnpy.py:366: UserWarning: Reference incoming neutron flux not provided. Using first value of incoming neutron flux.\n  warnings.warn('Reference incoming neutron flux not provided. Using first value of incoming neutron flux.')\n</pre> <p>Smooth the corrected data using the Savitzky-Golay filter with the <code>smooth_1D()</code> function.</p> In\u00a0[8]: Copied! <pre># Filter using the Savitzky-Golay filter\ndf_filtered = crnpy.smooth_1D(df['corrected'].dropna(), window=11, order=3, method=\"savitzky_golay\")\n\ndf_filtered.plot()\n</pre> # Filter using the Savitzky-Golay filter df_filtered = crnpy.smooth_1D(df['corrected'].dropna(), window=11, order=3, method=\"savitzky_golay\")  df_filtered.plot() Out[8]: <pre>&lt;Axes: xlabel='timestamp'&gt;</pre> <p>Convert the smoothed neutron counts to Volumetric Water Content (VWC) using the <code>counts_to_vwc()</code>. The function considers the smoothed neutron counts, $N_0$ specific parameter, soil bulk density, weight percent of latent water (Wlat), and weight percent of soil organic carbon (Wsoc). After conversion, plot the VWC against the timestamp for visual analysis.</p> In\u00a0[9]: Copied! <pre>N0_rdt = 3767 # Patrignani, A., Ochsner, T. E., Montag, B., &amp; Bellinger, S. (2021). A novel lithium foil cosmic-ray neutron detector for measuring field-scale soil moisture. Frontiers in Water, 3, 673185.\n\ndf['VWC']=crnpy.counts_to_vwc(df_filtered, N0=N0_rdt, bulk_density=1.4, Wlat=0.03, Wsoc=0.01)\ndf['VWC'].plot()\n</pre> N0_rdt = 3767 # Patrignani, A., Ochsner, T. E., Montag, B., &amp; Bellinger, S. (2021). A novel lithium foil cosmic-ray neutron detector for measuring field-scale soil moisture. Frontiers in Water, 3, 673185.  df['VWC']=crnpy.counts_to_vwc(df_filtered, N0=N0_rdt, bulk_density=1.4, Wlat=0.03, Wsoc=0.01) df['VWC'].plot() Out[9]: <pre>&lt;Axes: xlabel='timestamp'&gt;</pre>"},{"location":"examples/stationary/example_RDT_station/#processing-and-analyzing-rdt-stationary-detector-observations-with-crnpy","title":"Processing and Analyzing RDT stationary detector observations with CRNPy\u00b6","text":"<p>This tutorial, demonstrates how to process and analyze neutron detection data from 3 Radiation Detection Technologies, Inc (RDT) neutron detectors using the Cosmic Ray Neutron Python (CRNPy) library. The tutorial covers steps including data loading, count data processing, normalization, outlier removal, atmospheric correction, and conversion of neutron counts to Volumetric Water Content (VWC).</p> <p> Overview of the example workflow.</p> <p>Firstly, import the required Python libraries, load the data from the .csv file. Converting the 'timestamp' column to datetime format is essential for time-based operations. Lastly, setting 'timestamp' as the DataFrame index simplifies the time series analysis.</p>"}]}